[{"title":"使用vagrant搭建虚拟开发环境","date":"2018-09-10T13:51:45.000Z","path":"2018/09/10/使用vagrant搭建虚拟开发环境/","text":"虚拟机通过镜像文件创建虚拟环境: virtualbox VMware 什么是Vagrant&emsp;&emsp;Vagrant是构建在虚拟化技术之上的虚拟机运行环境管理工具,它的运行依赖于虚拟机： 建立和删除虚拟机配置虚拟机运行参数管理虚拟机运行状态自动化配置和安装开发环境打包分发虚拟机运行环境 优点&emsp;&emsp;跨平台、可移动、自动化部署无需人工干预 软件安装 virtualbox vagrant(注意vagrant和virtualbox之间的版本关系) xshell vagrant命令虚拟机的本质底层还是一个操作系统，使用虚拟机创建虚拟环境使用.iso文件，vagrant创建虚拟环境使用.box文件。 vagrant常用命令： 命令 描述 vagrant box list 查看目前已有的box vagrant box add 新增加一个box vagrant box remove 删除指定box vagrant init 初始化配置vagrantfile vagrant up 启动虚拟机 vagrant ssh ssh登录虚拟机 vagrant suspend 挂起虚拟机 vagrant reload 重启虚拟机 vagrant halt 关闭虚拟机 vagrant status 查看虚拟机状态 vagrant status 删除虚拟机 实际操作 虚拟机创建的创建和查看&emsp;&emsp;Vagrant使用基础镜像来快速克隆虚拟机，而不是从头开始构建虚拟机。这些基础镜像在 Vagrant 中被称为“box”，并且指定用于 Vagrant 环境的 box 始终是创建新 Vagrantfile 后的第一步。下载好.box文件后使用vagrant box add 虚拟环境名称 box文件名创建虚拟环境 新建imooc文件夹，进入文件夹，初始化配置vagrantfile，此时会生成一个vagrantfile文件 执行vagrant up，会在virtualbox中多一个虚拟环境实例，但是命令行一直会提示 这是由于虚拟机获取不到物理机的公钥, 创建Vagrantfile文件&emsp;&emsp;配置 Vagrant 项目的第一步是创建 Vagrantfile 文件。Vagrantfile 文件的目的有两个： 设置项目的根目录。Vagrant 中的许多配置选项是相对于这个根目录的。描述运行项目的机器类型和资源，以及需要安装的软件和访问方式。 &emsp;&emsp;Vagrant 内置了 vagrant init 命令，用于将目录初始化为 Vagrant 使用。请在你的终端中输入以下命令：123$ mkdir vagrant_getting_started$ cd vagrant_getting_started$ vagrant init &emsp;&emsp;命令执行完后会在你的目录中创建 Vagrantfile 文件。可以查看这个文件，里面写满了注释和示例。虽然看起来很吓人，但不要害怕，我们会尽快修改它。&emsp;&emsp;也可以在预先存在的目录中使用 vagrant init 命令配置已经存在的项目使用 Vagrant。&emsp;&emsp;如果你使用版本控制，则 Vagrantfile 可以用于项目的版本控制。这样，每个与该项目合作的人都可以从 Vagrant 中受益，而无需任何前期工作. box的安装与使用&emsp;&emsp;Vagrant 使用基础镜像来快速克隆虚拟机，而不是从头开始构建虚拟机。这些基础镜像在 Vagrant 中被称为“box”，并且指定用于 Vagrant 环境的 box 始终是创建新 Vagrantfile 后的第一步。 安装 box通过vagrant box add命令可以将 box 加入到 Vagrant。这会将 box 存储在一个特定的名称下，以便多个 Vagrant 环境可以重复利用。如果你还没有添加一个 box，可以这样做：1$ vagrant box add hashicorp/precise64 &emsp;&emsp;这将从 HashiCorp 的 Vagrant Cloud box 目录 下载名为“hashicorp/precise64”的 box。虽然从 HashiCorp 的 Vagrant Cloud下载 box 是最便利的方式，你也可以从本地文件或指定的 URL 等添加 box。&emsp;&emsp;对于当前用户，box 全局存储。每个项目都使用一个 box 作为初始镜像来克隆，并且从不修改基本镜像。这意味着如果你有两个项目都使用我们刚刚添加的 hashicorp/precise64 这个 box，则在一台 guest 机器中添加文件将不会对另一台机器产生影响。&emsp;&emsp;在上面的命令中，你会注意到这些 box 是有命名空间的。box 分为两部分 - 用户名和 box 名 - 用斜线分隔。在上面的例子中，用户名是“hashicorp”，并且 box 是“precise64”。也可以通过 URL 或本地文件路径来指定 box，但入门指南中不会涉及这些内容。 命名空间不保证规范 box！一个常见的误解是像“ubuntu”这样的命名空间代表了 Ubuntu 这个 box 的规范空间。这是不真实的。Vagrant Cloud上的命名空间的行为与 GitHub 上的命名空间非常相似。正如 GitHub 的支持团队无法协助解决某人存储库中的问题一样，HashiCorp 的支持团队无法管理第三方发布的 box。 使用 box&emsp;&emsp;现在 box 已经添加到了 Vagrant，需要配置项目使用这个 box 作为基准镜像。打开空白的 Vagrantfile 文件添加下面的内容：123Vagrant.configure(&quot;2&quot;) do |config| config.vm.box = &quot;hashicorp/precise64&quot;end &emsp;&emsp;这个例子中的“hashicorp/precise64”必须要跟你在上面添加的 box 名字匹配。通过这个配置，Vagrant 知道需要使用哪个 box。如果之前没有添加 box，Vagrant 会在运行时自动下载并添加 box。&emsp;&emsp;可以通过 config.vm.box_version 来指定一个 box 的确切版本：1234Vagrant.configure(&quot;2&quot;) do |config| config.vm.box = &quot;hashicorp/precise64&quot; config.vm.box_version = &quot;1.1.0&quot;end &emsp;&emsp;也可以直接使用 config.vm.box_url 指定一个 box 的 URL：1234Vagrant.configure(&quot;2&quot;) do |config| config.vm.box = &quot;hashicorp/precise64&quot; config.vm.box_url = &quot;http://files.vagrantup.com/precise64.box&quot;end 在下一节中，我们将启动 Vagrant 环境并与其进行一点互动。 查找更多的 box&emsp;&emsp;对于本入门指南的其余部分，我们将仅使用之前添加的“hashicorp/precise64” box。但是在完成入门指南后，第一个问题可能就是“我在哪里可以找到更多的 box？”&emsp;&emsp;HashiCorp 的 Vagrant Cloud box 目录 是寻找更多 box 的最佳地点。HashiCorp 的 Vagrant Cloud 有一个可以通过各种平台和技术免费使用的公共目录。HashiCorp 的 Vagrant Cloud 也有很好的搜索功能，可以让你找到你关心的 box。&emsp;&emsp;除了寻找免费的 box，HashiCorp 的 Vagrant Cloud 允许你托管自己的 box，如果打算为自己的组织创建 box 的话还可以创建私有 box。 启动 vagrant 及 通过 ssh 登录虚拟机&emsp;&emsp;在终端运行 vagrant up 命令即可启动 Vagrant 环境：1$ vagrant up &emsp;&emsp;不到一分钟，命令就会执行完毕，运行 Ubuntu 的虚拟机会启动成功。Vagrant 运行虚拟机的时候没有 UI 界面。可以通过 SSH 连接到机器判断机器是否运行成功：1$ vagrant ssh &emsp;&emsp;这个命令会让你进入一个完整的 SSH 会话。会话建立后可以与机器进行交互，做任何你想做的事情。要小心 rm -rf /，因为 Vagrant 与包含 Vagrantfile 的主机上的目录共享一个 /vagrant 目录，这会删除所有这些文件。共享文件夹将在下一节介绍。&emsp;&emsp;花点时间思考刚刚发生的事情：通过终端中的一行配置和一条命令，我们创建了一个功能齐全的，可通过 SSH 访问的虚拟机。SSH 会话可以用 CTRL + D 终止。12vagrant@precise64:~$ logoutConnection to 127.0.0.1 closed. &emsp;&emsp;完成了需要使用虚拟机的工作后，在你的主机上运行 vagrant destroy，Vagrant 将终止虚拟机使用任何资源。&emsp;&emsp;vagrant destroy 命令实际上并不删除下载的 box 文件。可以使用vagrant box remove 命令彻底删除 box 文件。 同步目录（synced folders）&emsp;&emsp;尽管可以非常轻松的启动一台虚拟机，但很少有人希望通过 SSH 使用基于终端的编辑器来编辑文件。幸运的是，借助 Vagrant 你不需要这样做。通过使用同步目录，Vagrant 会自动同步 guest 机器上的文件。&emsp;&emsp;默认情况下，Vagrant 将你的项目的目录（即 Vagrantfile 的目录）共享到 guest 中的 /vagrant 目录。&emsp;&emsp;注意，当使用 vagrant ssh 目录进入机器时，默认进入 /home/vagrant 目录。 /home/vagrant 是与同步的 /vagrant 目录不同的目录。&emsp;&emsp;如果终端报错，提示不兼容 guest additions（或没有 guest additions），那么可能需要更新 box 或选择不同的 box，如 hashicorp/precise64。一些用户成功使用了 vagrant-vbguest 插件，但它并未得到 Vagrant 核心团队的正式支持。&emsp;&emsp;再次运行 vagrant up 启动 vagrant，然后通过 vagrant ssh 进入机器：123456$ vagrant up...$ vagrant ssh...vagrant@precise64:~$ ls /vagrantVagrantfile &emsp;&emsp;不管你信不信，你在虚拟机中看到的 Vagrantfile 文件实际上是你宿主机上的同一个文件。下面证明一下：1234vagrant@precise64:~$ touch /vagrant/foovagrant@precise64:~$ exit$ lsfoo Vagrantfile &emsp;&emsp;现在，“foo”文件会出现在你的宿主机上。你可以看到，Vagrant 保证了这个目录的同步。&emsp;&emsp;通过同步目录，你可以继续使用宿主机上你自己的编辑器，对宿主机中文件的改动会自动同步到 guest 机器中。 配置&emsp;&emsp;现在我们已经有了一个运行 Ubuntu 的虚拟机，并且可以在宿主机上编辑文件并自动同步到虚拟机。现在让我们安装一个 web 服务器，通过服务器访问这些文件。&emsp;&emsp;可以通过 SSH 进入并安装一个 web 服务器并开始工作，但每个使用 Vagrant 的人都必须这样做。相反，Vagrant 内置了对自动配置的支持。使用此功能时，Vagrant 将在执行 vagrant up 时自动安装软件，以便 guest 机器可以重复创建并可立即使用。 安装 Apache&emsp;&emsp;可以通过 shell 脚本来为刚才的项目设置 Apache。创建下面的 shell 脚本并命名为 bootstrap.sh，保存在 Vagrantfile 文件相同的目录下：12345678#!/usr/bin/env bashapt-get updateapt-get install -y apache2if ! [ -L /var/www ]; then rm -rf /var/www ln -fs /vagrant /var/wwwfi &emsp;&emsp;然后，配置 Vagrant 在设置机器的时候运行这个脚本。编辑 Vagrantfile 文件：1234Vagrant.configure(&quot;2&quot;) do |config| config.vm.box = &quot;hashicorp/precise64&quot; config.vm.provision :shell, path: &quot;bootstrap.sh&quot;end &emsp;&emsp;“provision” 行是新添加的，告诉 Vagrant 使用 shell 命令执行 bootstrap.sh 文件来设置虚拟机。文件路径是相对于 Vagrantfile 文件所在的项目根目录的相对路径。 配置&emsp;&emsp;配置写完后，执行 vagrant up，Vagrant 会自动配置。可以在终端看到 shell 脚本的输出。如果虚拟机已经启动了，则需要执行 vagrant reload –provision，这会快速重启虚拟机并跳过初始化导入阶段。因为 Vagrant 只会在第一次 vagrant up 启动虚拟机的时候自动运行 provisioner，所以需要在 reload 命令中使用 provision 标志指示 Vagrant 必须运行 provisioner。&emsp;&emsp;Vagrant 运行结束后，web 服务器会成功运行。现在还不能在宿主机的浏览器上查看网页，但可以在通过 SSH 进入虚拟机后，通过加载文件来判断配置是否生效：123$ vagrant ssh...vagrant@precise64:~$ wget -qO- 127.0.0.1 &emsp;&emsp;上面例子会正常工作。我们安装 Apache 并设置其默认的 DocumentRoot 指向我们的 /vagrant 这个默认的同步目录。&emsp;&emsp;可以创建更多文件并在终端查看，下一步需要配置网络选项以便用宿主机的浏览器访问虚拟机。 对于复杂的配置脚本，将自定义的 Vagrant box 与预先安装的软件包打包在一起，而不是每次构建它们可能会更高效。入门指南未涵盖此主题，但可以在 自定义 box 文档中找到该主题。 网络&emsp;&emsp;现在，我们启动了 web 服务器，并且通过同步目录使用宿主机上的文件提供服务。然而，还只能通过虚拟机中的终端访问服务器。这一章节中，我们会使用 Vagrant 的网络特性，配置 Vagrant 以便从宿主机访问服务器。 端口转发（Port Forwarding）&emsp;&emsp;配置文件中支持端口转发选项。通过端口转发，可以在访问宿主机的某个端口时，自动将流量转发到虚拟机的指定端口。&emsp;&emsp;编辑 Vagrantfile 文件即可实现端口转发： 12345Vagrant.configure(&quot;2&quot;) do |config| config.vm.box = &quot;hashicorp/precise64&quot; config.vm.provision :shell, path: &quot;bootstrap.sh&quot; config.vm.network :forwarded_port, guest: 80, host: 4567end &emsp;&emsp;运行 vagrant reload 或 vagrant up（取决于虚拟机是否已经启动）加载配置。&emsp;&emsp;一旦虚拟机启动成功，在宿主机的浏览器中访问 http://127.0.0.1:4567。你应该看到虚拟机中的 web 服务器提供的网页。 其他网络Vagrant 还有其他网络配置选项，可以为虚拟机分配静态 IP 地址，或将虚拟机桥接到一个已经存在的网络上。更多资料参考这里。 share&emsp;&emsp;译者注：Vagrant Share 功能通过 ngrok 向所有人提供访问内网开发环境的能力。&emsp;&emsp;现在我们已经启动并运行了一台 Web 服务器，并且可以从你的机器访问，我们拥有一个相当实用的开发环境。但除了提供开发环境外，Vagrant 还可以轻松地在这些环境中共享和协作。Vagrant 中实现这个功能的特性叫做 Vagrant Share。&emsp;&emsp;Vagrant Share 使你可以通过网络向任何人共享 Vagrant 环境。这个功能会提供一个 URL 给你，任何人都可以通过这个 URL 路由到你的 Vagrant 环境。&emsp;&emsp;运行 vagrant share：12345$ vagrant share...==&gt; default: Creating Vagrant Share session...==&gt; default: HTTP URL: http://b1fb1f3f.ngrok.io... &emsp;&emsp;每个人的 URL 都是不同的。复制你的 URL，通过浏览器访问即可。&emsp;&emsp;如果你修改了共享目录中的文件，刷新 URL 后你会发现更新实时生效。这个 URL 直接路由到你的 Vagrant 环境，可以在世界上任意地点访问。&emsp;&emsp;在终端中通过 Ctrl + C 结束共享会话。可以再次刷新 URL 来验证开发环境是否仍在共享中。&emsp;&emsp;Vagrant Share 比简单的 HTTP 共享更加强大。详情参考 Vagrant Share 文档。 清理（teardown）&emsp;&emsp;我们现在有一个功能齐全的虚拟机，可以用于基本 Web 开发。但如果现在需要更换设备，或者在另一个项目上工作，如何清理我们的开发环境？&emsp;&emsp;借助 Vagrant，可以暂停（suspend），停止（halt）或销毁（destroy）虚拟机。每个选项都有优点和缺点。选择最适合的即可。 暂停（suspend）：通过调用 vagrant suspend 命令可以暂停虚拟机，此时会保存虚拟机当前运行状态并停止运行。当准备好再次工作时，运行 vagrant up 命令即可从上次暂停的状态恢复。这个方法的最大优点就是快，只要 5 到 10 秒就可以停止并开始工作。缺点是虚拟机仍占用磁盘空间，并且需要消耗更大的磁盘空间来保存虚拟机的 RAM 状态。 停止（halt）：通过调用 vagrant halt 命令可以优雅关闭虚拟机操作系统并断电。需要再次启动的时候，运行 vagrant up 命令即可。这个方法的好处是会干净地关闭你的机器，保存磁盘的内容，并让它再次干净地启动。缺点是冷启动需要较长时间，且虚拟机仍占用磁盘空间。 销毁（destroy）：通过调用 vagrant destroy 销毁虚拟机，这将从宿主机中删除虚拟机的所有痕迹。它会停止虚拟机，关闭它并删除其所有硬盘资源。当你准备好再次工作时，运行 vagrant up 命令即可。这样做的好处是，宿主机上不会留下残余物。虚拟机消耗的磁盘空间和 RAM 将被回收，并且主机保持清洁。缺点是，由于需要重新导入虚拟机并重新配置，因此需要更多时间。 https://app.vagrantup.com/boxes/search","tags":[{"name":"项目部署","slug":"项目部署","permalink":"http://yoursite.com/tags/项目部署/"}]},{"title":"django-扩展Django自带User模型，实现用户注册与登录","date":"2018-09-03T09:04:04.000Z","path":"2018/09/03/django-扩展Django自带User模型，实现用户注册与登录/","text":"&emsp;&emsp;用户的注册与登陆是一个网站应该具有的基本功能。前面的文章讲解了django自带的auth模块并使用第三方库完成登录注册等功能，今天来好好聊一聊如何扩展扩展Django自带User模型，并自己实现登录注册等功能。 扩展自带User模型&emsp;&emsp;我们需要实现用户登录注册功能就要先设计user表，如果django原有的user表不满足项目需求可以重新设计user表。 已有字段: id: 主键username 用户名，该字段不要随便改动password 密码email 邮箱first_name：名last_name：姓last_login Django自动记录用户最后登录时间is_superuser 表明用户是否是超级用户,默认是False(后台管理会用到)is_staff 表示是否是员工，默认是False(后台管理会用到)is_active 用户是否是激活状态，默认是Truedate_joined 注册时间，系统自动生成。 继承AbstractUser的方式 自定义user表12345678910111213141516171819from django.db import modelsfrom django.contrib.auth.models import AbstractUserclass UserProfile(AbstractUser): gender_choices = ( (&apos;male&apos;,&apos;男&apos;), (&apos;female&apos;,&apos;女&apos;) ) nick_name = models.CharField(&apos;昵称&apos;,max_length=50,default=&apos;&apos;) birthday = models.DateField(&apos;生日&apos;,null=True,blank=True) gender = models.CharField(&apos;性别&apos;,max_length=10,choices=gender_choices,default=&apos;female&apos;) adress = models.CharField(&apos;地址&apos;,max_length=100,default=&apos;&apos;) mobile = models.CharField(&apos;手机号&apos;,max_length=11,null=True,blank=True) image = models.ImageField(upload_to=&apos;image/%Y%m&apos;,default=&apos;image/default.png&apos;,max_length=100) class Meta: verbose_name = &apos;用户信息&apos; verbose_name_plural = verbose_name def __str__(self): return self.username 然后再setting.py中修改: AUTH_USER_MODEL = ‘users.UserProfile’ 执行makemigrations和migrate生成数据表: python manage.py makemigrationspython manage.py migrate 特别要注意图片和文件model需要指出上传地址upload_to image = models.ImageField(‘轮播图’,upload_to=’banner/%Y%m’,max_length=100)download = models.FileField(“资源文件”,upload_to=”course/resource/%Y/%m”,max_length=100) 图片上传需要安装第三方库 pip install pillow 使用1对1方式我们创建一个UserProfile模型，它只是对User模型的扩展, 与User是1对1的关系。1234567891011121314from django.db import modelsfrom django.contrib.auth.models import Userclass UserProfile(models.Model): # 与User是1对1关系 user = models.OneToOneField(User, on_delete=models.CASCADE, related_name=&apos;profile&apos;) org = models.CharField(&apos;Organization&apos;, max_length=128, blank=True) telephone = models.CharField(&apos;Telephone&apos;, max_length=50, blank=True) mod_date = models.DateTimeField(&apos;Last modified&apos;, auto_now=True) class Meta: verbose_name = &apos;User Profile&apos; def __str__(self): return self.user 然后你可以在终端输入以下命令，就可以创建UserProfile的数据表。12python manage.py makemigrations python manage.py migrate 登录注册功能的实现- 配置url url(r’^accounts/‘, include(‘users.urls’)), users.urls123456url(r&apos;^register/$&apos;, views.register, name=&apos;register&apos;),url(r&apos;^login/$&apos;, views.login, name=&apos;login&apos;),url(r&apos;^logout/$&apos;, views.logout, name=&apos;logout&apos;),url(r&apos;^user/(?P&lt;pk&gt;\\d+)/profile/$&apos;, views.profile, name=&apos;profile&apos;),url(r&apos;^user/(?P&lt;pk&gt;\\d+)/profile/update/$&apos;,views.profile_update,name=&apos;profile_update&apos;),url(r&apos;^user/(?P&lt;pk&gt;\\d+)/pwdchange/$&apos;, views.pwd_change,name=&apos;pwd_change&apos;),","tags":[{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"}]},{"title":"Docker入门","date":"2018-09-03T09:03:44.000Z","path":"2018/09/03/Docker入门/","text":"Docker概念&emsp;&emsp;Docker是开发人员和系统管理员使用容器进行开发，部署和运行应用程序的平台。使用Linux容器部署应用程序称为容器化。&emsp;&emsp;容器化越来越受欢迎，因为容器是： 灵活：即使是最复杂的应用也可以集装箱化。 轻量级：容器利用并共享主机内核。 可互换：您可以即时部署更新和升级。 便携式：您可以在本地构建，部署到云，并在任何地方运行。 可扩展：您可以增加并自动分发容器副本。 可堆叠：您可以垂直和即时堆叠服务。 图像和容器&emsp;&emsp;通过运行image启动容器。一个image是一个可执行的包，其中包括运行应用程序所需的所有代码，以及运行时的库，环境变量和配置文件。 容器和虚拟机&emsp;&emsp;容器在Linux上本机运行，与其他容器共享主机的内核。它运行一个独立的进程，不占用任何其他可执行文件的内存，使其轻量级。相比之下，虚拟机（VM）运行一个完整的“客户”操作系统，通过虚拟机管理程序对主机资源进行虚拟访问。通常，VM提供的环境比大多数应用程序需要的资源更多。 测试Docker版本&emsp;&emsp;运行docker –version并确保您拥有受支持的Docker版本：12docker --versionDocker version 17.12.0-ce, build c97c6d6 &emsp;&emsp;运行docker info或（docker version不–）查看有关docker安装的更多详细信息：12345678910docker infoContainers: 0 Running: 0 Paused: 0 Stopped: 0Images: 0Server Version: 17.12.0-ceStorage Driver: overlay2... &emsp;&emsp;要避免权限错误（以及使用sudo），请将您的用户添加到docker组中。阅读更多。 测试Docker安装&emsp;&emsp;通过运行简单的Docker镜像hello-world来测试您的安装是否有效 ：1234567891011docker run hello-worldUnable to find image &apos;hello-world:latest&apos; locallylatest: Pulling from library/hello-worldca4f61b1923c: Pull completeDigest: sha256:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.... &emsp;&emsp;列出hello-world下载到您的计算机的图像：1docker image ls &emsp;&emsp;列出hello-world在显示其消息后退出的容器（由图像生成）。如果它仍在运行，您将不需要–all选项：1234docker container ls --allCONTAINER ID IMAGE COMMAND CREATED STATUS54f4984ed6a8 hello-world &quot;/hello&quot; 20 seconds ago Exited (0) 19 seconds ago Docker指令12345678910111213141516171819## List Docker CLI commandsdockerdocker container --help## Display Docker version and infodocker --versiondocker versiondocker info## Execute Docker imagedocker run hello-world## List Docker imagesdocker image ls## List Docker containers (running, all, all in quiet mode)docker container lsdocker container ls --alldocker container ls -aq 新的开发环境&emsp;&emsp;在过去，如果您要开始编写Python应用程序，那么首先需要在你的计算机上安装Python运行环境。而且该环境需要非常适合你的应用程序按预期运行，并且还需要与你的生产环境相匹配。&emsp;&emsp;如果使用Docker，你可以将可移植的Python运行环境时作为映像获取，无需安装。 然后，您的构建可以在应用程序代码旁边包含基本Python映像，确保您的应用程序，其依赖项和运行时都一起运行。&emsp;&emsp;这些可移植图像由称为Dockerfile的东西定义。 在win创建并运行一个容器 Dockerfile&emsp;&emsp;创建一个空目录。cd进入该目录，创建一个名为Dockerfile的文件，将以下内容复制并粘贴到该文件中，然后保存。Dockerfile命名必须为“Dockerfile”，Docker镜像构建时，会查找指定目录中的Dockerfile。 1234567891011121314151617181920# Use an official Python runtime as a parent imageFROM python:2.7-slim# Set the working directory to /appWORKDIR /app# Copy the current directory contents into the container at /appADD . /app# Install any needed packages specified in requirements.txtRUN pip install --trusted-host pypi.python.org -r requirements.txt# Make port 80 available to the world outside this containerEXPOSE 80# Define environment variableENV NAME World# Run app.py when the container launchesCMD [&quot;python&quot;, &quot;app.py&quot;] 应用程序本身&emsp;&emsp;再创建两个文件，requirements.txt和app.py requirements.txt12FlaskRedis app.py123456789101112131415161718192021222324from flask import Flaskfrom redis import Redis, RedisErrorimport osimport socket#Connect to Redisredis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)app = Flask(__name__)@app.route(&quot;/&quot;)def hello(): try: visits = redis.incr(&quot;counter&quot;) except RedisError: visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot; html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \\ &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot; \\ &quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot; return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)if __name__ == &quot;__main__&quot;: app.run(host=&apos;0.0.0.0&apos;, port=80) 构建应用程序&emsp;&emsp;我们准备构建应用程序。确保您仍处于新目录的顶层。这是ls应该显示的内容：12$ lsDockerfile app.py requirements.txt &emsp;&emsp;现在运行build命令。这会创建一个Docker镜像，我们将使用-t它来标记，因此它具有友好的名称。1docker build -t friendlyhello . &emsp;&emsp;你的构建的镜像将位于您机器的本地Docker镜像注册表中：123$ docker image lsREPOSITORY TAG IMAGE IDfriendlyhello latest 326387cea398 4.运行该应用程序&emsp;&emsp;运行应用程序，使用以下方法将计算机的端口4000映射到容器的已发布端口80 -p：1docker run -p 4000:80 friendlyhello &emsp;&emsp;浏览器打开http://localhost:4000 . 就可以访问hello world. 1. 如果使用win,请使用Docker Machine IP而不是localhost。例如，http：//192.168.99.100：4000。要查找IP地址，请使用该命令docker-machine ip。 2.如果在阿里云运行,需要访问IP:4000,注意要在安全组中添加规则 Dockerfile|Docker镜像|容器之间关系 Dockerfile：Dockerfile 是一个文本文件， 它是Docker镜像的描述文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。有了 Dockerfile，当我们需要定制自己额外的需求时，只需在 Dockerfile 上添加或者修改指令，重新生成 image 即可，省去了敲命令的麻烦。 Docker镜像： 通过Dockerfile做出来的，包含操作系统基础文件和软件运行环境，它使用分层的存储方式。 容器： 是运行起来的镜像，简单理解，Docker镜像相当于程序，容器相当于进程。使用 Dockerfile 定义镜像，依赖镜像来运行容器 &emsp;&emsp;Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令、容器启动执行指令。一开始必须要指明所基于的镜像名称，接下来一般会说明维护者信息；后面则是镜像操作指令，例如 RUN 指令。每执行一条RUN 指令，镜像添加新的一层，并提交；最后是 CMD 指令，来指明运行容器时的操作命令。","tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}]},{"title":"django-FBV & CBV","date":"2018-09-02T06:01:52.000Z","path":"2018/09/02/django-FBV-&-CBV/","text":"FBVFBV（function base views） 就是在视图里使用函数处理请求。1234567url(r&apos;^index/&apos;, views.index),def index(request): if request.method == &quot;GET&quot;: return HttpResponse(&quot;GET&quot;) elif request.method == &quot;POST&quot;: return HttpResponse(&quot;POST&quot;) step1：根据访问请求，在urls寻找匹配的url映射，得到views.indexsetp2：根据views.index ，调用views下index函数（传入参数request即用户请求信息）step3：根据客户请求信息对数据进行处理，通过HttpResponse返回客户端 CBVCBV（class base views） 就是在视图里使用类处理请求。12345678url(r&apos;^index/&apos;, views.Index.as_view()),from django.views import Viewclass Index(View): def get(self, request): return HttpResponse(&quot;GET&quot;) def post(self, request): return HttpResponse(&quot;POST&quot;) 如果是get或者post都执行的代码可以放到dispatch:123456def dispatch(self, request, *args, **kwargs): # 调用父类中的dispatch print(&apos;before&apos;) # 类似装饰器的功能 result = super(Home,self).dispatch(request, *args, **kwargs) print(&apos;after&apos;) # 类似装饰器的功能 return result 其实CBV过程可以看成是FBV过程的抽象化、对象化。他需要最基本的三个类View，ContextMixin，TemplateResponseMixin对应FBV的三个步骤： step1. View类提供类方法as_view(),用于调用dipatch()，根据request类型分发给get，post…等对应方法处理。step2. ContextMixin类，get_context_data(self, **kwargs)获取上下文数据，如果对数据库进行操作均可以继承该类，然后将增删改查的结果放入上下文数据中（即重写get_context_data）step3. TemplateResponseMixin类，将内容渲染到指定模板上，通过render_to_response()方法实现对应功能而其他模板视图基本就是在这三个类上进行继承重写后得到。","tags":[{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"}]},{"title":"django-编辑器Markdown的使用","date":"2018-09-01T14:46:43.000Z","path":"2018/09/01/django-编辑器Markdown的使用/","text":"&emsp;&emsp;之前的一篇博客写到了如何在django中使用Ueditor,今天我们看看如何在django中使用Markdown进行文本的编辑.它是基于editor.md插件 Markdown的安装Markdown使用的是源码安装的方式: 首先到github下载源码 把里面的markdown文件夹放到extra_apps中 然后在INSTALLED_APPS中添加markdown.并在url.py中添加: url(r’^markdown/‘, include(‘markdown.urls’)), 在setting.py中设置图片上传的文件夹 MARKDOWN_IMAGE_FLODER = ‘ markdown ‘ #图片会上传到media/markdown文件夹下 配置上传图片格式 MARKDOWN_IMAGE_FORMATS = [“jpg”，”jpeg”，”gif”，”png”，”bmp”，”webp”] 在admin中使用&emsp;&emsp;所有的TextField都使用markdown编辑器:12345678from django.db import modelsfrom markdown.widgets import AdminMarkdownWidgetclass TestAdmin(admin.ModelAdmin): formfield_overrides = &#123; models.TextField: &#123;&apos;widget&apos;: AdminMarkdownWidget()&#125;, &#125;admin.site.register(Test,TestAdmin) 在xadmin中使用12345678from django.db import modelsfrom markdown.widgets import XAdminMarkdownWidgetclass TestAdmin(admin.ModelAdmin): formfield_overrides = &#123; models.TextField: &#123;&apos;widget&apos;: XAdminMarkdownWidget()&#125;, &#125;xadmin.site.register(Test,TestAdmin) 在form中使用123456from django import formsfrom markdown.forms import MarkdownFieldclass BlogForm(forms.Form): name = forms.CharField() context = MarkdownField() 这里注意在前端需要添加去添加css和js1234567&lt;head&gt; &lt;title&gt;Hello Django!&lt;/title&gt; &#123;&#123;form.media&#125;&#125;&lt;/head&gt;&lt;body&gt;&#123;&#123;form&#125;&#125;&lt;/body&gt; 支持参数 widthheightthemepreviewThemeeditorThemesyncScrollingsaveHTMLToTextareaemojitaskListtocmtexflowChartsequenceDiagramcodeFold 123formfield_overrides = &#123; models.TextField: &#123;&apos;widget&apos;: AdminMarkdownWidget(emoji=False)&#125;, &#125; 最终后端效果 前端显示&emsp;&emsp;你会发现前端显示是有问题的,这个时候需要把markdown语法转换为html,我们需要安装django-markdown-deux. 首先运行 pip install django-markdown-deux 在INSTALLED_APPS中添加markdown_deux 在需要显示markdown的页面:12&#123;% load markdown_deux_tags %&#125;&#123;&#123; course.detail | markdown &#125;&#125; 最后效果: &emsp;&emsp;这里还有一个问题就是无法修改图片的大小,目前没有比较有效的解决办法,如果对图片大小要求比较高,可以使用七牛等支持参数的图床,如果有其他想法,欢迎交流~","tags":[{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"},{"name":"文本编辑","slug":"文本编辑","permalink":"http://yoursite.com/tags/文本编辑/"}]},{"title":"django-编辑器Ueditor的使用","date":"2018-09-01T14:46:26.000Z","path":"2018/09/01/django-编辑器Ueditor的使用/","text":"&emsp;&emsp;Ueditor是比较流行的富文本编辑器,主要用于内容的编辑、排版和图片上传等。本文主要介绍Ueditor的安装并搭配xadmin的使用。 富文本编辑器Ueditor&emsp;&emsp;UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码。 Ueditor的源码安装&emsp;&emsp;前往github下载源码然后解压，把DjangoUeditor文件夹拷贝到项目目录(extra_apps)下面。 setting和url中的配置 settings中添加app 123INSTALLED_APPS = [ &apos;DjangoUeditor&apos;,] MxOnline/urls.py 1path(&apos;ueditor/&apos;,include(&apos;DjangoUeditor.urls&apos; )), model和adminx中的配置 course/models.py中Course修改detail字段 1234class Course(models.Model): # detail = models.TextField(&quot;课程详情&quot;) detail = UEditorField(verbose_name=u&apos;课程详情&apos;, width=600, height=300, imagePath=&quot;courses/ueditor/&quot;, filePath=&quot;courses/ueditor/&quot;, default=&apos;&apos;) xadmin/plugs目录下新建ueditor.py文件,代码如下: 1234567891011121314151617181920212223242526272829303132import xadminfrom xadmin.views import BaseAdminPlugin, CreateAdminView, ModelFormAdminView, UpdateAdminViewfrom DjangoUeditor.models import UEditorFieldfrom DjangoUeditor.widgets import UEditorWidgetfrom django.conf import settingsclass XadminUEditorWidget(UEditorWidget): def __init__(self, **kwargs): self.ueditor_options = kwargs self.Media.js = None super(XadminUEditorWidget,self).__init__(kwargs)class UeditorPlugin(BaseAdminPlugin): def get_field_style(self, attrs, db_field, style, **kwargs): if style == &apos;ueditor&apos;: if isinstance(db_field, UEditorField): widget = db_field.formfield().widget param = &#123;&#125; param.update(widget.ueditor_settings) param.update(widget.attrs) return &#123;&apos;widget&apos;:XadminUEditorWidget(**param)&#125; return attrs def block_extrahead(self, context, nodes): js = &apos;&lt;script type=&quot;text/javascript&quot; src=&quot;%s&quot;&gt;&lt;/script&gt;&apos; %(settings.STATIC_URL + &quot;ueditor/ueditor.config.js&quot;) js += &apos;&lt;script type=&quot;text/javascript&quot; src=&quot;%s&quot;&gt;&lt;/script&gt;&apos; %(settings.STATIC_URL + &quot;ueditor/ueditor.all.min.js&quot;) nodes.append(js)xadmin.site.register_plugin(UeditorPlugin, UpdateAdminView)xadmin.site.register_plugin(UeditorPlugin, CreateAdminView) xadmin/plugs/init.py里面添加ueditor插件 123PLUGINS = ( &apos;ueditor&apos;,) course/adminx.py中使用: 123class CourseAdmin(object): #detail就是要显示为富文本的字段名 style_fields = &#123;&quot;detail&quot;: &quot;ueditor&quot;&#125; xadmin后台效果&emsp;&emsp;但是前段显示还是会有问题:&emsp;&emsp;这是因为需要在模板中必须关闭Django的自动转义才能正常显示:123&#123;% autoescape off %&#125;&#123;&#123; course.detail &#125;&#125;&#123;% endautoescape %&#125; 最终显示效果","tags":[{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"},{"name":"文本编辑","slug":"文本编辑","permalink":"http://yoursite.com/tags/文本编辑/"}]},{"title":"在线教育平台Mxonline-xadmin的使用","date":"2018-09-01T05:10:09.000Z","path":"2018/09/01/在线教育平台Mxonline-xadmin的使用/","text":"&emsp;&emsp;django自带了admin用于后台管理，但是在github上还有一个更好看、功能更强大的库来管理后台，叫xadmin，今天就来好好介绍一下xadmin的使用。 xadmin的安装&emsp;&emsp;通过文档我们可以发现，我们有两种方法可以进行安装。 使用pip install 安装 pip install django-xadmin 下载源码安装 需要安装requirements.txt中的依赖包 &emsp;&emsp;关于源码安装，首先到github搜索 xadmin下载源码，然后在项目的工程目录下新建一个extra_apps，把源码放在该目录下，注意extra_apps需要与apps一样在settings中设置。这里不在重复叙述了，然后手动安装requirements.txt中的依赖包。最后在INSTALLED_APPS中添加xadmin和crispy_forms。&emsp;&emsp;接下来配置url: from extra_apps import xadminurl(r’^xadmin/‘, xadmin.site.urls), &emsp;&emsp;然后执行migrations和migrate生成数据库表并创建superuser.就可以访问登录啦 注册app到xadmin后台 在app文件夹中新建adminx.py:123456789101112import xadminfrom .models import EmailVerifyRecord#xadmin中这里是继承object，不再是继承adminclass EmailVerifyRecordAdmin(object): # 显示的列 list_display = [&apos;code&apos;, &apos;email&apos;, &apos;send_type&apos;, &apos;send_time&apos;] # 搜索的字段，不要添加时间搜索 search_fields = [&apos;code&apos;, &apos;email&apos;, &apos;send_type&apos;] # 过滤 list_filter = [&apos;code&apos;, &apos;email&apos;, &apos;send_type&apos;, &apos;send_time&apos;]xadmin.site.register(EmailVerifyRecord,EmailVerifyRecordAdmin) xadmin的全局配置 全局配置,包括title和footer等 app名称汉化，菜单收叠。 使用Xadmin的主题功能。 全局配置12345678910from xadmin import viewsclass GlobalSettings(object): # 修改title site_title = &apos;Mxonline后台管理界面&apos; # 修改footer site_footer = &apos;在线教育平台&apos; # 收起菜单 menu_style = &apos;accordion&apos; #将title和footer信息进行注册xadmin.site.register(views.CommAdminView,GlobalSettings) 主题功能12345678from xadmin import views#创建xadmin的最基本管理器配置，并与view绑定class BaseSetting(object): # 开启主题功能 enable_themes = True use_bootswatch = True#将基本配置管理与view绑定xadmin.site.register(views.BaseAdminView,BaseSetting) 修改app的名字&emsp;&emsp;在后台左侧的app显示还是英文,如果要设置为中文需要在apps.py中添加verbose_name,然后在init.py中添加default_app_config.12345678apps.pyfrom django.apps import AppConfigclass UsersConfig(AppConfig): name = &apos;users&apos; verbose_name = &apos;用户&apos; __init__.pydefault_app_config = &apos;users.apps.UsersConfig&apos; 最终效果 后台用户用户权限&emsp;&emsp;超级用户拥有所有权限，其它添加的用户默认没有任何权限。进后台添加一个用户“Editor1”,勾上“职员状态”后，这个用户才可以登录进后台。&emsp;&emsp;默认没添加权限的用户登录到后台的情况如下：&emsp;&emsp;使用超级管理员账号登录后为用户Editor1添加查看章节的权限后：&emsp;&emsp;也可以添加一个组赋予相关权限，然后把用户添加到组中：&emsp;&emsp;重新登录Editor1查看权限：&emsp;&emsp;组里面的成员不但拥有自己本身的权限外，还会拥有组的权限 自定义icon&emsp;&emsp;xadmin的图标采用的是第三方css样式“font awesome”,我们可以进官网下载最新的样式替代原本的，下载地址&emsp;&emsp;下载完后把里面的“css”和“fonts”两个文件夹拷贝到xadmin的源码（路径：xadmin/static/vendor/font-awesome）里面 使用方法： 以course为例，进官网找到图标的样式 在course/adminx.py使用 12class CourseAdmin(object): model_icon = &apos;fa fa-book&apos; 后台内容设置默认排序、只读字段和不显示的字段123456789class CourseAdmin(object): &apos;&apos;&apos;课程&apos;&apos;&apos; list_display = [ &apos;name&apos;,&apos;desc&apos;,&apos;detail&apos;,&apos;degree&apos;,&apos;learn_times&apos;,&apos;students&apos;] #显示的字段 search_fields = [&apos;name&apos;, &apos;desc&apos;, &apos;detail&apos;, &apos;degree&apos;, &apos;students&apos;] #搜索 list_filter = [ &apos;name&apos;,&apos;desc&apos;,&apos;detail&apos;,&apos;degree&apos;,&apos;learn_times&apos;,&apos;students&apos;] #过滤 model_icon = &apos;fa fa-book&apos; #图标 ordering = [&apos;-click_nums&apos;] #排序 readonly_fields = [&apos;click_nums&apos;] #只读字段，不能编辑 exclude = [&apos;fav_nums&apos;] #不显示的字段 inlines添加数据&emsp;&emsp;model设计时章节信息和资源指向课程,但是按之前的配置方式章节信息和课程资源需要分开添加,我们可以用inlines去实现使用添加课程的时候添加章节和课程资源.123456789class LessonInline(object): model = Lesson extra = 0class CourseResourceInline(object): model = CourseResource extra = 0#在CourseAdmin中使用inlines添加上面两个的方法class CourseAdmin(object): inlines = [LessonInline,CourseResourceInline] #增加章节和课程资源 &emsp;&emsp;可以看到在添加课程页面就可以直接添加与之关联的章节信息和资源的内容. 一张表分两个Model来管理比如课程里面分为轮播课程和不是轮播课程两种类型，它们是存储在同一张表,但是我们可以分开来管理.1234567class BannerCourse(Course): &apos;&apos;&apos;显示轮播课程&apos;&apos;&apos; class Meta: verbose_name = &apos;轮播课程&apos; verbose_name_plural = verbose_name #这里必须设置proxy=True，这样就不会再生成一张表，同时还具有Model的功能 proxy = True #一种继承的方式 1234567普通课程和轮播课程的后台管理通过添加该函数来进行筛选.def queryset(self): # 重载queryset方法，来过滤出我们想要的数据的 qs = super(CourseAdmin, self).queryset() # 只显示is_banner=True的课程 qs = qs.filter(is_banner=False) return qs 其他常用功能 list_editable : 在列表页可以直接编辑的 12class CourseAdmin(object): list_editable = [&apos;degree&apos;,&apos;desc&apos;] 自定义函数作为列显示 12345678910model.pyclass Course(models.Model):def get_zj_nums(self): #获取课程的章节数 return self.lesson_set.all().count()get_zj_nums.short_description = &apos;章节数&apos; #在后台显示的名称adminx.pyclass CourseAdmin(object): list_display = [&apos;get_zj_nums&apos;] #直接使用函数名作为字段显示 显示自定义的html代码 1234567891011model.pyclass Course(models.Model):def go_to(self): from django.utils.safestring import mark_safe #mark_safe后就不会转义 return mark_safe(&quot;&lt;a href=&apos;https://home.cnblogs.com/u/derek1184405959/&apos;&gt;跳转&lt;/a&gt;&quot;)go_to.short_description = &quot;跳转&quot;adminx.pyclass CourseAdmin(object): list_display = [&apos;go_to&apos;] refresh定时刷新工具 12class CourseAdmin(object): refresh_times = [3,5] #自动刷新（里面是秒数） 字段联动 1234567891011121314class CourseAdmin(object): def save_models(self): # 在保存课程的时候统计课程机构的课程数 # obj实际是一个course对象 obj = self.new_obj # 如果这里不保存，新增课程，统计的课程数会少一个 obj.save() # 确定课程的课程机构存在。 if obj.course_org is not None: #找到添加的课程的课程机构 course_org = obj.course_org #课程机构的课程数量等于添加课程后的数量 course_org.course_nums = Course.objects.filter(course_org=course_org).count() course_org.save()","tags":[{"name":"django项目","slug":"django项目","permalink":"http://yoursite.com/tags/django项目/"},{"name":"Mxonline","slug":"Mxonline","permalink":"http://yoursite.com/tags/Mxonline/"},{"name":"xadmin","slug":"xadmin","permalink":"http://yoursite.com/tags/xadmin/"}]},{"title":"在线教育平台Mxonline-django基本设置和model设计","date":"2018-09-01T05:09:09.000Z","path":"2018/09/01/在线教育平台Mxonline-django基本设置和model设计/","text":"&emsp;&emsp;在学习了一段时间的django框架后，也做了几个较为完整的项目，现将整个的过程做个记录和整理，也算是进行一次章节和回顾吧。接下来几天将从项目工程创建到linux服务器部署中较为关键的点进行记录和总结。 开发环境和开发平台 win10 Pycharm python3.6.2 django1.11.6 虚拟环境的安装与使用 virtualenv的安装：在win下使用pip install virtualenv执行安装,安装成功后使用pip list可以查看到版本信息 在需要创建虚拟环境的目录下执行virtualenv testvir就可以创建一个虚拟环境. cd 进入虚拟环境目录,通过dir查看该目录下文件,cd Scripts,执行activate可以激活虚拟环境,执行deactivate.bat可以退出虚拟环境 virtualenvwrapper可以进行虚拟环境的管理 win下安装pip install virtualenvwrapper-win,安装成功后使用mkvirtualenv testEve创建虚拟环境,会提示创建的虚拟环境的位置 使用workon查看已经安装的虚拟环境,使用workon testEve,如果虚拟环境已经激活,在任何时候执行deactivate.bat就可以退出虚拟环境 新工程设置&emsp;&emsp;工程目录下创建log(日志)、media(上传文件)、templates(模板文件)、static(静态文件)，并新建setting_dev.py用于存储密码等信息，如果将项目托管于github可以把该文件放到.gitignore.&emsp;&emsp;在工程目录下新建apps用于存放所有app,此时导入需要from apps.app1 import views,可以apps右键Mark Directory As - Sources Root(全局搜索路径),然后就可以通过from app1 import views,但是Mark后Pycharm能识别,但是使用命令行无法识别,需要再在setting中添加: sys.path.inser(0,os.path.join(BASE_DIR,’apps’)) 其他配置： 数据库切换成mysql,安装mysqlclient连接myql,同时在setting_dev.py中配置数据库12345678910DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;mxonline&apos;, #数据库名字 &apos;USER&apos;: &apos;root&apos;, #账号 &apos;PASSWORD&apos;: &apos;123456&apos;, #密码 &apos;HOST&apos;: &apos;127.0.0.1&apos;, #IP &apos;PORT&apos;: &apos;3306&apos;, #端口 &#125;&#125; 在setting.py配置上传文件和静态文件的路径:123456STATIC_URL = &apos;/static/&apos;STATICFILES_DIRS = ( os.path.join(BASE_DIR,&apos;static&apos;),)MEDIA_URL = &apos;/media/&apos;MEDIA_ROOT = os.path.join(BASE_DIR,&apos;media&apos;) 在url中配置处理图片的视图函数1234from django.conf.urls.static import staticfrom django.conf import settingsif settings.DEBUG: urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) 修改语言和时区12345LANGUAGE_CODE = &apos;zh_hans&apos;TIME_ZONE = &apos;Asia/Shanghai&apos;USE_I18N = TrueUSE_L10N = TrueUSE_TZ = False &emsp;&emsp;根据项目要求,会有一个users、course、organization的app,同时针对用户的各种操作设计operation的app python manage.py startapp userspython manage.py startapp coursepython manage.py startapp organizationpython manage.py startapp operation model设计&emsp;&emsp;在model设计之前一定要梳理每一个model需要哪些字段,这是一个项目的关键.","tags":[{"name":"django项目","slug":"django项目","permalink":"http://yoursite.com/tags/django项目/"},{"name":"Mxonline","slug":"Mxonline","permalink":"http://yoursite.com/tags/Mxonline/"}]},{"title":"常用Markdown语法说明","date":"2018-08-30T13:10:19.000Z","path":"2018/08/30/常用Markdown语法说明/","text":"Markdown 是一种轻量级标记语言，它允许人们“使用易读易写的纯文本格式”编写文档，本文主要针对Hexo中Markdown常用的语法进行总结，更详细的内容请参考Hexo官方书写格式链接和Markdown书写格式链接 标题Markdown支持两种标题的语法，Setext和atx形式：Setext形式是用底线的形式，利用 = (最高阶标题)和 - (第二阶标题)。Atx形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。 最高阶标题第二阶标题H1标题H2标题H3标题H4标题H5标题H6标题区块引用区块引用则使用 email 形式的 ‘&gt;’ 角括号。 区块引用 嵌套引用 修辞和强调强调内容两侧分别加上星号或者底线。斜体粗体删除 表格 至少一个- 使用:来设置对其方式 第一列 第二列 第三列 内容 内容 内容 列表无序列表使用星号、加号或减号来做为列表。 一号 二号 三号 四号 五号 六号 有序列表 一号 二号 链接这是我的博客地址 分割线 图片图片的语法和链接很像，只需在链接的基础上前方加一个！注意图片大小的设置方式,关于其他设置可以参考七牛云 代码main.c12345int i = 0; i = 1; for (int i = 0; i &lt; 100; i++)&#123; printf(\"hello markdown!\\n\");&#125; 任务列表 选项一 选项二 选项三","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]}]