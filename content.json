[{"title":"django-编辑器Markdown的使用","date":"2018-09-01T14:46:43.000Z","path":"2018/09/01/django-编辑器Markdown的使用/","text":"&emsp;&emsp;之前的一篇博客写到了如何在django中使用Ueditor,今天我们看看如何在django中使用Markdown进行文本的编辑.它是基于editor.md插件 Markdown的安装Markdown使用的是源码安装的方式: 首先到github下载源码 把里面的markdown文件夹放到extra_apps中 然后在INSTALLED_APPS中添加markdown.并在url.py中添加: url(r’^markdown/‘, include(‘markdown.urls’)), 在setting.py中设置图片上传的文件夹 MARKDOWN_IMAGE_FLODER = ‘ markdown ‘ #图片会上传到media/markdown文件夹下 配置上传图片格式 MARKDOWN_IMAGE_FORMATS = [“jpg”，”jpeg”，”gif”，”png”，”bmp”，”webp”] 在admin中使用&emsp;&emsp;所有的TextField都使用markdown编辑器:12345678from django.db import modelsfrom markdown.widgets import AdminMarkdownWidgetclass TestAdmin(admin.ModelAdmin): formfield_overrides = &#123; models.TextField: &#123;&apos;widget&apos;: AdminMarkdownWidget()&#125;, &#125;admin.site.register(Test,TestAdmin) 在xadmin中使用12345678from django.db import modelsfrom markdown.widgets import XAdminMarkdownWidgetclass TestAdmin(admin.ModelAdmin): formfield_overrides = &#123; models.TextField: &#123;&apos;widget&apos;: XAdminMarkdownWidget()&#125;, &#125;xadmin.site.register(Test,TestAdmin) 在form中使用123456from django import formsfrom markdown.forms import MarkdownFieldclass BlogForm(forms.Form): name = forms.CharField() context = MarkdownField() 这里注意在前端需要添加去添加css和js1234567&lt;head&gt; &lt;title&gt;Hello Django!&lt;/title&gt; &#123;&#123;form.media&#125;&#125;&lt;/head&gt;&lt;body&gt;&#123;&#123;form&#125;&#125;&lt;/body&gt; 支持参数 widthheightthemepreviewThemeeditorThemesyncScrollingsaveHTMLToTextareaemojitaskListtocmtexflowChartsequenceDiagramcodeFold 123formfield_overrides = &#123; models.TextField: &#123;&apos;widget&apos;: AdminMarkdownWidget(emoji=False)&#125;, &#125; 最终后端效果 前端显示&emsp;&emsp;你会发现前端显示是有问题的,这个时候需要把markdown语法转换为html,我们需要安装django-markdown-deux. 首先运行 pip install django-markdown-deux 在INSTALLED_APPS中添加markdown_deux 在需要显示markdown的页面:12&#123;% load markdown_deux_tags %&#125;&#123;&#123; course.detail | markdown &#125;&#125; 最后效果: &emsp;&emsp;这里还有一个问题就是无法修改图片的大小,目前没有比较有效的解决办法,如果对图片大小要求比较高,可以使用七牛等支持参数的图床,如果有其他想法,欢迎交流~","tags":[]},{"title":"django-编辑器Ueditor的使用","date":"2018-09-01T14:46:26.000Z","path":"2018/09/01/django-编辑器Ueditor的使用/","text":"&emsp;&emsp;Ueditor是比较流行的富文本编辑器,主要用于内容的编辑、排版和图片上传等。本文主要介绍Ueditor的安装并搭配xadmin的使用。 富文本编辑器Ueditor&emsp;&emsp;UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码。 Ueditor的源码安装&emsp;&emsp;前往github下载源码然后解压，把DjangoUeditor文件夹拷贝到项目目录(extra_apps)下面。 setting和url中的配置 settings中添加app 123INSTALLED_APPS = [ &apos;DjangoUeditor&apos;,] MxOnline/urls.py 1path(&apos;ueditor/&apos;,include(&apos;DjangoUeditor.urls&apos; )), model和adminx中的配置 course/models.py中Course修改detail字段 1234class Course(models.Model): # detail = models.TextField(&quot;课程详情&quot;) detail = UEditorField(verbose_name=u&apos;课程详情&apos;, width=600, height=300, imagePath=&quot;courses/ueditor/&quot;, filePath=&quot;courses/ueditor/&quot;, default=&apos;&apos;) xadmin/plugs目录下新建ueditor.py文件,代码如下: 1234567891011121314151617181920212223242526272829303132import xadminfrom xadmin.views import BaseAdminPlugin, CreateAdminView, ModelFormAdminView, UpdateAdminViewfrom DjangoUeditor.models import UEditorFieldfrom DjangoUeditor.widgets import UEditorWidgetfrom django.conf import settingsclass XadminUEditorWidget(UEditorWidget): def __init__(self, **kwargs): self.ueditor_options = kwargs self.Media.js = None super(XadminUEditorWidget,self).__init__(kwargs)class UeditorPlugin(BaseAdminPlugin): def get_field_style(self, attrs, db_field, style, **kwargs): if style == &apos;ueditor&apos;: if isinstance(db_field, UEditorField): widget = db_field.formfield().widget param = &#123;&#125; param.update(widget.ueditor_settings) param.update(widget.attrs) return &#123;&apos;widget&apos;:XadminUEditorWidget(**param)&#125; return attrs def block_extrahead(self, context, nodes): js = &apos;&lt;script type=&quot;text/javascript&quot; src=&quot;%s&quot;&gt;&lt;/script&gt;&apos; %(settings.STATIC_URL + &quot;ueditor/ueditor.config.js&quot;) js += &apos;&lt;script type=&quot;text/javascript&quot; src=&quot;%s&quot;&gt;&lt;/script&gt;&apos; %(settings.STATIC_URL + &quot;ueditor/ueditor.all.min.js&quot;) nodes.append(js)xadmin.site.register_plugin(UeditorPlugin, UpdateAdminView)xadmin.site.register_plugin(UeditorPlugin, CreateAdminView) xadmin/plugs/init.py里面添加ueditor插件 123PLUGINS = ( &apos;ueditor&apos;,) course/adminx.py中使用: 123class CourseAdmin(object): #detail就是要显示为富文本的字段名 style_fields = &#123;&quot;detail&quot;: &quot;ueditor&quot;&#125; xadmin后台效果&emsp;&emsp;但是前段显示还是会有问题:&emsp;&emsp;这是因为需要在模板中必须关闭Django的自动转义才能正常显示:123&#123;% autoescape off %&#125;&#123;&#123; course.detail &#125;&#125;&#123;% endautoescape %&#125; 最终显示效果","tags":[{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"},{"name":"文本编辑","slug":"文本编辑","permalink":"http://yoursite.com/tags/文本编辑/"}]},{"title":"在线教育平台Mxonline-用户登录注册功能的实现","date":"2018-09-01T05:11:33.000Z","path":"2018/09/01/在线教育平台Mxonline-用户登录注册功能的实现/","text":"&emsp;&emsp;对于web网站，小到一个博客系统，大到购物平台，用户管理是不可或缺的。包括了用户的注册、登录、修改重置密码、修改个人信息等，今天就来聊一聊用户管理那些事儿~ 用户管理&emsp;&emsp;其实django自带了一个用户认证模块，django.contrib.auth，auth模块是对登录认证方法的一种封装，之前我们获取用户输入的用户名及密码后需要自己从user表里查询有没有用户名和密码符合的对象，而有了auth模块之后就可以很轻松的去验证用户的登录信息是否存在于数据库中。 auth里的方法 authenticate():提供了用户认证，即验证用户名以及密码是否正确，如果认证信息有效，会返回一个 User 对象。authenticate()会在 User 对象上设置一个属性标识表明认证后端认证了该用户，且该信息在后面的登录过程中是需要的。当我们试图登陆一个从数据库中直接取出来不经过authenticate()的User对象会报错的！！ user = authenticate(username=’someone’,password=’somepassword’) login(HttpRequest, user):该函数接受一个HttpRequest对象，以及一个认证了的User对象，此函数使用django的session框架给某个已认证的用户附加上session id等信息 12345username = request.POST[&apos;username&apos;]password = request.POST[&apos;password&apos;]user = authenticate(username=username, password=password)if user is not None: login(request, user) logout(request):该函数接受一个HttpRequest对象，无返回值。当调用该函数时，当前请求的session信息会全部清除。该用户即使没有登录，使用该函数也不会报错。 12def logout_view(request): logout(request) user对象的 is_authenticated():要求：1 用户登陆后才能访问某些页面，2 如果用户没有登录就访问该页面的话直接跳到登录页面3 用户在跳转的登陆界面中完成登陆后，自动访问跳转到之前访问的地址 123def my_view(request): if not request.user.is_authenticated(): return redirect(&apos;%s?next=%s&apos; % (settings.LOGIN_URL, request.path)) 对于用户是否登录的认证还有其他方法,比如修饰器和类的继承方式: 用户是否登录认证的其他方式修饰器方式123from django.contrib.auth.decorators import login_required@login_requireddef my_view(request): 若用户没有登录，则会跳转到django默认的登录URL ‘/accounts/login/ ‘ (这个值可以在settings文件中通过LOGIN_URL进行修改)。并传递 当前访问url的绝对路径 ( 登陆成功后，会重定向到该路径 )。 LoginRequiredMixin123456789101112from django.contrib.auth.decorators import login_requiredfrom django.utils.decorators import method_decoratorfrom django.shortcuts import reverseLOGIN_URL = &apos;/users/login/&apos;class LoginRequiredMixin(object): @method_decorator(login_required(login_url=LOGIN_URL)) def dispatch(self,request,*args,**kwargs): return super(LoginRequiredMixin, self).dispatch(request,*args,**kwargs) class ImageUploadView(LoginRequiredMixin,View): user对象 username 用户名password（必填项）password用哈希算法保存到数据库is_staff ： 用户是否拥有网站的管理权限.is_active ： 是否允许用户登录, 设置为False，可以不用删除用户来禁止用户登录check_password(passwd) 如果给定的字符串通过了密码检查，返回 Trueset_password() 修改密码 自定义user表&emsp;&emsp;以上的所有操作，都是针对django自动创建的auth_user表，如果要用auth模块，就必须要使用（或继承）这张表。继承表的好处是我们可以增加一些自己需要的字段，并且同时可以使用auth模块提供的接口、方法,而我们项目中的UserProfile就是继承该表. #","tags":[{"name":"django项目","slug":"django项目","permalink":"http://yoursite.com/tags/django项目/"},{"name":"Mxonline","slug":"Mxonline","permalink":"http://yoursite.com/tags/Mxonline/"}]},{"title":"在线教育平台Mxonline-xadmin的使用","date":"2018-09-01T05:10:09.000Z","path":"2018/09/01/在线教育平台Mxonline-xadmin的使用/","text":"&emsp;&emsp;django自带了admin用于后台管理，但是在github上还有一个更好看、功能更强大的库来管理后台，叫xadmin，今天就来好好介绍一下xadmin的使用。 xadmin的安装&emsp;&emsp;通过文档我们可以发现，我们有两种方法可以进行安装。 使用pip install 安装 pip install django-xadmin 下载源码安装 需要安装requirements.txt中的依赖包 &emsp;&emsp;关于源码安装，首先到github搜索 xadmin下载源码，然后在项目的工程目录下新建一个extra_apps，把源码放在该目录下，注意extra_apps需要与apps一样在settings中设置。这里不在重复叙述了，然后手动安装requirements.txt中的依赖包。最后在INSTALLED_APPS中添加xadmin和crispy_forms。&emsp;&emsp;接下来配置url: from extra_apps import xadminurl(r’^xadmin/‘, xadmin.site.urls), &emsp;&emsp;然后执行migrations和migrate生成数据库表并创建superuser.就可以访问登录啦 注册app到xadmin后台 在app文件夹中新建adminx.py:123456789101112import xadminfrom .models import EmailVerifyRecord#xadmin中这里是继承object，不再是继承adminclass EmailVerifyRecordAdmin(object): # 显示的列 list_display = [&apos;code&apos;, &apos;email&apos;, &apos;send_type&apos;, &apos;send_time&apos;] # 搜索的字段，不要添加时间搜索 search_fields = [&apos;code&apos;, &apos;email&apos;, &apos;send_type&apos;] # 过滤 list_filter = [&apos;code&apos;, &apos;email&apos;, &apos;send_type&apos;, &apos;send_time&apos;]xadmin.site.register(EmailVerifyRecord,EmailVerifyRecordAdmin) xadmin的全局配置 全局配置,包括title和footer等 app名称汉化，菜单收叠。 使用Xadmin的主题功能。 全局配置12345678910from xadmin import viewsclass GlobalSettings(object): # 修改title site_title = &apos;Mxonline后台管理界面&apos; # 修改footer site_footer = &apos;在线教育平台&apos; # 收起菜单 menu_style = &apos;accordion&apos; #将title和footer信息进行注册xadmin.site.register(views.CommAdminView,GlobalSettings) 主题功能12345678from xadmin import views#创建xadmin的最基本管理器配置，并与view绑定class BaseSetting(object): # 开启主题功能 enable_themes = True use_bootswatch = True#将基本配置管理与view绑定xadmin.site.register(views.BaseAdminView,BaseSetting) 修改app的名字&emsp;&emsp;在后台左侧的app显示还是英文,如果要设置为中文需要在apps.py中添加verbose_name,然后在init.py中添加default_app_config.12345678apps.pyfrom django.apps import AppConfigclass UsersConfig(AppConfig): name = &apos;users&apos; verbose_name = &apos;用户&apos; __init__.pydefault_app_config = &apos;users.apps.UsersConfig&apos; 最终效果 后台用户用户权限&emsp;&emsp;超级用户拥有所有权限，其它添加的用户默认没有任何权限。进后台添加一个用户“Editor1”,勾上“职员状态”后，这个用户才可以登录进后台。&emsp;&emsp;默认没添加权限的用户登录到后台的情况如下：&emsp;&emsp;使用超级管理员账号登录后为用户Editor1添加查看章节的权限后：&emsp;&emsp;也可以添加一个组赋予相关权限，然后把用户添加到组中：&emsp;&emsp;重新登录Editor1查看权限：&emsp;&emsp;组里面的成员不但拥有自己本身的权限外，还会拥有组的权限 自定义icon&emsp;&emsp;xadmin的图标采用的是第三方css样式“font awesome”,我们可以进官网下载最新的样式替代原本的，下载地址&emsp;&emsp;下载完后把里面的“css”和“fonts”两个文件夹拷贝到xadmin的源码（路径：xadmin/static/vendor/font-awesome）里面 使用方法： 以course为例，进官网找到图标的样式 在course/adminx.py使用 12class CourseAdmin(object): model_icon = &apos;fa fa-book&apos; 后台内容设置默认排序、只读字段和不显示的字段123456789class CourseAdmin(object): &apos;&apos;&apos;课程&apos;&apos;&apos; list_display = [ &apos;name&apos;,&apos;desc&apos;,&apos;detail&apos;,&apos;degree&apos;,&apos;learn_times&apos;,&apos;students&apos;] #显示的字段 search_fields = [&apos;name&apos;, &apos;desc&apos;, &apos;detail&apos;, &apos;degree&apos;, &apos;students&apos;] #搜索 list_filter = [ &apos;name&apos;,&apos;desc&apos;,&apos;detail&apos;,&apos;degree&apos;,&apos;learn_times&apos;,&apos;students&apos;] #过滤 model_icon = &apos;fa fa-book&apos; #图标 ordering = [&apos;-click_nums&apos;] #排序 readonly_fields = [&apos;click_nums&apos;] #只读字段，不能编辑 exclude = [&apos;fav_nums&apos;] #不显示的字段 inlines添加数据&emsp;&emsp;model设计时章节信息和资源指向课程,但是按之前的配置方式章节信息和课程资源需要分开添加,我们可以用inlines去实现使用添加课程的时候添加章节和课程资源.123456789class LessonInline(object): model = Lesson extra = 0class CourseResourceInline(object): model = CourseResource extra = 0#在CourseAdmin中使用inlines添加上面两个的方法class CourseAdmin(object): inlines = [LessonInline,CourseResourceInline] #增加章节和课程资源 &emsp;&emsp;可以看到在添加课程页面就可以直接添加与之关联的章节信息和资源的内容. 一张表分两个Model来管理比如课程里面分为轮播课程和不是轮播课程两种类型，它们是存储在同一张表,但是我们可以分开来管理.1234567class BannerCourse(Course): &apos;&apos;&apos;显示轮播课程&apos;&apos;&apos; class Meta: verbose_name = &apos;轮播课程&apos; verbose_name_plural = verbose_name #这里必须设置proxy=True，这样就不会再生成一张表，同时还具有Model的功能 proxy = True #一种继承的方式 1234567普通课程和轮播课程的后台管理通过添加该函数来进行筛选.def queryset(self): # 重载queryset方法，来过滤出我们想要的数据的 qs = super(CourseAdmin, self).queryset() # 只显示is_banner=True的课程 qs = qs.filter(is_banner=False) return qs 其他常用功能 list_editable : 在列表页可以直接编辑的 12class CourseAdmin(object): list_editable = [&apos;degree&apos;,&apos;desc&apos;] 自定义函数作为列显示 12345678910model.pyclass Course(models.Model):def get_zj_nums(self): #获取课程的章节数 return self.lesson_set.all().count()get_zj_nums.short_description = &apos;章节数&apos; #在后台显示的名称adminx.pyclass CourseAdmin(object): list_display = [&apos;get_zj_nums&apos;] #直接使用函数名作为字段显示 显示自定义的html代码 1234567891011model.pyclass Course(models.Model):def go_to(self): from django.utils.safestring import mark_safe #mark_safe后就不会转义 return mark_safe(&quot;&lt;a href=&apos;https://home.cnblogs.com/u/derek1184405959/&apos;&gt;跳转&lt;/a&gt;&quot;)go_to.short_description = &quot;跳转&quot;adminx.pyclass CourseAdmin(object): list_display = [&apos;go_to&apos;] refresh定时刷新工具 12class CourseAdmin(object): refresh_times = [3,5] #自动刷新（里面是秒数） 字段联动 1234567891011121314class CourseAdmin(object): def save_models(self): # 在保存课程的时候统计课程机构的课程数 # obj实际是一个course对象 obj = self.new_obj # 如果这里不保存，新增课程，统计的课程数会少一个 obj.save() # 确定课程的课程机构存在。 if obj.course_org is not None: #找到添加的课程的课程机构 course_org = obj.course_org #课程机构的课程数量等于添加课程后的数量 course_org.course_nums = Course.objects.filter(course_org=course_org).count() course_org.save()","tags":[{"name":"django项目","slug":"django项目","permalink":"http://yoursite.com/tags/django项目/"},{"name":"Mxonline","slug":"Mxonline","permalink":"http://yoursite.com/tags/Mxonline/"},{"name":"xadmin","slug":"xadmin","permalink":"http://yoursite.com/tags/xadmin/"}]},{"title":"在线教育平台Mxonline-django基本设置和model设计","date":"2018-09-01T05:09:09.000Z","path":"2018/09/01/在线教育平台Mxonline-django基本设置和model设计/","text":"&emsp;&emsp;在学习了一段时间的django框架后，也做了几个较为完整的项目，现将整个的过程做个记录和整理，也算是进行一次章节和回顾吧。接下来几天将从项目工程创建到linux服务器部署中较为关键的点进行记录和总结。 开发环境和开发平台 win10 Pycharm python3.6.2 django1.11.6 虚拟环境的安装与使用 virtualenv的安装：在win下使用pip install virtualenv执行安装,安装成功后使用pip list可以查看到版本信息 在需要创建虚拟环境的目录下执行virtualenv testvir就可以创建一个虚拟环境. cd 进入虚拟环境目录,通过dir查看该目录下文件,cd Scripts,执行activate可以激活虚拟环境,执行deactivate.bat可以退出虚拟环境 virtualenvwrapper可以进行虚拟环境的管理 win下安装pip install virtualenvwrapper-win,安装成功后使用mkvirtualenv testEve创建虚拟环境,会提示创建的虚拟环境的位置 使用workon查看已经安装的虚拟环境,使用workon testEve,如果虚拟环境已经激活,在任何时候执行deactivate.bat就可以退出虚拟环境 新工程设置&emsp;&emsp;工程目录下创建log(日志)、media(上传文件)、templates(模板文件)、static(静态文件)，并新建setting_dev.py用于存储密码等信息，如果将项目托管于github可以把该文件放到.gitignore.&emsp;&emsp;在工程目录下新建apps用于存放所有app,此时导入需要from apps.app1 import views,可以apps右键Mark Directory As - Sources Root(全局搜索路径),然后就可以通过from app1 import views,但是Mark后Pycharm能识别,但是使用命令行无法识别,需要再在setting中添加: sys.path.inser(0,os.path.join(BASE_DIR,’apps’)) 其他配置： 数据库切换成mysql,安装mysqlclient连接myql,同时在setting_dev.py中配置数据库12345678910DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;mxonline&apos;, #数据库名字 &apos;USER&apos;: &apos;root&apos;, #账号 &apos;PASSWORD&apos;: &apos;123456&apos;, #密码 &apos;HOST&apos;: &apos;127.0.0.1&apos;, #IP &apos;PORT&apos;: &apos;3306&apos;, #端口 &#125;&#125; 在setting.py配置上传文件和静态文件的路径:123456STATIC_URL = &apos;/static/&apos;STATICFILES_DIRS = ( os.path.join(BASE_DIR,&apos;static&apos;),)MEDIA_URL = &apos;/media/&apos;MEDIA_ROOT = os.path.join(BASE_DIR,&apos;media&apos;) 在url中配置处理图片的视图函数1234from django.conf.urls.static import staticfrom django.conf import settingsif settings.DEBUG: urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) 修改语言和时区12345LANGUAGE_CODE = &apos;zh_hans&apos;TIME_ZONE = &apos;Asia/Shanghai&apos;USE_I18N = TrueUSE_L10N = TrueUSE_TZ = False &emsp;&emsp;根据项目要求,会有一个users、course、organization的app,同时针对用户的各种操作设计operation的app python manage.py startapp userspython manage.py startapp coursepython manage.py startapp organizationpython manage.py startapp operation model设计&emsp;&emsp;在model设计之前一定要梳理每一个model需要哪些字段,这是一个项目的关键. 用户表的设计 首先设计user表,如果django原有的user表不满足项目需求可以重新设计user表 已有字段: id: 主键password 密码last_login Django自动记录用户最后登录时间is_superuser 表明用户是否是超级用户(后台管理会用到)username 用户名字段不要随便改动email 邮箱is_staff 表示是否是员工(后台管理会用到)is_active 用户是否是激活状态date_joined 注册时间 自定义user表12345678910111213141516171819from django.db import modelsfrom django.contrib.auth.models import AbstractUserclass UserProfile(AbstractUser): gender_choices = ( (&apos;male&apos;,&apos;男&apos;), (&apos;female&apos;,&apos;女&apos;) ) nick_name = models.CharField(&apos;昵称&apos;,max_length=50,default=&apos;&apos;) birthday = models.DateField(&apos;生日&apos;,null=True,blank=True) gender = models.CharField(&apos;性别&apos;,max_length=10,choices=gender_choices,default=&apos;female&apos;) adress = models.CharField(&apos;地址&apos;,max_length=100,default=&apos;&apos;) mobile = models.CharField(&apos;手机号&apos;,max_length=11,null=True,blank=True) image = models.ImageField(upload_to=&apos;image/%Y%m&apos;,default=&apos;image/default.png&apos;,max_length=100) class Meta: verbose_name = &apos;用户信息&apos; verbose_name_plural = verbose_name def __str__(self): return self.username 然后再setting.py中修改: AUTH_USER_MODEL = ‘users.UserProfile’ 执行makemigrations和migrate生成数据表: python manage.py makemigrationspython manage.py migrate 特别要注意图片和文件model需要指出上传地址upload_to image = models.ImageField(‘轮播图’,upload_to=’banner/%Y%m’,max_length=100)download = models.FileField(“资源文件”,upload_to=”course/resource/%Y/%m”,max_length=100) 图片上传需要安装第三方库 pip install pillow","tags":[{"name":"django项目","slug":"django项目","permalink":"http://yoursite.com/tags/django项目/"},{"name":"Mxonline","slug":"Mxonline","permalink":"http://yoursite.com/tags/Mxonline/"}]},{"title":"常用Markdown语法说明","date":"2018-08-30T13:10:19.000Z","path":"2018/08/30/常用Markdown语法说明/","text":"Markdown 是一种轻量级标记语言，它允许人们“使用易读易写的纯文本格式”编写文档，本文主要针对Hexo中Markdown常用的语法进行总结，更详细的内容请参考Hexo官方书写格式链接和Markdown书写格式链接 标题Markdown支持两种标题的语法，Setext和atx形式：Setext形式是用底线的形式，利用 = (最高阶标题)和 - (第二阶标题)。Atx形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。 最高阶标题第二阶标题H1标题H2标题H3标题H4标题H5标题H6标题区块引用区块引用则使用 email 形式的 ‘&gt;’ 角括号。 区块引用 嵌套引用 修辞和强调强调内容两侧分别加上星号或者底线。斜体粗体删除 表格 至少一个- 使用:来设置对其方式 第一列 第二列 第三列 内容 内容 内容 列表无序列表使用星号、加号或减号来做为列表。 一号 二号 三号 四号 五号 六号 有序列表 一号 二号 链接这是我的博客地址 分割线 图片图片的语法和链接很像，只需在链接的基础上前方加一个！注意图片大小的设置方式,关于其他设置可以参考七牛云 代码main.c12345int i = 0; i = 1; for (int i = 0; i &lt; 100; i++)&#123; printf(\"hello markdown!\\n\");&#125; 任务列表 选项一 选项二 选项三","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]}]