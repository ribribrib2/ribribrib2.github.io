[{"title":"线程与进程","date":"2018-10-26T01:47:08.000Z","path":"2018/10/26/线程与进程/","text":"&emsp;&emsp;计算机所有的指令的操作都是有CPU来负责的，cpu是来负责运算的。OS(操作系统) 调度cpu的最小单位就是线程。&emsp;&emsp;进程：是以一个整体的形式暴露给操作系统管理，里面包含对各种资源的调用，内存的管理，网络接口的调用等等，是各种资源管理的集合&emsp;&emsp;线程：是操作系统的最小的调度单位，是一串指令的集合。 进程(Process）&emsp;&emsp;程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。&emsp;&emsp;在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。这是这样的设计，大大提高了CPU的利用率。进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。 线程(Thead)&emsp;&emsp;线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 有了进程为什么还要线程?&emsp;&emsp;进程有很多优点，它提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率。很多人就不理解了，既然进程这么优秀，为什么还要线程呢？其实，仔细观察就会发现进程还是有很多缺陷的，主要体现在两点上： 进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。 进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。 &emsp;&emsp;例如，我们在使用qq聊天， qq做为一个独立进程如果同一时间只能干一件事，那他如何实现在同一时刻：即能监听键盘输入、又能监听其它人给你发的消息、同时还能把别人发的消息显示在屏幕上呢？你会说，操作系统不是有分时么？但是分时是指在不同进程间的分时， 即操作系统处理一会你的qq任务，又切换到word文档任务上了，每个cpu时间片分给你的qq程序时，事实上，你的qq还是同一时间只能干一件事情。&emsp;&emsp;再直白一点， 一个操作系统就像是一个工厂，工厂里面有很多个生产车间，不同的车间生产不同的产品，每个车间就相当于一个进程，且你的工厂又穷，供电不足，同一时间只能给一个车间供电，为了能让所有车间都能同时生产，你的工厂的电工只能给不同的车间分时供电，但是轮到你的qq车间时，发现只有一个干活的工人，结果生产效率极低，为了解决这个问题，就需要多加几个工人，让几个人工人并行工作，这每个工人，就是线程！ 进程和线程的区别 线程是共享内存空间的；进程的内存是独立的。 线程可以直接访问此进程中的数据部分；进程有他们独立拷贝自己父进程的数据部分，每个进程是独立的 同一进程的线程之间直接交流(直接交流涉及到数据共享，信息传递)；两个进程想通信，必须通过一个中间代理来实现。 创建一个新的线程很容易；创建新的进程需要对其父进程进行一次克隆。 一个线程可以控制和操作同一进程里的其他线程；但是进程只能操作子进程。 对主线程的修改，可能会影响到进程中其他线程的修改；对于一个父进程的修改不会影响其他子进程(只要不删除父进程即可)概念小结 线程是操作系统最小的调度单位，是一串指令的集合。 进程要操作CPU，必须先创建一个线程。 进程本身是不可以执行的，操作cpu是通过线程实现的，因为它是一堆执行，而进程是不具备执行概念的。就像一个屋子，屋子就是进程，但是屋子里面的每一个人就是线程，屋子就是内存空间。 单核CPU只能同时干一件事，但是为什么给我们的感觉是在干了很多件事？因为CPU太快了，可以有N多次切换。 进程是通过PID来区分的，并不是通过进程名来区分的。进程里面的第一个线程就是主线程，父线程和子线程是相互独立的，只是父线程创建了子线程，父线程down了，子线程不会受到影响的。 主线程修改会影响其他线程，因为它们是共享数据的。 线程启动比进程块，但是运行速度没有可比性 threading.Thread模块函数式多线程1234567891011121314151617import threading,time def run(n): print(&quot;run&quot;, n) time.sleep(2) print(n,&apos;end time:&apos;,time.time())&quot;&quot;&quot;第一个参数是线程函数变量，第二个参数args是一个元组变量参数，如果只传递一个值，就只需要i,如果需要传递多个参数，那么还可以继续传递下去其他的参数，其中的逗号不能少，少了逗号位置参数指引就会出错。&quot;&quot;&quot; t1 = threading.Thread(target=run, args=(&quot;t1&quot;,)) # 生成线程对象t2 = threading.Thread(target=run, args=(&quot;t2&quot;,))print(&apos;start:&apos;,time.time())t1.start() # start()函数启动一个线程t2.start() 继承式多线程1234567891011121314151617181920import threading,time class MyThread(threading.Thread): # 继承threading.Thread &quot;&quot;&quot;继承式多线程&quot;&quot;&quot; def __init__(self, n): super(MyThread,self).__init__() # 也可以写成这样threading.Thread.__init__(self) self.n = n def run(self): # 重写run方法 &quot;&quot;&quot;这个方法不能叫别的名字，只能叫run方法&quot;&quot;&quot; print(&quot;run&quot;, self.n) time.sleep(2) print(self.n,&apos;end time:&apos;,time.time()) t1 = MyThread(&quot;t1&quot;) # 实例化t2 = MyThread(&quot;t2&quot;)print(&apos;start:&apos;,time.time()) t1.start() # 启动一个多线程t2.start() &amp;emsp；&amp;emsp；在上面两个示例代码中，都包含一个主线程和两个子线程，主线程在启动子线程后，子线程就是独立的，所以主线程不会等待子线程的sleep就直接运行下去。如果实现等待线程执行结果可以使用join。 join函数12345678910111213141516171819202122import threading,time class MyThread(threading.Thread): # 继承threading.Thread &quot;&quot;&quot;继承式多线程&quot;&quot;&quot; def __init__(self, n): super(MyThread,self).__init__() # 也可以写成这样threading.Thread.__init__(self) self.n = n def run(self): # 重写run方法 &quot;&quot;&quot;这个方法不能叫别的名字，只能叫run方法&quot;&quot;&quot; print(&quot;run&quot;, self.n) time.sleep(2) print(self.n,&apos;end time:&apos;,time.time()) t1 = MyThread(&quot;t1&quot;) # 实例化t2 = MyThread(&quot;t2&quot;)print(&apos;start:&apos;,time.time()) t1.start() # 启动一个多线程t1.join()t2.start()print(&apos;main end time:&apos;,time.time()) 加了join之后，主线程依赖子线程执行完毕才往下走。 如果想要的是线程依然是并行效果，就需要更换join()的位置 计算多线程执行时间12345678910111213141516171819import threading,time def run(n): # 这边的run方法的名字是自行定义的，跟继承式多线程不一样，那个是强制的 print(&quot;task:&quot;, n) time.sleep(2) print(&quot;task done&quot;, n) start_time = time.time() # 开始时间t_obj = [] # 存放子线程实例for i in range(10): # 一次性启动10个线程 t = threading.Thread(target=run, args=(&quot;t-&#123;0&#125;&quot;.format(i),)) t.start() t_obj.append(t) # 为了不阻塞后面线程的启动，不在这里join，先放到一个列表中 for t in t_obj: # 循环线程实例列表，等待所有线程执行完毕 t.join() print(&quot;--------all thread has finished&quot;)print(&quot;cost:&quot;, time.time() - start_time) # 计算总耗时 守护进程&emsp;&emsp;只要主线程执行完毕，它不管子线程有没有执行完毕，就退出。现在就可以把所有的子线程变成守护线程。子线程变成守护线程之后，主程序就不会等子线程结束再退出了。说白了，设置一个主人，在设置几个仆人，这几个仆人都是为主人服务的。可以帮主人做很多事情，一个主人（主线程）可以有多个仆人（守护线程），服务的前提是，主线程必须存在，如果主线程不存在，则守护进程也没了。那守护进程是干嘛的呢？可以管理一些资源，打开一些文件，监听一些端口，监听一些资源，把一些垃圾资源回收，可以干很多事情，可以随便定义。123456789101112131415import threading,timedef run(n): print(&quot;task:&quot;, n) time.sleep(2) print(&quot;task done&quot;, n) start_time = time.time()for i in range(5): t = threading.Thread(target=run,args=(&quot;t-&#123;0&#125;&quot;.format(i),)) t.setDaemon(True) # Daemon意思是守护进程，这边是把当前线程设置为守护线程 t.start() print(&quot;--------all thread has finished&quot;)print(&quot;cost:&quot;, time.time() - start_time)守护进程一定要在start之前设置，start之后就不能设置了，之后设置会报错 使用场景&emsp;&emsp;比如写一个socket_server，每一个链接过来，socket_server就会给这个链接分配一个新的线程。如果我手动的把socket_server停掉。那这种情况你必须手动停掉服务，那它就要down了，这种情况下还要等线程结束吗？就不用等线程结束了，它自己就直接结束了。这样，是不是就可以把每个socket线程设置一个守护线程，主线程一旦down掉，就全部退出。 补充 theading.current_thead()查看当前线程； 用theading.active_count()来统计当前活动的线程数 线程个数=子线程数+主线程数 GIL锁(全局解释器锁)&emsp;&emsp;计算机有4核，代表着同一时间，可以干4个任务。如果单核cpu的话，我启动10个线程，我看上去也是并发的，因为是执行了上下文的切换，让看上去是并发的。但是单核永远肯定时串行的，它肯定是串行的，cpu真正执行的时候，因为一会执行1，一会执行2.。。。。正常的线程就是这个样子的。但是，在python中，无论有多少核，永远都是假象。无论是4核，8核，还是16核…….不好意思，同一时间执行的线程只有一个(线程)，它就是这个样子的。这个是python的一个开发时候，设计的一个缺陷，所以说python中的线程是假线程。 GIL存在的意义&emsp;&emsp;在新处理器上运行的程序要想充分利用其性能，必须按照并发方式进行重写。大部分开发者听到“并发”通常会立刻想到多线程的程序。目前来说，多线程执行还是利用多核系统最常用的方式。尽管多线程编程大大好于“顺序”编程，不过即便是仔细的程序员也没法在代码中将并发性做到最好。编程语言在这方面应该做的更好，大部分应用广泛的现代编程语言都会支持多线程编程。&emsp;&emsp;要想利用多核系统，Python必须支持多线程运行。作为解释型语言，Python的解释器必须做到既安全又高效。我们都知道多线程编程会遇到的问题。解释器要留意的是避免在不同的线程操作内部共享的数据。同时它还要保证在管理用户线程时保证总是有最大化的计算资源。&emsp;&emsp;那么，不同线程同时访问时，数据的保护机制是怎样的呢？答案是解释器全局锁。从名字上看能告诉我们很多东西，很显然，这是一个加在解释器上的全局（从解释器的角度看）锁（从互斥或者类似角度看）。这种方式当然很安全，但是它有一层隐含的意思（Python初学者需要了解这个）：对于任何Python程序，不管有多少的处理器，任何时候都总是只有一个线程在执行。 GIL锁关系图&emsp;&emsp;GIL(全局解释器锁)是加在python解释器里面的，效果如图：总结:&emsp;&emsp;需要明确的一点是GIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。就好比C++是一套语言（语法）标准，但是可以用不同的编译器来编译成可执行代码。有名的编译器例如GCC，INTEL C++，Visual C++等。Python也一样，同样一段代码可以通过CPython，PyPy，Psyco等不同的Python执行环境来执行。像其中的JPython就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境。所以在很多人的概念里CPython就是Python，也就想当然的把GIL归结为Python语言的缺陷。所以这里要先明确一点：GIL并不是Python的特性，Python完全可以不依赖于GIL。 CPython：是用C语言实现Pyhon，是目前应用最广泛的解释器。 线程锁（互斥锁）1234567891011121314151617181920212223import threading,time def run(n): global num # 把num变成全局变量 time.sleep(1) # 注意了sleep的时候是不占有cpu的，这个时候cpu直接把这个线程挂起了，此时cpu去干别的事情去了 num += 1 # 所有的线程都做+1操作 num = 0 # 初始化num为0t_obj = list()for i in range(100): t = threading.Thread(target=run, args=(&quot;t-&#123;0&#125;&quot;.format(i),)) t.start() t_obj.append(t) for t in t_obj: t.join() print(&quot;--------all thread has finished&quot;)print(&quot;num:&quot;, num) # 输出最后的num值#执行结果--------all thead has finished(&apos;num:&apos;, 97) #输出的结果 &emsp;&emsp;其实这种情况只能在python2.x 中才会出现的，python3.x里面没有这种现象，下面我们就用一张图来解释一下这个原因。如图：解释： 到第5步的时候，可能这个时候python正好切换了一次GIL(据说python2.7中，每100条指令会切换一次GIL),执行的时间到了，被要求释放GIL,这个时候thead 1的count=0并没有得到执行，而是挂起状态，count=0这个上下文关系被存到寄存器中. 然后到第6步，这个时候thead 2开始执行，然后就变成了count = 1,返回给count，这个时候count=1. 然后再回到thead 1，这个时候由于上下文关系，thead 1拿到的寄存器中的count = 0，经过计算，得到count = 1，经过第13步的操作就覆盖了原来的count = 1的值，所以这个时候count依然是count = 1，所以这个数据并没有保护起来。 添加线程锁&emsp;&emsp;通过上面的图我们知道，结果依然是不准确的。所以我还要加一把锁，这个是用户级别的锁。12345678910111213141516171819202122import threading,timedef run(n): lock.acquire() # 添加线程锁 global num # 把num变成全局变量 time.sleep(0.1) # 注意了sleep的时候是不占有cpu的，这个时候cpu直接把这个线程挂起了，此时cpu去干别的事情去了 num += 1 # 所有的线程都做+1操作 lock.release() # 释放线程锁 num = 0 # 初始化num为0lock = threading.Lock() # 生成线程锁实例t_obj = list()for i in range(10): t = threading.Thread(target=run, args=(&quot;t-&#123;0&#125;&quot;.format(i),)) t.start() t_obj.append(t) for t in t_obj: t.join() # 为join是等子线程执行的结果，如果不加，主线程执行完，下面就获取不到子线程num的值了，共享数据num值就错误了print(&quot;--------all thread has finished&quot;)print(&quot;num:&quot;, num) # 输出最后的num值小结： 用theading.Lock()创建一个lock的实例。 在线程启动之前通过lock.acquire()加加锁，在线程结束之后通过lock.release()释放锁。 这层锁是用户开的锁，就是我们用户程序的锁。跟我们这个GIL没有关系，但是它把这个数据相当于copy了两份，所以在这里加锁，以确保同一时间只有一个线程，真真正正的修改这个数据，所以这里的锁跟GIL没有关系，你理解就是自己的锁。 加锁，说明此时我来去修改这个数据，其他人都不能动。然后修改完了，要把这把锁释放。这样的话就把程序编程串行了。 死锁&emsp;&emsp;在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁，因为系统判断这部分资源都正在使用，所有这两个线程在无外力作用下将一直等待下去.（大锁内加小锁）1234567891011121314151617181920212223242526272829303132333435import threading,time mutexA=threading.Lock()mutexB=threading.Lock()class MyThread(threading.Thread): def run(self): self.func1() self.func2() def func1(self): print(&apos;%s func1 start&apos;%self.name) mutexA.acquire() print(&apos;%s func1 拿到A锁 &apos;%self.name) mutexB.acquire() print(&apos;%s func1 拿到B锁 &apos;%self.name) mutexB.release() mutexA.release() print(&apos;%s func1 end&apos;%self.name) def func2(self): print(&apos;%s func2 start&apos;%self.name) mutexB.acquire() print(&apos;%s func2 拿到B锁 &apos;%self.name) time.sleep(2) mutexA.acquire() print(&apos;%s func2 拿到A锁 &apos;%self.name) mutexA.release() mutexB.release() print(&apos;%s func2 end&apos;%self.name)if __name__ == &apos;__main__&apos;: for i in range(5): t=MyThread() t.start()线程1拿到B锁，线程3拿到A锁，造成同时等待，而且线程2、4、5也会因为拿不到锁等待。 递归锁（RLock）&emsp;&emsp;这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。12345678910111213141516171819202122232425262728293031323334import threading,time mutexA=mutexB=threading.RLock()class MyThread(threading.Thread): def run(self): self.func1() self.func2() def func1(self): print(&apos;%s func1 start&apos;%self.name) mutexA.acquire() print(&apos;%s func1 拿到A锁 &apos;%self.name) mutexB.acquire() print(&apos;%s func1 拿到B锁 &apos;%self.name) mutexB.release() mutexA.release() print(&apos;%s func1 end&apos;%self.name) def func2(self): print(&apos;%s func2 start&apos;%self.name) mutexB.acquire() print(&apos;%s func2 拿到B锁 &apos;%self.name) time.sleep(2) mutexA.acquire() print(&apos;%s func2 拿到A锁 &apos;%self.name) mutexA.release() mutexB.release() print(&apos;%s func2 end&apos;%self.name)if __name__ == &apos;__main__&apos;: for i in range(5): t=MyThread() t.start()&emsp;&emsp;由于锁A，B是同一个递归锁，thread1拿到A,B锁，counter记录了acquire的次数2次，然后在func1执行完毕，就释放递归锁，在thread1释放完递归锁，执行完func1代码，接下来会有2种可能：1、thread1在次抢到递归锁，执行func2代码 2、其他的线程抢到递归锁，去执行func1的任务代码递归锁用于多重锁的情况，如果只是一层锁，就用不上递归锁递归锁原理其实很简单：就是每开一把门，在字典里面存一份数据，退出的时候去到door1或者door2里面找到这个钥匙退出，如图： 信号量（Semaphore）&emsp;&emsp;之前讲的线程锁（互斥锁）同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去。 信号量是一个变量，控制着对公共资源或者临界区的访问。信号量维护着一个计数器，指定可同时访问资源或者进入临界区的线程数。 每次有一个线程获得信号量时，计数器-1。若计数器为0，其他线程就停止访问信号量，直到另一个线程释放信号量 1234567891011121314151617import threading,time def run(n): semaphore.acquire() # 加信号量锁 time.sleep(5) print(&quot;run the thread: %s\\n&quot; % n) semaphore.release() # 释放信号量锁 if __name__ == &apos;__main__&apos;: semaphore = threading.BoundedSemaphore(5) # 最多允许5个线程同时运行(Bounded:绑定，Semaphore：信号量) for i in range(20): t = threading.Thread(target=run, args=(i,)) t.start()while threading.active_count() != 1: passelse: print(&apos;----all threads done---&apos;) 上面程序的执行，会让人感觉是：分了4组，前5个同时完成，然后又5个同时进去。但是实际的效果是：这5个里面如果有3个完成，就会立刻再放3个进去。不会等5个都完成，每出来1个就放进去1个，出来几个放进去几个使用场景和总结 连接池，线程池，MySQL的有连接池，同一时间有多少个并发，就能连多少个连接。 我们为了保证我的socket_server，因为python不会默认现在你启动多少个线程，但是你启动的线程越多，就会把系统拉的越慢，就会把程序拉的越慢。这里就可以搞一个我同一时间放100线程个进来，就是用semaphore event&emsp;&emsp;事件处理的机制：全局定义了一个“Flag”，如果“Flag”值为 False，那么当程序执行 event.wait 方法时就会阻塞，如果“Flag”值为True，那么event.wait 方法时便不再阻塞。threading.Event 实现线程间通信,使用threading.Event可以使一个线程等待其他线程的通知 event = threading.Event() # 设置一个事件的全局变量 event.is_set() # 判断是否已经设置标志位。 event.wait() # 没有设置标志位的时候会阻塞，一遇到标志位就不会阻塞 #判断是否已经设置标志位。 event.set() # 设置标志位 ，标志位设置了，代表着绿灯，直接通行。 event.clear() # 清除标志位，标志位被清空，代表红灯，wait等待变绿灯。 1234567891011121314151617181920212223242526272829303132333435import threading,time event = threading.Event() # 生成线程事件实例 def lighter(): count = 0 event.set() # 先设置标志位,代表绿灯 while True: if count &gt; 5 and count &lt; 10: # 改成红灯 event.clear() # 清除标志位，变成红灯 print(&quot;red light is on ....&quot;) elif count &gt; 10: event.set() # 创建标志位，变成绿灯 count = 0 else: print(&quot;green light is on ....&quot;) time.sleep(1) count += 1 def car(name): while True: if event.is_set(): # 有标志位，代表是绿灯 print(&quot;&#123;0&#125; running ....&quot;.format(name)) time.sleep(1) else: # 如果不是绿灯就代表红灯 print(&quot;&#123;0&#125; sees red light ,waiting ....&quot;.format(name)) event.wait() # 阻塞 print(&quot;green light is on , start going ...&quot;) light = threading.Thread(target=lighter,) # 启动代表红绿灯的线程light.start()car1 = threading.Thread(target=car, args=(&quot;car1&quot;,)) # 启动代表车的线程car1.start()","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"使用vagrant搭建虚拟开发环境","date":"2018-09-10T13:51:45.000Z","path":"2018/09/10/使用vagrant搭建虚拟开发环境/","text":"虚拟机通过镜像文件创建虚拟环境: virtualbox VMware 什么是Vagrant&emsp;&emsp;Vagrant是构建在虚拟化技术之上的虚拟机运行环境管理工具,它的运行依赖于虚拟机： 建立和删除虚拟机配置虚拟机运行参数管理虚拟机运行状态自动化配置和安装开发环境打包分发虚拟机运行环境 优点&emsp;&emsp;跨平台、可移动、自动化部署无需人工干预 软件安装 virtualbox vagrant(注意vagrant和virtualbox之间的版本关系) xshell vagrant命令虚拟机的本质底层还是一个操作系统，使用虚拟机创建虚拟环境使用.iso文件，vagrant创建虚拟环境使用.box文件。 vagrant常用命令： 命令 描述 vagrant box list 查看目前已有的box vagrant box add 新增加一个box vagrant box remove 删除指定box vagrant init 初始化配置vagrantfile vagrant up 启动虚拟机 vagrant ssh ssh登录虚拟机 vagrant suspend 挂起虚拟机 vagrant reload 重启虚拟机 vagrant halt 关闭虚拟机 vagrant status 查看虚拟机状态 vagrant status 删除虚拟机 实际操作 虚拟机创建的创建和查看&emsp;&emsp;Vagrant使用基础镜像来快速克隆虚拟机，而不是从头开始构建虚拟机。这些基础镜像在 Vagrant 中被称为“box”，并且指定用于 Vagrant 环境的 box 始终是创建新 Vagrantfile 后的第一步。下载好.box文件后使用vagrant box add 虚拟环境名称 box文件名创建虚拟环境 新建imooc文件夹，进入文件夹，初始化配置vagrantfile，此时会生成一个vagrantfile文件 执行vagrant up，会在virtualbox中多一个虚拟环境实例，但是命令行一直会提示 这是由于虚拟机获取不到物理机的公钥, 创建Vagrantfile文件&emsp;&emsp;配置 Vagrant 项目的第一步是创建 Vagrantfile 文件。Vagrantfile 文件的目的有两个： 设置项目的根目录。Vagrant 中的许多配置选项是相对于这个根目录的。描述运行项目的机器类型和资源，以及需要安装的软件和访问方式。 &emsp;&emsp;Vagrant 内置了 vagrant init 命令，用于将目录初始化为 Vagrant 使用。请在你的终端中输入以下命令：123$ mkdir vagrant_getting_started$ cd vagrant_getting_started$ vagrant init &emsp;&emsp;命令执行完后会在你的目录中创建 Vagrantfile 文件。可以查看这个文件，里面写满了注释和示例。虽然看起来很吓人，但不要害怕，我们会尽快修改它。&emsp;&emsp;也可以在预先存在的目录中使用 vagrant init 命令配置已经存在的项目使用 Vagrant。&emsp;&emsp;如果你使用版本控制，则 Vagrantfile 可以用于项目的版本控制。这样，每个与该项目合作的人都可以从 Vagrant 中受益，而无需任何前期工作. box的安装与使用&emsp;&emsp;Vagrant 使用基础镜像来快速克隆虚拟机，而不是从头开始构建虚拟机。这些基础镜像在 Vagrant 中被称为“box”，并且指定用于 Vagrant 环境的 box 始终是创建新 Vagrantfile 后的第一步。 安装 box通过vagrant box add命令可以将 box 加入到 Vagrant。这会将 box 存储在一个特定的名称下，以便多个 Vagrant 环境可以重复利用。如果你还没有添加一个 box，可以这样做：1$ vagrant box add hashicorp/precise64 &emsp;&emsp;这将从 HashiCorp 的 Vagrant Cloud box 目录 下载名为“hashicorp/precise64”的 box。虽然从 HashiCorp 的 Vagrant Cloud下载 box 是最便利的方式，你也可以从本地文件或指定的 URL 等添加 box。&emsp;&emsp;对于当前用户，box 全局存储。每个项目都使用一个 box 作为初始镜像来克隆，并且从不修改基本镜像。这意味着如果你有两个项目都使用我们刚刚添加的 hashicorp/precise64 这个 box，则在一台 guest 机器中添加文件将不会对另一台机器产生影响。&emsp;&emsp;在上面的命令中，你会注意到这些 box 是有命名空间的。box 分为两部分 - 用户名和 box 名 - 用斜线分隔。在上面的例子中，用户名是“hashicorp”，并且 box 是“precise64”。也可以通过 URL 或本地文件路径来指定 box，但入门指南中不会涉及这些内容。 命名空间不保证规范 box！一个常见的误解是像“ubuntu”这样的命名空间代表了 Ubuntu 这个 box 的规范空间。这是不真实的。Vagrant Cloud上的命名空间的行为与 GitHub 上的命名空间非常相似。正如 GitHub 的支持团队无法协助解决某人存储库中的问题一样，HashiCorp 的支持团队无法管理第三方发布的 box。 使用 box&emsp;&emsp;现在 box 已经添加到了 Vagrant，需要配置项目使用这个 box 作为基准镜像。打开空白的 Vagrantfile 文件添加下面的内容：123Vagrant.configure(&quot;2&quot;) do |config| config.vm.box = &quot;hashicorp/precise64&quot;end &emsp;&emsp;这个例子中的“hashicorp/precise64”必须要跟你在上面添加的 box 名字匹配。通过这个配置，Vagrant 知道需要使用哪个 box。如果之前没有添加 box，Vagrant 会在运行时自动下载并添加 box。&emsp;&emsp;可以通过 config.vm.box_version 来指定一个 box 的确切版本：1234Vagrant.configure(&quot;2&quot;) do |config| config.vm.box = &quot;hashicorp/precise64&quot; config.vm.box_version = &quot;1.1.0&quot;end &emsp;&emsp;也可以直接使用 config.vm.box_url 指定一个 box 的 URL：1234Vagrant.configure(&quot;2&quot;) do |config| config.vm.box = &quot;hashicorp/precise64&quot; config.vm.box_url = &quot;http://files.vagrantup.com/precise64.box&quot;end 在下一节中，我们将启动 Vagrant 环境并与其进行一点互动。 查找更多的 box&emsp;&emsp;对于本入门指南的其余部分，我们将仅使用之前添加的“hashicorp/precise64” box。但是在完成入门指南后，第一个问题可能就是“我在哪里可以找到更多的 box？”&emsp;&emsp;HashiCorp 的 Vagrant Cloud box 目录 是寻找更多 box 的最佳地点。HashiCorp 的 Vagrant Cloud 有一个可以通过各种平台和技术免费使用的公共目录。HashiCorp 的 Vagrant Cloud 也有很好的搜索功能，可以让你找到你关心的 box。&emsp;&emsp;除了寻找免费的 box，HashiCorp 的 Vagrant Cloud 允许你托管自己的 box，如果打算为自己的组织创建 box 的话还可以创建私有 box。 启动 vagrant 及 通过 ssh 登录虚拟机&emsp;&emsp;在终端运行 vagrant up 命令即可启动 Vagrant 环境：1$ vagrant up &emsp;&emsp;不到一分钟，命令就会执行完毕，运行 Ubuntu 的虚拟机会启动成功。Vagrant 运行虚拟机的时候没有 UI 界面。可以通过 SSH 连接到机器判断机器是否运行成功：1$ vagrant ssh &emsp;&emsp;这个命令会让你进入一个完整的 SSH 会话。会话建立后可以与机器进行交互，做任何你想做的事情。要小心 rm -rf /，因为 Vagrant 与包含 Vagrantfile 的主机上的目录共享一个 /vagrant 目录，这会删除所有这些文件。共享文件夹将在下一节介绍。&emsp;&emsp;花点时间思考刚刚发生的事情：通过终端中的一行配置和一条命令，我们创建了一个功能齐全的，可通过 SSH 访问的虚拟机。SSH 会话可以用 CTRL + D 终止。12vagrant@precise64:~$ logoutConnection to 127.0.0.1 closed. &emsp;&emsp;完成了需要使用虚拟机的工作后，在你的主机上运行 vagrant destroy，Vagrant 将终止虚拟机使用任何资源。&emsp;&emsp;vagrant destroy 命令实际上并不删除下载的 box 文件。可以使用vagrant box remove 命令彻底删除 box 文件。 同步目录（synced folders）&emsp;&emsp;尽管可以非常轻松的启动一台虚拟机，但很少有人希望通过 SSH 使用基于终端的编辑器来编辑文件。幸运的是，借助 Vagrant 你不需要这样做。通过使用同步目录，Vagrant 会自动同步 guest 机器上的文件。&emsp;&emsp;默认情况下，Vagrant 将你的项目的目录（即 Vagrantfile 的目录）共享到 guest 中的 /vagrant 目录。&emsp;&emsp;注意，当使用 vagrant ssh 目录进入机器时，默认进入 /home/vagrant 目录。 /home/vagrant 是与同步的 /vagrant 目录不同的目录。&emsp;&emsp;如果终端报错，提示不兼容 guest additions（或没有 guest additions），那么可能需要更新 box 或选择不同的 box，如 hashicorp/precise64。一些用户成功使用了 vagrant-vbguest 插件，但它并未得到 Vagrant 核心团队的正式支持。&emsp;&emsp;再次运行 vagrant up 启动 vagrant，然后通过 vagrant ssh 进入机器：123456$ vagrant up...$ vagrant ssh...vagrant@precise64:~$ ls /vagrantVagrantfile &emsp;&emsp;不管你信不信，你在虚拟机中看到的 Vagrantfile 文件实际上是你宿主机上的同一个文件。下面证明一下：1234vagrant@precise64:~$ touch /vagrant/foovagrant@precise64:~$ exit$ lsfoo Vagrantfile &emsp;&emsp;现在，“foo”文件会出现在你的宿主机上。你可以看到，Vagrant 保证了这个目录的同步。&emsp;&emsp;通过同步目录，你可以继续使用宿主机上你自己的编辑器，对宿主机中文件的改动会自动同步到 guest 机器中。 配置&emsp;&emsp;现在我们已经有了一个运行 Ubuntu 的虚拟机，并且可以在宿主机上编辑文件并自动同步到虚拟机。现在让我们安装一个 web 服务器，通过服务器访问这些文件。&emsp;&emsp;可以通过 SSH 进入并安装一个 web 服务器并开始工作，但每个使用 Vagrant 的人都必须这样做。相反，Vagrant 内置了对自动配置的支持。使用此功能时，Vagrant 将在执行 vagrant up 时自动安装软件，以便 guest 机器可以重复创建并可立即使用。 安装 Apache&emsp;&emsp;可以通过 shell 脚本来为刚才的项目设置 Apache。创建下面的 shell 脚本并命名为 bootstrap.sh，保存在 Vagrantfile 文件相同的目录下：12345678#!/usr/bin/env bashapt-get updateapt-get install -y apache2if ! [ -L /var/www ]; then rm -rf /var/www ln -fs /vagrant /var/wwwfi &emsp;&emsp;然后，配置 Vagrant 在设置机器的时候运行这个脚本。编辑 Vagrantfile 文件：1234Vagrant.configure(&quot;2&quot;) do |config| config.vm.box = &quot;hashicorp/precise64&quot; config.vm.provision :shell, path: &quot;bootstrap.sh&quot;end &emsp;&emsp;“provision” 行是新添加的，告诉 Vagrant 使用 shell 命令执行 bootstrap.sh 文件来设置虚拟机。文件路径是相对于 Vagrantfile 文件所在的项目根目录的相对路径。 配置&emsp;&emsp;配置写完后，执行 vagrant up，Vagrant 会自动配置。可以在终端看到 shell 脚本的输出。如果虚拟机已经启动了，则需要执行 vagrant reload –provision，这会快速重启虚拟机并跳过初始化导入阶段。因为 Vagrant 只会在第一次 vagrant up 启动虚拟机的时候自动运行 provisioner，所以需要在 reload 命令中使用 provision 标志指示 Vagrant 必须运行 provisioner。&emsp;&emsp;Vagrant 运行结束后，web 服务器会成功运行。现在还不能在宿主机的浏览器上查看网页，但可以在通过 SSH 进入虚拟机后，通过加载文件来判断配置是否生效：123$ vagrant ssh...vagrant@precise64:~$ wget -qO- 127.0.0.1 &emsp;&emsp;上面例子会正常工作。我们安装 Apache 并设置其默认的 DocumentRoot 指向我们的 /vagrant 这个默认的同步目录。&emsp;&emsp;可以创建更多文件并在终端查看，下一步需要配置网络选项以便用宿主机的浏览器访问虚拟机。 对于复杂的配置脚本，将自定义的 Vagrant box 与预先安装的软件包打包在一起，而不是每次构建它们可能会更高效。入门指南未涵盖此主题，但可以在 自定义 box 文档中找到该主题。 网络&emsp;&emsp;现在，我们启动了 web 服务器，并且通过同步目录使用宿主机上的文件提供服务。然而，还只能通过虚拟机中的终端访问服务器。这一章节中，我们会使用 Vagrant 的网络特性，配置 Vagrant 以便从宿主机访问服务器。 端口转发（Port Forwarding）&emsp;&emsp;配置文件中支持端口转发选项。通过端口转发，可以在访问宿主机的某个端口时，自动将流量转发到虚拟机的指定端口。&emsp;&emsp;编辑 Vagrantfile 文件即可实现端口转发： 12345Vagrant.configure(&quot;2&quot;) do |config| config.vm.box = &quot;hashicorp/precise64&quot; config.vm.provision :shell, path: &quot;bootstrap.sh&quot; config.vm.network :forwarded_port, guest: 80, host: 4567end &emsp;&emsp;运行 vagrant reload 或 vagrant up（取决于虚拟机是否已经启动）加载配置。&emsp;&emsp;一旦虚拟机启动成功，在宿主机的浏览器中访问 http://127.0.0.1:4567。你应该看到虚拟机中的 web 服务器提供的网页。 其他网络Vagrant 还有其他网络配置选项，可以为虚拟机分配静态 IP 地址，或将虚拟机桥接到一个已经存在的网络上。更多资料参考这里。 share&emsp;&emsp;译者注：Vagrant Share 功能通过 ngrok 向所有人提供访问内网开发环境的能力。&emsp;&emsp;现在我们已经启动并运行了一台 Web 服务器，并且可以从你的机器访问，我们拥有一个相当实用的开发环境。但除了提供开发环境外，Vagrant 还可以轻松地在这些环境中共享和协作。Vagrant 中实现这个功能的特性叫做 Vagrant Share。&emsp;&emsp;Vagrant Share 使你可以通过网络向任何人共享 Vagrant 环境。这个功能会提供一个 URL 给你，任何人都可以通过这个 URL 路由到你的 Vagrant 环境。&emsp;&emsp;运行 vagrant share：12345$ vagrant share...==&gt; default: Creating Vagrant Share session...==&gt; default: HTTP URL: http://b1fb1f3f.ngrok.io... &emsp;&emsp;每个人的 URL 都是不同的。复制你的 URL，通过浏览器访问即可。&emsp;&emsp;如果你修改了共享目录中的文件，刷新 URL 后你会发现更新实时生效。这个 URL 直接路由到你的 Vagrant 环境，可以在世界上任意地点访问。&emsp;&emsp;在终端中通过 Ctrl + C 结束共享会话。可以再次刷新 URL 来验证开发环境是否仍在共享中。&emsp;&emsp;Vagrant Share 比简单的 HTTP 共享更加强大。详情参考 Vagrant Share 文档。 清理（teardown）&emsp;&emsp;我们现在有一个功能齐全的虚拟机，可以用于基本 Web 开发。但如果现在需要更换设备，或者在另一个项目上工作，如何清理我们的开发环境？&emsp;&emsp;借助 Vagrant，可以暂停（suspend），停止（halt）或销毁（destroy）虚拟机。每个选项都有优点和缺点。选择最适合的即可。 暂停（suspend）：通过调用 vagrant suspend 命令可以暂停虚拟机，此时会保存虚拟机当前运行状态并停止运行。当准备好再次工作时，运行 vagrant up 命令即可从上次暂停的状态恢复。这个方法的最大优点就是快，只要 5 到 10 秒就可以停止并开始工作。缺点是虚拟机仍占用磁盘空间，并且需要消耗更大的磁盘空间来保存虚拟机的 RAM 状态。 停止（halt）：通过调用 vagrant halt 命令可以优雅关闭虚拟机操作系统并断电。需要再次启动的时候，运行 vagrant up 命令即可。这个方法的好处是会干净地关闭你的机器，保存磁盘的内容，并让它再次干净地启动。缺点是冷启动需要较长时间，且虚拟机仍占用磁盘空间。 销毁（destroy）：通过调用 vagrant destroy 销毁虚拟机，这将从宿主机中删除虚拟机的所有痕迹。它会停止虚拟机，关闭它并删除其所有硬盘资源。当你准备好再次工作时，运行 vagrant up 命令即可。这样做的好处是，宿主机上不会留下残余物。虚拟机消耗的磁盘空间和 RAM 将被回收，并且主机保持清洁。缺点是，由于需要重新导入虚拟机并重新配置，因此需要更多时间。 https://app.vagrantup.com/boxes/search","tags":[{"name":"项目部署","slug":"项目部署","permalink":"http://yoursite.com/tags/项目部署/"}]},{"title":"django-扩展Django自带User模型，实现用户注册与登录","date":"2018-09-03T09:04:04.000Z","path":"2018/09/03/django-扩展Django自带User模型，实现用户注册与登录/","text":"&emsp;&emsp;用户的注册与登陆是一个网站应该具有的基本功能。前面的文章讲解了django自带的auth模块并使用第三方库完成登录注册等功能，今天来好好聊一聊如何扩展扩展Django自带User模型，并自己实现登录注册等功能。 扩展自带User模型&emsp;&emsp;我们需要实现用户登录注册功能就要先设计user表，如果django原有的user表不满足项目需求可以重新设计user表。 已有字段: id: 主键username 用户名，该字段不要随便改动password 密码email 邮箱first_name：名last_name：姓last_login Django自动记录用户最后登录时间is_superuser 表明用户是否是超级用户,默认是False(后台管理会用到)is_staff 表示是否是员工，默认是False(后台管理会用到)is_active 用户是否是激活状态，默认是Truedate_joined 注册时间，系统自动生成。 继承AbstractUser的方式 自定义user表12345678910111213141516171819from django.db import modelsfrom django.contrib.auth.models import AbstractUserclass UserProfile(AbstractUser): gender_choices = ( (&apos;male&apos;,&apos;男&apos;), (&apos;female&apos;,&apos;女&apos;) ) nick_name = models.CharField(&apos;昵称&apos;,max_length=50,default=&apos;&apos;) birthday = models.DateField(&apos;生日&apos;,null=True,blank=True) gender = models.CharField(&apos;性别&apos;,max_length=10,choices=gender_choices,default=&apos;female&apos;) adress = models.CharField(&apos;地址&apos;,max_length=100,default=&apos;&apos;) mobile = models.CharField(&apos;手机号&apos;,max_length=11,null=True,blank=True) image = models.ImageField(upload_to=&apos;image/%Y%m&apos;,default=&apos;image/default.png&apos;,max_length=100) class Meta: verbose_name = &apos;用户信息&apos; verbose_name_plural = verbose_name def __str__(self): return self.username 然后再setting.py中修改: AUTH_USER_MODEL = ‘users.UserProfile’ 执行makemigrations和migrate生成数据表: python manage.py makemigrationspython manage.py migrate 特别要注意图片和文件model需要指出上传地址upload_to image = models.ImageField(‘轮播图’,upload_to=’banner/%Y%m’,max_length=100)download = models.FileField(“资源文件”,upload_to=”course/resource/%Y/%m”,max_length=100) 图片上传需要安装第三方库 pip install pillow 使用1对1方式我们创建一个UserProfile模型，它只是对User模型的扩展, 与User是1对1的关系。1234567891011121314from django.db import modelsfrom django.contrib.auth.models import Userclass UserProfile(models.Model): # 与User是1对1关系 user = models.OneToOneField(User, on_delete=models.CASCADE, related_name=&apos;profile&apos;) org = models.CharField(&apos;Organization&apos;, max_length=128, blank=True) telephone = models.CharField(&apos;Telephone&apos;, max_length=50, blank=True) mod_date = models.DateTimeField(&apos;Last modified&apos;, auto_now=True) class Meta: verbose_name = &apos;User Profile&apos; def __str__(self): return self.user 然后你可以在终端输入以下命令，就可以创建UserProfile的数据表。12python manage.py makemigrations python manage.py migrate 登录注册功能的实现- 配置url url(r’^accounts/‘, include(‘users.urls’)), users.urls123456url(r&apos;^register/$&apos;, views.register, name=&apos;register&apos;),url(r&apos;^login/$&apos;, views.login, name=&apos;login&apos;),url(r&apos;^logout/$&apos;, views.logout, name=&apos;logout&apos;),url(r&apos;^user/(?P&lt;pk&gt;\\d+)/profile/$&apos;, views.profile, name=&apos;profile&apos;),url(r&apos;^user/(?P&lt;pk&gt;\\d+)/profile/update/$&apos;,views.profile_update,name=&apos;profile_update&apos;),url(r&apos;^user/(?P&lt;pk&gt;\\d+)/pwdchange/$&apos;, views.pwd_change,name=&apos;pwd_change&apos;),","tags":[{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"}]},{"title":"Docker入门","date":"2018-09-03T09:03:44.000Z","path":"2018/09/03/Docker入门/","text":"Docker概念&emsp;&emsp;Docker是开发人员和系统管理员使用容器进行开发，部署和运行应用程序的平台。使用Linux容器部署应用程序称为容器化。&emsp;&emsp;容器化越来越受欢迎，因为容器是： 灵活：即使是最复杂的应用也可以集装箱化。 轻量级：容器利用并共享主机内核。 可互换：您可以即时部署更新和升级。 便携式：您可以在本地构建，部署到云，并在任何地方运行。 可扩展：您可以增加并自动分发容器副本。 可堆叠：您可以垂直和即时堆叠服务。 图像和容器&emsp;&emsp;通过运行image启动容器。一个image是一个可执行的包，其中包括运行应用程序所需的所有代码，以及运行时的库，环境变量和配置文件。 容器和虚拟机&emsp;&emsp;容器在Linux上本机运行，与其他容器共享主机的内核。它运行一个独立的进程，不占用任何其他可执行文件的内存，使其轻量级。相比之下，虚拟机（VM）运行一个完整的“客户”操作系统，通过虚拟机管理程序对主机资源进行虚拟访问。通常，VM提供的环境比大多数应用程序需要的资源更多。 测试Docker版本&emsp;&emsp;运行docker –version并确保您拥有受支持的Docker版本：12docker --versionDocker version 17.12.0-ce, build c97c6d6 &emsp;&emsp;运行docker info或（docker version不–）查看有关docker安装的更多详细信息：12345678910docker infoContainers: 0 Running: 0 Paused: 0 Stopped: 0Images: 0Server Version: 17.12.0-ceStorage Driver: overlay2... &emsp;&emsp;要避免权限错误（以及使用sudo），请将您的用户添加到docker组中。阅读更多。 测试Docker安装&emsp;&emsp;通过运行简单的Docker镜像hello-world来测试您的安装是否有效 ：1234567891011docker run hello-worldUnable to find image &apos;hello-world:latest&apos; locallylatest: Pulling from library/hello-worldca4f61b1923c: Pull completeDigest: sha256:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.... &emsp;&emsp;列出hello-world下载到您的计算机的图像：1docker image ls &emsp;&emsp;列出hello-world在显示其消息后退出的容器（由图像生成）。如果它仍在运行，您将不需要–all选项：1234docker container ls --allCONTAINER ID IMAGE COMMAND CREATED STATUS54f4984ed6a8 hello-world &quot;/hello&quot; 20 seconds ago Exited (0) 19 seconds ago Docker指令12345678910111213141516171819## List Docker CLI commandsdockerdocker container --help## Display Docker version and infodocker --versiondocker versiondocker info## Execute Docker imagedocker run hello-world## List Docker imagesdocker image ls## List Docker containers (running, all, all in quiet mode)docker container lsdocker container ls --alldocker container ls -aq 新的开发环境&emsp;&emsp;在过去，如果您要开始编写Python应用程序，那么首先需要在你的计算机上安装Python运行环境。而且该环境需要非常适合你的应用程序按预期运行，并且还需要与你的生产环境相匹配。&emsp;&emsp;如果使用Docker，你可以将可移植的Python运行环境时作为映像获取，无需安装。 然后，您的构建可以在应用程序代码旁边包含基本Python映像，确保您的应用程序，其依赖项和运行时都一起运行。&emsp;&emsp;这些可移植图像由称为Dockerfile的东西定义。 在win创建并运行一个容器 Dockerfile&emsp;&emsp;创建一个空目录。cd进入该目录，创建一个名为Dockerfile的文件，将以下内容复制并粘贴到该文件中，然后保存。Dockerfile命名必须为“Dockerfile”，Docker镜像构建时，会查找指定目录中的Dockerfile。 1234567891011121314151617181920# Use an official Python runtime as a parent imageFROM python:2.7-slim# Set the working directory to /appWORKDIR /app# Copy the current directory contents into the container at /appADD . /app# Install any needed packages specified in requirements.txtRUN pip install --trusted-host pypi.python.org -r requirements.txt# Make port 80 available to the world outside this containerEXPOSE 80# Define environment variableENV NAME World# Run app.py when the container launchesCMD [&quot;python&quot;, &quot;app.py&quot;] 应用程序本身&emsp;&emsp;再创建两个文件，requirements.txt和app.py requirements.txt12FlaskRedis app.py123456789101112131415161718192021222324from flask import Flaskfrom redis import Redis, RedisErrorimport osimport socket#Connect to Redisredis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)app = Flask(__name__)@app.route(&quot;/&quot;)def hello(): try: visits = redis.incr(&quot;counter&quot;) except RedisError: visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot; html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \\ &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot; \\ &quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot; return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)if __name__ == &quot;__main__&quot;: app.run(host=&apos;0.0.0.0&apos;, port=80) 构建应用程序&emsp;&emsp;我们准备构建应用程序。确保您仍处于新目录的顶层。这是ls应该显示的内容：12$ lsDockerfile app.py requirements.txt &emsp;&emsp;现在运行build命令。这会创建一个Docker镜像，我们将使用-t它来标记，因此它具有友好的名称。1docker build -t friendlyhello . &emsp;&emsp;你的构建的镜像将位于您机器的本地Docker镜像注册表中：123$ docker image lsREPOSITORY TAG IMAGE IDfriendlyhello latest 326387cea398 4.运行该应用程序&emsp;&emsp;运行应用程序，使用以下方法将计算机的端口4000映射到容器的已发布端口80 -p：1docker run -p 4000:80 friendlyhello &emsp;&emsp;浏览器打开http://localhost:4000 . 就可以访问hello world. 1. 如果使用win,请使用Docker Machine IP而不是localhost。例如，http：//192.168.99.100：4000。要查找IP地址，请使用该命令docker-machine ip。 2.如果在阿里云运行,需要访问IP:4000,注意要在安全组中添加规则 Dockerfile|Docker镜像|容器之间关系 Dockerfile：Dockerfile 是一个文本文件， 它是Docker镜像的描述文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。有了 Dockerfile，当我们需要定制自己额外的需求时，只需在 Dockerfile 上添加或者修改指令，重新生成 image 即可，省去了敲命令的麻烦。 Docker镜像： 通过Dockerfile做出来的，包含操作系统基础文件和软件运行环境，它使用分层的存储方式。 容器： 是运行起来的镜像，简单理解，Docker镜像相当于程序，容器相当于进程。使用 Dockerfile 定义镜像，依赖镜像来运行容器 &emsp;&emsp;Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令、容器启动执行指令。一开始必须要指明所基于的镜像名称，接下来一般会说明维护者信息；后面则是镜像操作指令，例如 RUN 指令。每执行一条RUN 指令，镜像添加新的一层，并提交；最后是 CMD 指令，来指明运行容器时的操作命令。","tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}]},{"title":"django-FBV&CBV","date":"2018-09-02T06:01:52.000Z","path":"2018/09/02/django-FBV&CBV/","text":"FBVFBV（function base views） 就是在视图里使用函数处理请求。1234567url(r&apos;^index/&apos;, views.index),def index(request): if request.method == &quot;GET&quot;: return HttpResponse(&quot;GET&quot;) elif request.method == &quot;POST&quot;: return HttpResponse(&quot;POST&quot;) step1：根据访问请求，在urls寻找匹配的url映射，得到views.indexsetp2：根据views.index ，调用views下index函数（传入参数request即用户请求信息）step3：根据客户请求信息对数据进行处理，通过HttpResponse返回客户端 CBVCBV（class base views） 就是在视图里使用类处理请求。12345678url(r&apos;^index/&apos;, views.Index.as_view()),from django.views import Viewclass Index(View): def get(self, request): return HttpResponse(&quot;GET&quot;) def post(self, request): return HttpResponse(&quot;POST&quot;) 如果是get或者post都执行的代码可以放到dispatch:123456def dispatch(self, request, *args, **kwargs): # 调用父类中的dispatch print(&apos;before&apos;) # 类似装饰器的功能 result = super(Home,self).dispatch(request, *args, **kwargs) print(&apos;after&apos;) # 类似装饰器的功能 return result 其实CBV过程可以看成是FBV过程的抽象化、对象化。他需要最基本的三个类View，ContextMixin，TemplateResponseMixin对应FBV的三个步骤： step1. View类提供类方法as_view(),用于调用dipatch()，根据request类型分发给get，post…等对应方法处理。step2. ContextMixin类，get_context_data(self, **kwargs)获取上下文数据，如果对数据库进行操作均可以继承该类，然后将增删改查的结果放入上下文数据中（即重写get_context_data）step3. TemplateResponseMixin类，将内容渲染到指定模板上，通过render_to_response()方法实现对应功能而其他模板视图基本就是在这三个类上进行继承重写后得到。","tags":[{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"}]},{"title":"django-编辑器Markdown的使用","date":"2018-09-01T14:46:43.000Z","path":"2018/09/01/django-编辑器Markdown的使用/","text":"&emsp;&emsp;之前的一篇博客写到了如何在django中使用Ueditor,今天我们看看如何在django中使用Markdown进行文本的编辑.它是基于editor.md插件 Markdown的安装Markdown使用的是源码安装的方式: 首先到github下载源码 把里面的markdown文件夹放到extra_apps中 然后在INSTALLED_APPS中添加markdown.并在url.py中添加: url(r’^markdown/‘, include(‘markdown.urls’)), 在setting.py中设置图片上传的文件夹 MARKDOWN_IMAGE_FLODER = ‘ markdown ‘ #图片会上传到media/markdown文件夹下 配置上传图片格式 MARKDOWN_IMAGE_FORMATS = [“jpg”，”jpeg”，”gif”，”png”，”bmp”，”webp”] 在admin中使用&emsp;&emsp;所有的TextField都使用markdown编辑器:12345678from django.db import modelsfrom markdown.widgets import AdminMarkdownWidgetclass TestAdmin(admin.ModelAdmin): formfield_overrides = &#123; models.TextField: &#123;&apos;widget&apos;: AdminMarkdownWidget()&#125;, &#125;admin.site.register(Test,TestAdmin) 在xadmin中使用12345678from django.db import modelsfrom markdown.widgets import XAdminMarkdownWidgetclass TestAdmin(admin.ModelAdmin): formfield_overrides = &#123; models.TextField: &#123;&apos;widget&apos;: XAdminMarkdownWidget()&#125;, &#125;xadmin.site.register(Test,TestAdmin) 在form中使用123456from django import formsfrom markdown.forms import MarkdownFieldclass BlogForm(forms.Form): name = forms.CharField() context = MarkdownField() 这里注意在前端需要添加去添加css和js1234567&lt;head&gt; &lt;title&gt;Hello Django!&lt;/title&gt; &#123;&#123;form.media&#125;&#125;&lt;/head&gt;&lt;body&gt;&#123;&#123;form&#125;&#125;&lt;/body&gt; 支持参数 widthheightthemepreviewThemeeditorThemesyncScrollingsaveHTMLToTextareaemojitaskListtocmtexflowChartsequenceDiagramcodeFold 123formfield_overrides = &#123; models.TextField: &#123;&apos;widget&apos;: AdminMarkdownWidget(emoji=False)&#125;, &#125; 最终后端效果 前端显示&emsp;&emsp;你会发现前端显示是有问题的,这个时候需要把markdown语法转换为html,我们需要安装django-markdown-deux. 首先运行 pip install django-markdown-deux 在INSTALLED_APPS中添加markdown_deux 在需要显示markdown的页面:12&#123;% load markdown_deux_tags %&#125;&#123;&#123; course.detail | markdown &#125;&#125; 最后效果: &emsp;&emsp;这里还有一个问题就是无法修改图片的大小,目前没有比较有效的解决办法,如果对图片大小要求比较高,可以使用七牛等支持参数的图床,如果有其他想法,欢迎交流~","tags":[{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"},{"name":"文本编辑","slug":"文本编辑","permalink":"http://yoursite.com/tags/文本编辑/"}]},{"title":"django-编辑器Ueditor的使用","date":"2018-09-01T14:46:26.000Z","path":"2018/09/01/django-编辑器Ueditor的使用/","text":"&emsp;&emsp;Ueditor是比较流行的富文本编辑器,主要用于内容的编辑、排版和图片上传等。本文主要介绍Ueditor的安装并搭配xadmin的使用。 富文本编辑器Ueditor&emsp;&emsp;UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码。 Ueditor的源码安装&emsp;&emsp;前往github下载源码然后解压，把DjangoUeditor文件夹拷贝到项目目录(extra_apps)下面。 setting和url中的配置 settings中添加app 123INSTALLED_APPS = [ &apos;DjangoUeditor&apos;,] MxOnline/urls.py 1path(&apos;ueditor/&apos;,include(&apos;DjangoUeditor.urls&apos; )), model和adminx中的配置 course/models.py中Course修改detail字段 1234class Course(models.Model): # detail = models.TextField(&quot;课程详情&quot;) detail = UEditorField(verbose_name=u&apos;课程详情&apos;, width=600, height=300, imagePath=&quot;courses/ueditor/&quot;, filePath=&quot;courses/ueditor/&quot;, default=&apos;&apos;) xadmin/plugs目录下新建ueditor.py文件,代码如下: 1234567891011121314151617181920212223242526272829303132import xadminfrom xadmin.views import BaseAdminPlugin, CreateAdminView, ModelFormAdminView, UpdateAdminViewfrom DjangoUeditor.models import UEditorFieldfrom DjangoUeditor.widgets import UEditorWidgetfrom django.conf import settingsclass XadminUEditorWidget(UEditorWidget): def __init__(self, **kwargs): self.ueditor_options = kwargs self.Media.js = None super(XadminUEditorWidget,self).__init__(kwargs)class UeditorPlugin(BaseAdminPlugin): def get_field_style(self, attrs, db_field, style, **kwargs): if style == &apos;ueditor&apos;: if isinstance(db_field, UEditorField): widget = db_field.formfield().widget param = &#123;&#125; param.update(widget.ueditor_settings) param.update(widget.attrs) return &#123;&apos;widget&apos;:XadminUEditorWidget(**param)&#125; return attrs def block_extrahead(self, context, nodes): js = &apos;&lt;script type=&quot;text/javascript&quot; src=&quot;%s&quot;&gt;&lt;/script&gt;&apos; %(settings.STATIC_URL + &quot;ueditor/ueditor.config.js&quot;) js += &apos;&lt;script type=&quot;text/javascript&quot; src=&quot;%s&quot;&gt;&lt;/script&gt;&apos; %(settings.STATIC_URL + &quot;ueditor/ueditor.all.min.js&quot;) nodes.append(js)xadmin.site.register_plugin(UeditorPlugin, UpdateAdminView)xadmin.site.register_plugin(UeditorPlugin, CreateAdminView) xadmin/plugs/init.py里面添加ueditor插件 123PLUGINS = ( &apos;ueditor&apos;,) course/adminx.py中使用: 123class CourseAdmin(object): #detail就是要显示为富文本的字段名 style_fields = &#123;&quot;detail&quot;: &quot;ueditor&quot;&#125; xadmin后台效果&emsp;&emsp;但是前段显示还是会有问题:&emsp;&emsp;这是因为需要在模板中必须关闭Django的自动转义才能正常显示:123&#123;% autoescape off %&#125;&#123;&#123; course.detail &#125;&#125;&#123;% endautoescape %&#125; 最终显示效果","tags":[{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"},{"name":"文本编辑","slug":"文本编辑","permalink":"http://yoursite.com/tags/文本编辑/"}]},{"title":"在线教育平台Mxonline-xadmin的使用","date":"2018-09-01T05:10:09.000Z","path":"2018/09/01/在线教育平台Mxonline-xadmin的使用/","text":"&emsp;&emsp;django自带了admin用于后台管理，但是在github上还有一个更好看、功能更强大的库来管理后台，叫xadmin，今天就来好好介绍一下xadmin的使用。 xadmin的安装&emsp;&emsp;通过文档我们可以发现，我们有两种方法可以进行安装。 使用pip install 安装 pip install django-xadmin 下载源码安装 需要安装requirements.txt中的依赖包 &emsp;&emsp;关于源码安装，首先到github搜索 xadmin下载源码，然后在项目的工程目录下新建一个extra_apps，把源码放在该目录下，注意extra_apps需要与apps一样在settings中设置。这里不在重复叙述了，然后手动安装requirements.txt中的依赖包。最后在INSTALLED_APPS中添加xadmin和crispy_forms。&emsp;&emsp;接下来配置url: from extra_apps import xadminurl(r’^xadmin/‘, xadmin.site.urls), &emsp;&emsp;然后执行migrations和migrate生成数据库表并创建superuser.就可以访问登录啦 注册app到xadmin后台 在app文件夹中新建adminx.py:123456789101112import xadminfrom .models import EmailVerifyRecord#xadmin中这里是继承object，不再是继承adminclass EmailVerifyRecordAdmin(object): # 显示的列 list_display = [&apos;code&apos;, &apos;email&apos;, &apos;send_type&apos;, &apos;send_time&apos;] # 搜索的字段，不要添加时间搜索 search_fields = [&apos;code&apos;, &apos;email&apos;, &apos;send_type&apos;] # 过滤 list_filter = [&apos;code&apos;, &apos;email&apos;, &apos;send_type&apos;, &apos;send_time&apos;]xadmin.site.register(EmailVerifyRecord,EmailVerifyRecordAdmin) xadmin的全局配置 全局配置,包括title和footer等 app名称汉化，菜单收叠。 使用Xadmin的主题功能。 全局配置12345678910from xadmin import viewsclass GlobalSettings(object): # 修改title site_title = &apos;Mxonline后台管理界面&apos; # 修改footer site_footer = &apos;在线教育平台&apos; # 收起菜单 menu_style = &apos;accordion&apos; #将title和footer信息进行注册xadmin.site.register(views.CommAdminView,GlobalSettings) 主题功能12345678from xadmin import views#创建xadmin的最基本管理器配置，并与view绑定class BaseSetting(object): # 开启主题功能 enable_themes = True use_bootswatch = True#将基本配置管理与view绑定xadmin.site.register(views.BaseAdminView,BaseSetting) 修改app的名字&emsp;&emsp;在后台左侧的app显示还是英文,如果要设置为中文需要在apps.py中添加verbose_name,然后在init.py中添加default_app_config.12345678apps.pyfrom django.apps import AppConfigclass UsersConfig(AppConfig): name = &apos;users&apos; verbose_name = &apos;用户&apos; __init__.pydefault_app_config = &apos;users.apps.UsersConfig&apos; 最终效果 后台用户用户权限&emsp;&emsp;超级用户拥有所有权限，其它添加的用户默认没有任何权限。进后台添加一个用户“Editor1”,勾上“职员状态”后，这个用户才可以登录进后台。&emsp;&emsp;默认没添加权限的用户登录到后台的情况如下：&emsp;&emsp;使用超级管理员账号登录后为用户Editor1添加查看章节的权限后：&emsp;&emsp;也可以添加一个组赋予相关权限，然后把用户添加到组中：&emsp;&emsp;重新登录Editor1查看权限：&emsp;&emsp;组里面的成员不但拥有自己本身的权限外，还会拥有组的权限 自定义icon&emsp;&emsp;xadmin的图标采用的是第三方css样式“font awesome”,我们可以进官网下载最新的样式替代原本的，下载地址&emsp;&emsp;下载完后把里面的“css”和“fonts”两个文件夹拷贝到xadmin的源码（路径：xadmin/static/vendor/font-awesome）里面 使用方法： 以course为例，进官网找到图标的样式 在course/adminx.py使用 12class CourseAdmin(object): model_icon = &apos;fa fa-book&apos; 后台内容设置默认排序、只读字段和不显示的字段123456789class CourseAdmin(object): &apos;&apos;&apos;课程&apos;&apos;&apos; list_display = [ &apos;name&apos;,&apos;desc&apos;,&apos;detail&apos;,&apos;degree&apos;,&apos;learn_times&apos;,&apos;students&apos;] #显示的字段 search_fields = [&apos;name&apos;, &apos;desc&apos;, &apos;detail&apos;, &apos;degree&apos;, &apos;students&apos;] #搜索 list_filter = [ &apos;name&apos;,&apos;desc&apos;,&apos;detail&apos;,&apos;degree&apos;,&apos;learn_times&apos;,&apos;students&apos;] #过滤 model_icon = &apos;fa fa-book&apos; #图标 ordering = [&apos;-click_nums&apos;] #排序 readonly_fields = [&apos;click_nums&apos;] #只读字段，不能编辑 exclude = [&apos;fav_nums&apos;] #不显示的字段 inlines添加数据&emsp;&emsp;model设计时章节信息和资源指向课程,但是按之前的配置方式章节信息和课程资源需要分开添加,我们可以用inlines去实现使用添加课程的时候添加章节和课程资源.123456789class LessonInline(object): model = Lesson extra = 0class CourseResourceInline(object): model = CourseResource extra = 0#在CourseAdmin中使用inlines添加上面两个的方法class CourseAdmin(object): inlines = [LessonInline,CourseResourceInline] #增加章节和课程资源 &emsp;&emsp;可以看到在添加课程页面就可以直接添加与之关联的章节信息和资源的内容. 一张表分两个Model来管理比如课程里面分为轮播课程和不是轮播课程两种类型，它们是存储在同一张表,但是我们可以分开来管理.1234567class BannerCourse(Course): &apos;&apos;&apos;显示轮播课程&apos;&apos;&apos; class Meta: verbose_name = &apos;轮播课程&apos; verbose_name_plural = verbose_name #这里必须设置proxy=True，这样就不会再生成一张表，同时还具有Model的功能 proxy = True #一种继承的方式 1234567普通课程和轮播课程的后台管理通过添加该函数来进行筛选.def queryset(self): # 重载queryset方法，来过滤出我们想要的数据的 qs = super(CourseAdmin, self).queryset() # 只显示is_banner=True的课程 qs = qs.filter(is_banner=False) return qs 其他常用功能 list_editable : 在列表页可以直接编辑的 12class CourseAdmin(object): list_editable = [&apos;degree&apos;,&apos;desc&apos;] 自定义函数作为列显示 12345678910model.pyclass Course(models.Model):def get_zj_nums(self): #获取课程的章节数 return self.lesson_set.all().count()get_zj_nums.short_description = &apos;章节数&apos; #在后台显示的名称adminx.pyclass CourseAdmin(object): list_display = [&apos;get_zj_nums&apos;] #直接使用函数名作为字段显示 显示自定义的html代码 1234567891011model.pyclass Course(models.Model):def go_to(self): from django.utils.safestring import mark_safe #mark_safe后就不会转义 return mark_safe(&quot;&lt;a href=&apos;https://home.cnblogs.com/u/derek1184405959/&apos;&gt;跳转&lt;/a&gt;&quot;)go_to.short_description = &quot;跳转&quot;adminx.pyclass CourseAdmin(object): list_display = [&apos;go_to&apos;] refresh定时刷新工具 12class CourseAdmin(object): refresh_times = [3,5] #自动刷新（里面是秒数） 字段联动 1234567891011121314class CourseAdmin(object): def save_models(self): # 在保存课程的时候统计课程机构的课程数 # obj实际是一个course对象 obj = self.new_obj # 如果这里不保存，新增课程，统计的课程数会少一个 obj.save() # 确定课程的课程机构存在。 if obj.course_org is not None: #找到添加的课程的课程机构 course_org = obj.course_org #课程机构的课程数量等于添加课程后的数量 course_org.course_nums = Course.objects.filter(course_org=course_org).count() course_org.save()","tags":[{"name":"django项目","slug":"django项目","permalink":"http://yoursite.com/tags/django项目/"},{"name":"Mxonline","slug":"Mxonline","permalink":"http://yoursite.com/tags/Mxonline/"},{"name":"xadmin","slug":"xadmin","permalink":"http://yoursite.com/tags/xadmin/"}]},{"title":"在线教育平台Mxonline-django基本设置和model设计","date":"2018-09-01T05:09:09.000Z","path":"2018/09/01/在线教育平台Mxonline-django基本设置和model设计/","text":"&emsp;&emsp;在学习了一段时间的django框架后，也做了几个较为完整的项目，现将整个的过程做个记录和整理，也算是进行一次章节和回顾吧。接下来几天将从项目工程创建到linux服务器部署中较为关键的点进行记录和总结。 开发环境和开发平台 win10 Pycharm python3.6.2 django1.11.6 虚拟环境的安装与使用 virtualenv的安装：在win下使用pip install virtualenv执行安装,安装成功后使用pip list可以查看到版本信息 在需要创建虚拟环境的目录下执行virtualenv testvir就可以创建一个虚拟环境. cd 进入虚拟环境目录,通过dir查看该目录下文件,cd Scripts,执行activate可以激活虚拟环境,执行deactivate.bat可以退出虚拟环境 virtualenvwrapper可以进行虚拟环境的管理 win下安装pip install virtualenvwrapper-win,安装成功后使用mkvirtualenv testEve创建虚拟环境,会提示创建的虚拟环境的位置 使用workon查看已经安装的虚拟环境,使用workon testEve,如果虚拟环境已经激活,在任何时候执行deactivate.bat就可以退出虚拟环境 新工程设置&emsp;&emsp;工程目录下创建log(日志)、media(上传文件)、templates(模板文件)、static(静态文件)，并新建setting_dev.py用于存储密码等信息，如果将项目托管于github可以把该文件放到.gitignore.&emsp;&emsp;在工程目录下新建apps用于存放所有app,此时导入需要from apps.app1 import views,可以apps右键Mark Directory As - Sources Root(全局搜索路径),然后就可以通过from app1 import views,但是Mark后Pycharm能识别,但是使用命令行无法识别,需要再在setting中添加: sys.path.inser(0,os.path.join(BASE_DIR,’apps’)) 其他配置： 数据库切换成mysql,安装mysqlclient连接myql,同时在setting_dev.py中配置数据库12345678910DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;mxonline&apos;, #数据库名字 &apos;USER&apos;: &apos;root&apos;, #账号 &apos;PASSWORD&apos;: &apos;123456&apos;, #密码 &apos;HOST&apos;: &apos;127.0.0.1&apos;, #IP &apos;PORT&apos;: &apos;3306&apos;, #端口 &#125;&#125; 在setting.py配置上传文件和静态文件的路径:123456STATIC_URL = &apos;/static/&apos;STATICFILES_DIRS = ( os.path.join(BASE_DIR,&apos;static&apos;),)MEDIA_URL = &apos;/media/&apos;MEDIA_ROOT = os.path.join(BASE_DIR,&apos;media&apos;) 在url中配置处理图片的视图函数1234from django.conf.urls.static import staticfrom django.conf import settingsif settings.DEBUG: urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) 修改语言和时区12345LANGUAGE_CODE = &apos;zh_hans&apos;TIME_ZONE = &apos;Asia/Shanghai&apos;USE_I18N = TrueUSE_L10N = TrueUSE_TZ = False &emsp;&emsp;根据项目要求,会有一个users、course、organization的app,同时针对用户的各种操作设计operation的app python manage.py startapp userspython manage.py startapp coursepython manage.py startapp organizationpython manage.py startapp operation model设计&emsp;&emsp;在model设计之前一定要梳理每一个model需要哪些字段,这是一个项目的关键.","tags":[{"name":"django项目","slug":"django项目","permalink":"http://yoursite.com/tags/django项目/"},{"name":"Mxonline","slug":"Mxonline","permalink":"http://yoursite.com/tags/Mxonline/"}]},{"title":"常用Markdown语法说明","date":"2018-08-30T13:10:19.000Z","path":"2018/08/30/常用Markdown语法说明/","text":"Markdown 是一种轻量级标记语言，它允许人们“使用易读易写的纯文本格式”编写文档，本文主要针对Hexo中Markdown常用的语法进行总结，更详细的内容请参考Hexo官方书写格式链接和Markdown书写格式链接 标题Markdown支持两种标题的语法，Setext和atx形式：Setext形式是用底线的形式，利用 = (最高阶标题)和 - (第二阶标题)。Atx形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。 最高阶标题第二阶标题H1标题H2标题H3标题H4标题H5标题H6标题区块引用区块引用则使用 email 形式的 ‘&gt;’ 角括号。 区块引用 嵌套引用 修辞和强调强调内容两侧分别加上星号或者底线。斜体粗体删除 表格 至少一个- 使用:来设置对其方式 第一列 第二列 第三列 内容 内容 内容 列表无序列表使用星号、加号或减号来做为列表。 一号 二号 三号 四号 五号 六号 有序列表 一号 二号 链接这是我的博客地址 分割线 图片图片的语法和链接很像，只需在链接的基础上前方加一个！注意图片大小的设置方式,关于其他设置可以参考七牛云 代码main.c12345int i = 0; i = 1; for (int i = 0; i &lt; 100; i++)&#123; printf(\"hello markdown!\\n\");&#125; 任务列表 选项一 选项二 选项三","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]}]