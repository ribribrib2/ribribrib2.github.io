[{"title":"Django(1)-Web框架本质探究","date":"2018-10-01T14:46:43.000Z","path":"2018/10/01/Django(1)-Web框架本质探究/","text":"Web框架本质&emsp;&emsp;对于所有的Web应用，本质上其实就是一个socket服务端，用户的浏览器其实就是一个socket客户端。对于真实开发中的python web程序来说，一般会分为两部分：服务器程序和应用程序。服务器程序负责对socket服务器进行封装，并在请求到来时，对请求的各种数据进行整理。应用程序则负责具体的逻辑处理。&emsp;&emsp;为了方便应用程序的开发,就会出现许多的Web框架,而所有的web框架都需要与服务器程序配合才能为用户服务，所以web框架和web服务器之间需要标准化。 一般Web框架架构&emsp;&emsp;大多数基于Python的web框架，如Django、tornado、flask、webpy都是在这个范围内进行增删裁剪的。例如Tornado用的是自己的异步非阻塞“WSGI”网关接口，Flask则只提供了最精简和基本的框架，Django则是直接使用了现成的WSGI，并实现了大部分功能，提供了大量的应用工具。 MTV设计模式 WSGI-uwsgi-uWSGI区别&emsp;&emsp;WSGI：全称是Web Server Gateway Interface，WSGI不是服务器、python模块、框架、API或者任何软件，只是一种网关接口，它是一个Web服务器（如nginx，uWSGI等服务器）与web应用（如用Django框架写的程序）通信的一种规范。&emsp;&emsp;uwsgi：一种传输协议，常用于在uWSGI服务器与其他网络服务器的数据通信。&emsp;&emsp;uWSGI：是一个web服务器，实现了WSGI协议、uwsgi协议、http协议等。工作流程: 首先客户端请求服务资源。 nginx作为直接对外的服务接口,接收到客户端发送过来的http请求,会解包、分析。 如果是静态文件请求就根据nginx配置的静态文件目录，返回请求的资源。 如果是动态的请求,nginx就通过配置文件,将请求传递给uWSGI。 uWSGI将接收到的包进行处理，转发给wsgi。 wsgi根据请求调用django工程的某个文件或函数，处理完后django将返回值交给wsgi。 wsgi将返回值进行打包，转发给uWSGI。 uWSGI接收后转发给nginx,nginx最终将返回值返回给客户端(如浏览器)。 &emsp;&emsp;第一级的nginx并不是必须的，uwsgi完全可以完成整个的和浏览器交互的流程，但是要考虑到某些情况： 安全问题：程序不能直接被浏览器访问到，而是通过nginx。nginx只开放某个接口，这样运维人员在nginx上加上安全性的限制，可以达到保护程序的作用。 负载均衡问题：一个uwsgi很可能不够用，有了nginx做代理，一个nginx可以代理多台uwsgi完成uwsgi的负载均衡。 静态文件问题：用django或是uwsgi这种东西来负责静态文件的处理是很浪费的行为，而且他们本身对文件的处理也不如nginx好，所以整个静态文件的处理都直接由nginx完成，静态文件的访问完全不去经过uwsgi以及其后面的东西。 通过对Django的启动研究socket的启动&emsp;&emsp;使用runserver是启动Django自带的WSGI服务器，常用于开发调试，分析Django的源码: 执行python manage.py runserver 127.0.0.1:8000后，会在\\Django1.11.6\\Lib\\site-packages\\django\\core\\management\\__init__.py中执行self.fetch_command(subcommand).run_from_argv(self.argv)。 调用fetch_command返回的runserver模块下的Command对象，其中Command对象是&lt;django.contrib.staticfiles.management.commands.runserver.Command object&gt;，继续调用Command对象的run_from_argv方法，然后执行self.handle(*args, **options)调用Command下的handle。 从Command.handle–&gt;Command.run–&gt;Command.inner_run，并在inner_run中执行： 123handler = self.get_handler(*args, **options)run(self.addr, int(self.port), handler, ipv6=self.use_ipv6, threading=threading, server_cls=self.server_cls) 在get_handler中会在通过wsgi.py返回WSGIHandler()，继承于class WSGIHandler(base.BaseHandler)，然后会执行run: 而run就是启动一个线程一直监听，其中wsgi_handler是WSGIHandler()，server_cls=WSGIServer是继承于class WSGIServer(simple_server.WSGIServer, object)，而simple_server来自于from wsgiref import simple_server，而wsgiref就是Python内置的一个WSGI服务器。 1234567891011121314151617def run(addr, port, wsgi_handler, ipv6=False, threading=False, server_cls=WSGIServer): server_address = (addr, port) if threading: httpd_cls = type(str(&apos;WSGIServer&apos;), (socketserver.ThreadingMixIn, server_cls), &#123;&#125;) else: httpd_cls = server_cls httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6) if threading: # ThreadingMixIn.daemon_threads indicates how threads will behave on an # abrupt shutdown; like quitting the server by the user or restarting # by the auto-reloader. True means the server will not wait for thread # termination before it quits. This will make auto-reloader faster # and will prevent the need to kill the server manually if a thread # isn&apos;t terminating correctly. httpd.daemon_threads = True httpd.set_app(wsgi_handler) httpd.serve_forever() wsgiref是用纯Python编写的WSGI服务器的参考实现。所谓“参考实现”是指该实现完全符合WSGI标准，但是不考虑任何运行效率，仅供开发和测试使用。 参考文章: 由django.setup()引发得对Django启动过程解读 Django 源码学习之搭建环境和django启动流程(一)","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]}]