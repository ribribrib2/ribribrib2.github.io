<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人的技术分享和生活点滴记录"><meta name="keywords" content="Rearib"><title>线程与进程 | Rearib的个人博客</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">线程与进程</h1><a id="logo" href="/.">Rearib的个人博客</a><p class="description">面朝大海,春暖花开</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">线程与进程</h1><div class="post-meta"><a href="/2018/10/26/线程与进程/#comments" class="comment-count"><i id="changyan_count_unit" data-xid="2018/10/26/线程与进程/"></i>留言,<i id="changyan_parti_unit" data-xid="2018/10/26/线程与进程/"></i>参与</a><p><span class="date">Oct 26, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>&emsp;&emsp;计算机所有的指令的操作都是有CPU来负责的，cpu是来负责运算的。<strong>OS(操作系统) 调度cpu的最小单位就是线程。</strong><br>&emsp;&emsp;进程：是以一个整体的形式暴露给操作系统管理，里面包含对各种资源的调用，内存的管理，网络接口的调用等等，是各种资源管理的集合<br>&emsp;&emsp;线程：是操作系统的最小的调度单位，是一串指令的集合。<br><a id="more"></a><br><img src="http://qiniu.rearib.top/1/20181026100045261.png" alt=""></p>
<h2 id="进程（Process）"><a href="#进程（Process）" class="headerlink" title="进程（Process）"></a>进程（Process）</h2><p>&emsp;&emsp;程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：<strong>程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。</strong><br>&emsp;&emsp;在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。这是这样的设计，大大提高了CPU的利用率。进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。</p>
<h2 id="线程-Thead"><a href="#线程-Thead" class="headerlink" title="线程(Thead)"></a>线程(Thead)</h2><p>&emsp;&emsp;线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，<strong>一个进程中可以并发多个线程，每条线程并行执行不同的任务。</strong></p>
<h2 id="有了进程为什么还要线程"><a href="#有了进程为什么还要线程" class="headerlink" title="有了进程为什么还要线程?"></a>有了进程为什么还要线程?</h2><p>&emsp;&emsp;进程有很多优点，它提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率。很多人就不理解了，既然进程这么优秀，为什么还要线程呢？其实，仔细观察就会发现进程还是有很多缺陷的，主要体现在两点上：</p>
<ul>
<li>进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。</li>
<li>进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。</li>
</ul>
<p>&emsp;&emsp;例如，我们在使用qq聊天， qq做为一个独立进程如果同一时间只能干一件事，那他如何实现在同一时刻：即能监听键盘输入、又能监听其它人给你发的消息、同时还能把别人发的消息显示在屏幕上呢？你会说，操作系统不是有分时么？但是分时是指在不同进程间的分时， 即操作系统处理一会你的qq任务，又切换到word文档任务上了，每个cpu时间片分给你的qq程序时，事实上，你的qq还是同一时间只能干一件事情。<br>&emsp;&emsp;再直白一点， 一个操作系统就像是一个工厂，工厂里面有很多个生产车间，不同的车间生产不同的产品，每个车间就相当于一个进程，且你的工厂又穷，供电不足，同一时间只能给一个车间供电，为了能让所有车间都能同时生产，你的工厂的电工只能给不同的车间分时供电，但是轮到你的qq车间时，发现只有一个干活的工人，结果生产效率极低，为了解决这个问题，就需要多加几个工人，让几个人工人并行工作，这每个工人，就是线程！</p>
<h2 id="进程和线程的区别："><a href="#进程和线程的区别：" class="headerlink" title="进程和线程的区别："></a>进程和线程的区别：</h2><ul>
<li>线程是共享内存空间的；进程的内存是独立的。</li>
<li>线程可以直接访问此进程中的数据部分；进程有他们独立拷贝自己父进程的数据部分，每个进程是独立的</li>
<li>同一进程的线程之间直接交流(直接交流涉及到数据共享，信息传递)；两个进程想通信，必须通过一个中间代理来实现。</li>
<li>创建一个新的线程很容易；创建新的进程需要对其父进程进行一次克隆。</li>
<li>一个线程可以控制和操作同一进程里的其他线程；但是进程只能操作子进程。</li>
<li>对主线程的修改，可能会影响到进程中其他线程的修改；对于一个父进程的修改不会影响其他子进程(只要不删除父进程即可)<h2 id="概念小结："><a href="#概念小结：" class="headerlink" title="概念小结："></a>概念小结：</h2></li>
<li>线程是操作系统最小的调度单位，是一串指令的集合。</li>
<li>进程要操作CPU，必须先创建一个线程。</li>
<li>进程本身是不可以执行的，操作cpu是通过线程实现的，因为它是一堆执行，而进程是不具备执行概念的。就像一个屋子，屋子就是进程，但是屋子里面的每一个人就是线程，屋子就是内存空间。</li>
<li>单核CPU只能同时干一件事，但是为什么给我们的感觉是在干了很多件事？因为CPU太快了，可以有N多次切换。</li>
<li>进程是通过PID来区分的，并不是通过进程名来区分的。进程里面的第一个线程就是主线程，父线程和子线程是相互独立的，只是父线程创建了子线程，父线程down了，子线程不会受到影响的。</li>
<li>主线程修改会影响其他线程，因为它们是共享数据的。</li>
<li>线程启动比进程块，但是运行速度没有可比性</li>
</ul>
<h1 id="threading-Thread模块"><a href="#threading-Thread模块" class="headerlink" title="threading.Thread模块"></a>threading.Thread模块</h1><h2 id="函数式多线程"><a href="#函数式多线程" class="headerlink" title="函数式多线程"></a>函数式多线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">def run(n):</span><br><span class="line">    print(&quot;run&quot;, n)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(n,&apos;end time:&apos;,time.time())</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">第一个参数是线程函数变量，第二个参数args是一个元组变量参数，如果只传递一个值，就只需要i,</span><br><span class="line">如果需要传递多个参数，那么还可以继续传递下去其他的参数，其中的逗号不能少，少了逗号位置参数指引就会出错。</span><br><span class="line">&quot;&quot;&quot; </span><br><span class="line">t1 = threading.Thread(target=run, args=(&quot;t1&quot;,))  # 生成线程对象</span><br><span class="line">t2 = threading.Thread(target=run, args=(&quot;t2&quot;,))</span><br><span class="line"></span><br><span class="line">print(&apos;start:&apos;,time.time())</span><br><span class="line">t1.start()  # start()函数启动一个线程</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>
<p><img src="/线程与进程/20181026101728106.png" alt=""></p>
<h2 id="继承式多线程"><a href="#继承式多线程" class="headerlink" title="继承式多线程"></a>继承式多线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">class MyThread(threading.Thread):   # 继承threading.Thread</span><br><span class="line">    &quot;&quot;&quot;继承式多线程&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        super(MyThread,self).__init__()  # 也可以写成这样threading.Thread.__init__(self)</span><br><span class="line">        self.n = n</span><br><span class="line"> </span><br><span class="line">    def run(self):     # 重写run方法</span><br><span class="line">        &quot;&quot;&quot;这个方法不能叫别的名字，只能叫run方法&quot;&quot;&quot;</span><br><span class="line">        print(&quot;run&quot;, self.n)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(self.n,&apos;end time:&apos;,time.time())</span><br><span class="line">        </span><br><span class="line">t1 = MyThread(&quot;t1&quot;)   # 实例化</span><br><span class="line">t2 = MyThread(&quot;t2&quot;)</span><br><span class="line"></span><br><span class="line">print(&apos;start:&apos;,time.time()) </span><br><span class="line">t1.start()   # 启动一个多线程</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>
<p><img src="/线程与进程/20181026102059476.png" alt=""></p>
<p>&amp;emsp；&amp;emsp；在上面两个示例代码中，都包含一个主线程和两个子线程，主线程在启动子线程后，子线程就是独立的，所以主线程不会等待子线程的sleep就直接运行下去。如果实现等待线程执行结果可以使用join。</p>
<h2 id="join函数"><a href="#join函数" class="headerlink" title="join函数"></a>join函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">class MyThread(threading.Thread):   # 继承threading.Thread</span><br><span class="line">    &quot;&quot;&quot;继承式多线程&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        super(MyThread,self).__init__()  # 也可以写成这样threading.Thread.__init__(self)</span><br><span class="line">        self.n = n</span><br><span class="line"> </span><br><span class="line">    def run(self):     # 重写run方法</span><br><span class="line">        &quot;&quot;&quot;这个方法不能叫别的名字，只能叫run方法&quot;&quot;&quot;</span><br><span class="line">        print(&quot;run&quot;, self.n)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(self.n,&apos;end time:&apos;,time.time())</span><br><span class="line">        </span><br><span class="line">t1 = MyThread(&quot;t1&quot;)   # 实例化</span><br><span class="line">t2 = MyThread(&quot;t2&quot;)</span><br><span class="line"></span><br><span class="line">print(&apos;start:&apos;,time.time()) </span><br><span class="line">t1.start()   # 启动一个多线程</span><br><span class="line">t1.join()</span><br><span class="line">t2.start()</span><br><span class="line">print(&apos;main end time:&apos;,time.time())</span><br></pre></td></tr></table></figure>
<p><img src="/线程与进程/20181026103100213.png" alt=""></p>
<ul>
<li>加了join之后，主线程依赖子线程执行完毕才往下走。</li>
</ul>
<p><strong>如果想要的是线程依然是并行效果，就需要更换join()的位置</strong><br><img src="/线程与进程/20181026102935930.png" alt=""></p>
<h2 id="计算多线程执行时间"><a href="#计算多线程执行时间" class="headerlink" title="计算多线程执行时间"></a>计算多线程执行时间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">def run(n):  # 这边的run方法的名字是自行定义的，跟继承式多线程不一样，那个是强制的</span><br><span class="line">    print(&quot;task:&quot;, n)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;task done&quot;, n)</span><br><span class="line"> </span><br><span class="line">start_time = time.time()  # 开始时间</span><br><span class="line">t_obj = []  # 存放子线程实例</span><br><span class="line">for i in range(10):  # 一次性启动10个线程</span><br><span class="line">    t = threading.Thread(target=run, args=(&quot;t-&#123;0&#125;&quot;.format(i),))</span><br><span class="line">    t.start()</span><br><span class="line">    t_obj.append(t)   # 为了不阻塞后面线程的启动，不在这里join，先放到一个列表中</span><br><span class="line"> </span><br><span class="line">for t in t_obj:  # 循环线程实例列表，等待所有线程执行完毕</span><br><span class="line">    t.join() </span><br><span class="line"> </span><br><span class="line">print(&quot;--------all thread has finished&quot;)</span><br><span class="line">print(&quot;cost:&quot;, time.time() - start_time)  # 计算总耗时</span><br></pre></td></tr></table></figure>
<p><img src="/线程与进程/20181026103423804.png" alt=""></p>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>&emsp;&emsp;只要主线程执行完毕，它不管子线程有没有执行完毕，就退出。现在就可以把所有的子线程变成守护线程。<strong>子线程变成守护线程之后，主程序就不会等子线程结束再退出了</strong>。说白了，设置一个主人，在设置几个仆人，这几个仆人都是为主人服务的。可以帮主人做很多事情，一个主人（主线程）可以有多个仆人（守护线程），服务的前提是，主线程必须存在，如果主线程不存在，则守护进程也没了。那守护进程是干嘛的呢？可以管理一些资源，打开一些文件，监听一些端口，监听一些资源，把一些垃圾资源回收，可以干很多事情，可以随便定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"></span><br><span class="line">def run(n):</span><br><span class="line">    print(&quot;task:&quot;, n)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;task done&quot;, n)</span><br><span class="line"> </span><br><span class="line">start_time = time.time()</span><br><span class="line">for i in range(5):</span><br><span class="line">    t = threading.Thread(target=run,args=(&quot;t-&#123;0&#125;&quot;.format(i),))</span><br><span class="line">    t.setDaemon(True)  # Daemon意思是守护进程，这边是把当前线程设置为守护线程</span><br><span class="line">    t.start()</span><br><span class="line"> </span><br><span class="line">print(&quot;--------all thread has finished&quot;)</span><br><span class="line">print(&quot;cost:&quot;, time.time() - start_time)</span><br></pre></td></tr></table></figure><br><img src="/线程与进程/20181026103850709.png" alt=""><br><strong>守护进程一定要在start之前设置，start之后就不能设置了，之后设置会报错</strong></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>&emsp;&emsp;比如写一个socket_server，每一个链接过来，socket_server就会给这个链接分配一个新的线程。如果我手动的把socket_server停掉。那这种情况你必须手动停掉服务，那它就要down了，这种情况下还要等线程结束吗？就不用等线程结束了，它自己就直接结束了。这样，是不是就可以把每个socket线程设置一个守护线程，主线程一旦down掉，就全部退出。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul>
<li>theading.current_thead()查看当前线程；</li>
<li>用theading.active_count()来统计当前活动的线程数</li>
<li>线程个数=子线程数+主线程数</li>
</ul>
<h1 id="GIL锁-全局解释器锁"><a href="#GIL锁-全局解释器锁" class="headerlink" title="GIL锁(全局解释器锁)"></a>GIL锁(全局解释器锁)</h1><p>&emsp;&emsp;计算机有4核，代表着同一时间，可以干4个任务。如果单核cpu的话，我启动10个线程，我看上去也是并发的，因为是执行了上下文的切换，让看上去是并发的。但是单核永远肯定时串行的，它肯定是串行的，cpu真正执行的时候，因为一会执行1，一会执行2.。。。。正常的线程就是这个样子的。但是，在python中，无论有多少核，永远都是假象。无论是4核，8核，还是16核…….不好意思，同一时间执行的线程只有一个(线程)，它就是这个样子的。这个是python的一个开发时候，设计的一个缺陷，所以说python中的线程是假线程。</p>
<h1 id="GIL存在的意义"><a href="#GIL存在的意义" class="headerlink" title="GIL存在的意义"></a><a href="https://www.cnblogs.com/gengcx/p/7500401.html" target="_blank" rel="noopener">GIL存在的意义</a></h1><p>&emsp;&emsp;在新处理器上运行的程序要想充分利用其性能，必须按照并发方式进行重写。大部分开发者听到“并发”通常会立刻想到多线程的程序。目前来说，多线程执行还是利用多核系统最常用的方式。尽管多线程编程大大好于“顺序”编程，不过即便是仔细的程序员也没法在代码中将并发性做到最好。编程语言在这方面应该做的更好，大部分应用广泛的现代编程语言都会支持多线程编程。<br>&emsp;&emsp;要想利用多核系统，Python必须支持多线程运行。作为解释型语言，Python的解释器必须做到既安全又高效。我们都知道多线程编程会遇到的问题。解释器要留意的是避免在不同的线程操作内部共享的数据。同时它还要保证在管理用户线程时保证总是有最大化的计算资源。<br>&emsp;&emsp;那么，不同线程同时访问时，数据的保护机制是怎样的呢？答案是解释器全局锁。从名字上看能告诉我们很多东西，很显然，这是一个加在解释器上的全局（从解释器的角度看）锁（从互斥或者类似角度看）。这种方式当然很安全，但是它有一层隐含的意思（Python初学者需要了解这个）：对于任何Python程序，不管有多少的处理器，任何时候都总是只有一个线程在执行。</p>
<h2 id="GIL锁关系图"><a href="#GIL锁关系图" class="headerlink" title="GIL锁关系图"></a>GIL锁关系图</h2><p>&emsp;&emsp;GIL(全局解释器锁)是加在python解释器里面的，效果如图：<br><img src="/线程与进程/20181026110513560.png" alt=""><br><strong>总结:</strong><br>&emsp;&emsp;需要明确的一点是<strong>GIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念</strong>。就好比C++是一套语言（语法）标准，但是可以用不同的编译器来编译成可执行代码。有名的编译器例如GCC，INTEL C++，Visual C++等。Python也一样，同样一段代码可以通过CPython，PyPy，Psyco等不同的Python执行环境来执行。像其中的JPython就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境。<strong>所以在很多人的概念里CPython就是Python，也就想当然的把GIL归结为Python语言的缺陷。所以这里要先明确一点：GIL并不是Python的特性，Python完全可以不依赖于GIL。</strong></p>
<ul>
<li>CPython：是用C语言实现Pyhon，是目前应用最广泛的解释器。</li>
</ul>
<h1 id="线程锁（互斥锁）"><a href="#线程锁（互斥锁）" class="headerlink" title="线程锁（互斥锁）"></a>线程锁（互斥锁）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">def run(n):</span><br><span class="line">    global num   # 把num变成全局变量</span><br><span class="line">    time.sleep(1)  # 注意了sleep的时候是不占有cpu的，这个时候cpu直接把这个线程挂起了，此时cpu去干别的事情去了</span><br><span class="line">    num += 1   # 所有的线程都做+1操作</span><br><span class="line"> </span><br><span class="line">num = 0   # 初始化num为0</span><br><span class="line">t_obj = list()</span><br><span class="line">for i in range(100):</span><br><span class="line">    t = threading.Thread(target=run, args=(&quot;t-&#123;0&#125;&quot;.format(i),))</span><br><span class="line">    t.start()</span><br><span class="line">    t_obj.append(t)</span><br><span class="line"> </span><br><span class="line">for t in t_obj:</span><br><span class="line">    t.join()</span><br><span class="line"> </span><br><span class="line">print(&quot;--------all thread has finished&quot;)</span><br><span class="line">print(&quot;num:&quot;, num)   # 输出最后的num值</span><br><span class="line"></span><br><span class="line">#执行结果</span><br><span class="line">--------all thead has finished</span><br><span class="line">(&apos;num:&apos;, 97)  #输出的结果</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其实这种情况只能在python2.x 中才会出现的，python3.x里面没有这种现象，下面我们就用一张图来解释一下这个原因。如图：<br><img src="/线程与进程/20181026114846189.png" alt=""><br>解释：</p>
<ul>
<li>到第5步的时候，可能这个时候python正好切换了一次GIL(据说python2.7中，每100条指令会切换一次GIL),执行的时间到了，被要求释放GIL,这个时候thead 1的count=0并没有得到执行，而是挂起状态，count=0这个上下文关系被存到寄存器中.</li>
<li>然后到第6步，这个时候thead 2开始执行，然后就变成了count = 1,返回给count，这个时候count=1.</li>
<li>然后再回到thead 1，这个时候由于上下文关系，thead 1拿到的寄存器中的count = 0，经过计算，得到count = 1，经过第13步的操作就覆盖了原来的count = 1的值，所以这个时候count依然是count = 1，所以这个数据并没有保护起来。</li>
</ul>
<h2 id="添加线程锁"><a href="#添加线程锁" class="headerlink" title="添加线程锁"></a>添加线程锁</h2><p>&emsp;&emsp;通过上面的图我们知道，结果依然是不准确的。所以我还要加一把锁，这个是用户级别的锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"></span><br><span class="line">def run(n):</span><br><span class="line">    lock.acquire()  # 添加线程锁</span><br><span class="line">    global num      # 把num变成全局变量</span><br><span class="line">    time.sleep(0.1) # 注意了sleep的时候是不占有cpu的，这个时候cpu直接把这个线程挂起了，此时cpu去干别的事情去了</span><br><span class="line">    num += 1        # 所有的线程都做+1操作</span><br><span class="line">    lock.release()  # 释放线程锁</span><br><span class="line"> </span><br><span class="line">num = 0   # 初始化num为0</span><br><span class="line">lock = threading.Lock()  # 生成线程锁实例</span><br><span class="line">t_obj = list()</span><br><span class="line">for i in range(10):</span><br><span class="line">    t = threading.Thread(target=run, args=(&quot;t-&#123;0&#125;&quot;.format(i),))</span><br><span class="line">    t.start()</span><br><span class="line">    t_obj.append(t)</span><br><span class="line"> </span><br><span class="line">for t in t_obj:</span><br><span class="line">    t.join()   # 为join是等子线程执行的结果，如果不加，主线程执行完，下面就获取不到子线程num的值了，共享数据num值就错误了</span><br><span class="line"></span><br><span class="line">print(&quot;--------all thread has finished&quot;)</span><br><span class="line">print(&quot;num:&quot;, num)   # 输出最后的num值</span><br></pre></td></tr></table></figure><br><img src="/线程与进程/20181026115312595.png" alt=""><br><strong>小结：</strong></p>
<ul>
<li>用theading.Lock()创建一个lock的实例。</li>
<li>在线程启动之前通过lock.acquire()加加锁，在线程结束之后通过lock.release()释放锁。</li>
<li>这层锁是用户开的锁，就是我们用户程序的锁。跟我们这个GIL没有关系，但是它把这个数据相当于copy了两份，所以在这里加锁，以确保同一时间只有一个线程，真真正正的修改这个数据，所以这里的锁跟GIL没有关系，你理解就是自己的锁。</li>
<li>加锁，说明此时我来去修改这个数据，其他人都不能动。然后修改完了，要把这把锁释放。这样的话就把程序编程串行了。</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>&emsp;&emsp;在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁，因为系统判断这部分资源都正在使用，所有这两个线程在无外力作用下将一直等待下去.（大锁内加小锁）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import threading,time </span><br><span class="line"></span><br><span class="line">mutexA=threading.Lock()</span><br><span class="line">mutexB=threading.Lock()</span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        self.func1()</span><br><span class="line">        self.func2()</span><br><span class="line"></span><br><span class="line">    def func1(self):</span><br><span class="line">        print(&apos;%s func1 start&apos;%self.name)</span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(&apos;%s func1 拿到A锁 &apos;%self.name)</span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(&apos;%s func1 拿到B锁 &apos;%self.name)</span><br><span class="line">        mutexB.release()</span><br><span class="line">        mutexA.release()</span><br><span class="line">        print(&apos;%s func1 end&apos;%self.name)</span><br><span class="line"></span><br><span class="line">    def func2(self):</span><br><span class="line">        print(&apos;%s func2 start&apos;%self.name)</span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(&apos;%s func2 拿到B锁 &apos;%self.name)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(&apos;%s func2 拿到A锁 &apos;%self.name)</span><br><span class="line">        mutexA.release()</span><br><span class="line">        mutexB.release()</span><br><span class="line">        print(&apos;%s func2 end&apos;%self.name)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    for i in range(5):</span><br><span class="line">        t=MyThread()</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><br><img src="/线程与进程/20181026044139986.png" alt=""><br>线程1拿到B锁，线程3拿到A锁，造成同时等待，而且线程2、4、5也会因为拿不到锁等待。</p>
<h2 id="递归锁（RLock）"><a href="#递归锁（RLock）" class="headerlink" title="递归锁（RLock）"></a>递归锁（RLock）</h2><p>&emsp;&emsp;这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import threading,time </span><br><span class="line"></span><br><span class="line">mutexA=mutexB=threading.RLock()</span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        self.func1()</span><br><span class="line">        self.func2()</span><br><span class="line"></span><br><span class="line">    def func1(self):</span><br><span class="line">        print(&apos;%s func1 start&apos;%self.name)</span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(&apos;%s func1 拿到A锁 &apos;%self.name)</span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(&apos;%s func1 拿到B锁 &apos;%self.name)</span><br><span class="line">        mutexB.release()</span><br><span class="line">        mutexA.release()</span><br><span class="line">        print(&apos;%s func1 end&apos;%self.name)</span><br><span class="line"></span><br><span class="line">    def func2(self):</span><br><span class="line">        print(&apos;%s func2 start&apos;%self.name)</span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(&apos;%s func2 拿到B锁 &apos;%self.name)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(&apos;%s func2 拿到A锁 &apos;%self.name)</span><br><span class="line">        mutexA.release()</span><br><span class="line">        mutexB.release()</span><br><span class="line">        print(&apos;%s func2 end&apos;%self.name)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    for i in range(5):</span><br><span class="line">        t=MyThread()</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><br><img src="/线程与进程/20181026045033501.png" alt=""><br><img src="/线程与进程/20181026045227839.png" alt=""><br>&emsp;&emsp;由于锁A，B是同一个递归锁，thread1拿到A,B锁，counter记录了acquire的次数2次，然后在func1执行完毕，就释放递归锁，在thread1释放完递归锁，执行完func1代码，接下来会有2种可能：1、thread1在次抢到递归锁，执行func2代码 2、其他的线程抢到递归锁，去执行func1的任务代码<br><strong>递归锁用于多重锁的情况，如果只是一层锁，就用不上递归锁</strong><br>递归锁原理其实很简单：就是每开一把门，在字典里面存一份数据，退出的时候去到door1或者door2里面找到这个钥匙退出，如图：<br><img src="/线程与进程/20181026050112225.png" alt=""></p>
<h2 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h2><p>&emsp;&emsp;之前讲的线程锁（互斥锁）同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去。</p>
<ul>
<li>信号量是一个变量，控制着对公共资源或者临界区的访问。信号量维护着一个计数器，指定可同时访问资源或者进入临界区的线程数。 </li>
<li>每次有一个线程获得信号量时，计数器-1。若计数器为0，其他线程就停止访问信号量，直到另一个线程释放信号量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">def run(n):</span><br><span class="line">    semaphore.acquire()   # 加信号量锁</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    print(&quot;run the thread: %s\n&quot; % n)</span><br><span class="line">    semaphore.release()   # 释放信号量锁</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    semaphore = threading.BoundedSemaphore(5)  # 最多允许5个线程同时运行(Bounded:绑定，Semaphore：信号量)</span><br><span class="line">    for i in range(20):</span><br><span class="line">        t = threading.Thread(target=run, args=(i,))</span><br><span class="line">        t.start()</span><br><span class="line">while threading.active_count() != 1:</span><br><span class="line">    pass</span><br><span class="line">else:</span><br><span class="line">    print(&apos;----all threads done---&apos;)</span><br></pre></td></tr></table></figure>
<p>上面程序的执行，会让人感觉是：分了4组，前5个同时完成，然后又5个同时进去。但是实际的效果是：这5个里面如果有3个完成，就会立刻再放3个进去。不会等5个都完成，每出来1个就放进去1个，出来几个放进去几个<br><strong>使用场景和总结</strong></p>
<ul>
<li>连接池，线程池，MySQL的有连接池，同一时间有多少个并发，就能连多少个连接。</li>
<li>我们为了保证我的socket_server，因为python不会默认现在你启动多少个线程，但是你启动的线程越多，就会把系统拉的越慢，就会把程序拉的越慢。这里就可以搞一个我同一时间放100线程个进来，就是用semaphore</li>
</ul>
<h2 id="event"><a href="#event" class="headerlink" title="event"></a>event</h2><p>&emsp;&emsp;事件处理的机制：全局定义了一个“Flag”，如果“Flag”值为 False，那么当程序执行 event.wait 方法时就会阻塞，如果“Flag”值为True，那么event.wait 方法时便不再阻塞。<br><strong>threading.Event 实现线程间通信,使用threading.Event可以使一个线程等待其他线程的通知</strong></p>
<blockquote>
<ul>
<li>event = threading.Event()   # 设置一个事件的全局变量</li>
<li>event.is_set()       # 判断是否已经设置标志位。</li>
<li>event.wait()         # 没有设置标志位的时候会阻塞，一遇到标志位就不会阻塞 #判断是否已经设置标志位。</li>
<li>event.set()          # 设置标志位 ，标志位设置了，代表着绿灯，直接通行。</li>
<li>event.clear()        # 清除标志位，标志位被清空，代表红灯，wait等待变绿灯。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">event = threading.Event()  # 生成线程事件实例</span><br><span class="line"> </span><br><span class="line">def lighter():</span><br><span class="line">    count = 0</span><br><span class="line">    event.set()   # 先设置标志位,代表绿灯</span><br><span class="line">    while True:</span><br><span class="line">        if count &gt; 5 and count &lt; 10:   # 改成红灯</span><br><span class="line">            event.clear()    # 清除标志位，变成红灯</span><br><span class="line">            print(&quot;red light is on ....&quot;)</span><br><span class="line">        elif count &gt; 10:</span><br><span class="line">            event.set()   # 创建标志位，变成绿灯</span><br><span class="line">            count = 0</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;green light is on ....&quot;)</span><br><span class="line"> </span><br><span class="line">        time.sleep(1)</span><br><span class="line">        count += 1</span><br><span class="line"> </span><br><span class="line">def car(name):</span><br><span class="line">    while True:</span><br><span class="line">        if event.is_set():   # 有标志位，代表是绿灯</span><br><span class="line">            print(&quot;&#123;0&#125; running ....&quot;.format(name))</span><br><span class="line">            time.sleep(1)</span><br><span class="line">        else:   # 如果不是绿灯就代表红灯</span><br><span class="line">            print(&quot;&#123;0&#125; sees red light ,waiting ....&quot;.format(name))</span><br><span class="line">            event.wait()   # 阻塞</span><br><span class="line">            print(&quot;green light is on , start going ...&quot;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">light = threading.Thread(target=lighter,)  # 启动代表红绿灯的线程</span><br><span class="line">light.start()</span><br><span class="line">car1 = threading.Thread(target=car, args=(&quot;car1&quot;,))  # 启动代表车的线程</span><br><span class="line">car1.start()</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/python/">python</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/09/10/使用vagrant搭建虚拟开发环境/" class="next">使用vagrant搭建虚拟开发环境</a></div><div id="comments"><div id="SOHUCS" sid="2018/10/26/线程与进程/"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概念"><span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程（Process）"><span class="toc-text">进程（Process）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程-Thead"><span class="toc-text">线程(Thead)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#有了进程为什么还要线程"><span class="toc-text">有了进程为什么还要线程?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程和线程的区别："><span class="toc-text">进程和线程的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#概念小结："><span class="toc-text">概念小结：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#threading-Thread模块"><span class="toc-text">threading.Thread模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数式多线程"><span class="toc-text">函数式多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承式多线程"><span class="toc-text">继承式多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#join函数"><span class="toc-text">join函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计算多线程执行时间"><span class="toc-text">计算多线程执行时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#守护进程"><span class="toc-text">守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景"><span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#补充"><span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GIL锁-全局解释器锁"><span class="toc-text">GIL锁(全局解释器锁)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GIL存在的意义"><span class="toc-text">GIL存在的意义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GIL锁关系图"><span class="toc-text">GIL锁关系图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程锁（互斥锁）"><span class="toc-text">线程锁（互斥锁）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#添加线程锁"><span class="toc-text">添加线程锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归锁（RLock）"><span class="toc-text">递归锁（RLock）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信号量（Semaphore）"><span class="toc-text">信号量（Semaphore）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#event"><span class="toc-text">event</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/26/线程与进程/">线程与进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/10/使用vagrant搭建虚拟开发环境/">使用vagrant搭建虚拟开发环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/03/django-扩展Django自带User模型，实现用户注册与登录/">django-扩展Django自带User模型，实现用户注册与登录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/03/Docker入门/">Docker入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/02/django-FBV&CBV/">django-FBV&CBV</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/django-编辑器Markdown的使用/">django-编辑器Markdown的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/django-编辑器Ueditor的使用/">django-编辑器Ueditor的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/在线教育平台Mxonline-xadmin的使用/">在线教育平台Mxonline-xadmin的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/在线教育平台Mxonline-django基本设置和model设计/">在线教育平台Mxonline-django基本设置和model设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/30/常用Markdown语法说明/">常用Markdown语法说明</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/django/" style="font-size: 15px;">django</a> <a href="/tags/文本编辑/" style="font-size: 15px;">文本编辑</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/django项目/" style="font-size: 15px;">django项目</a> <a href="/tags/Mxonline/" style="font-size: 15px;">Mxonline</a> <a href="/tags/xadmin/" style="font-size: 15px;">xadmin</a> <a href="/tags/项目部署/" style="font-size: 15px;">项目部署</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.tendcode.com/" title="Tendcode" target="_blank">Tendcode</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Rearib.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c7a5758117d8eb934731041ec33d337";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>window._config = { showScore: true };
(function(){ 
  var appid = 'cytNbO8fF'; 
  var conf = 'prod_f9b0b202ed5d2cb263a89f8a9bd08a94'; 
  var width = window.innerWidth || document.documentElement.clientWidth; 
  var nodes =document.getElementsByTagName("head")[0]||document.head||document.documentElement;
  if (/(Android|iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) && width < 750) {  
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
  }
  else { 
    var loadJs=function(d,a){
      var b=document.createElement("script");b.setAttribute("type","text/javascript");
      b.setAttribute("charset","UTF-8");
      b.setAttribute("src",d);
      if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}
      nodes.appendChild(b)
    };
    loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); 
  } 
  var loadCss = function(cssString){  
    var style=document.createElement("style");  
    style.setAttribute("type", "text/css");  
    if(style.styleSheet){// IE  
        style.styleSheet.cssText = cssString;  
    } else {// w3c  
        var cssText = document.createTextNode(cssString);  
        style.appendChild(cssText);  
    }
    nodes.appendChild(style);
  }
  window.onload=function(){loadCss('.module-hot-topic,.module-cmt-float-bar{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .cbox-prompt-w span.prompt-empty-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w .form-text-w span.text-null,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w a.comment-link-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w span.comment-text-w,#SOHUCS #SOHU_MAIN .module-cmt-footer .section-service-w div.service-wrap-w a:hover,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w span.wrap-name-w,#SOHUCS #SOHU_MAIN .module-cmt-list .action-click-gw span.click-disable-eg a em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li div.title-name-gw,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number .comment-number span.cy-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number span.comment-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active,#SOHUCS #SOHU_MAIN .module-cmt-list .msg-wrap-gw .wrap-action-gw .action-click-gw span a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .picture-box-gw div.box-action-gw a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-action-gw .action-click-gw span a:hover em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-user-gw span.user-name-gw a{color:#40759b!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-r,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-l,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-r{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-l{background:#FFF!important;top:-2px!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-function-w .uploading-wrapper-dw div.wrapper-image-dw,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-main,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w div.form-text-w,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-list .module-cmt-box .post-wrap-w div.post-wrap-main{border:1px solid #e6e6e6!important;border-radius:20px 20px 20px 20px;margin:0!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw{width:130px!important;height:34px!important;line-height:33px!important;font-size:17px!important;background:#5483b1!important;border-radius:20px!important;color:#FFF!important;-webkit-box-shadow:0 -1px 4px #5483b1 inset;box-shadow:0 -1px 10px #5483b1 inset}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw:before{content:"发表评论"}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a:hover .btn-fw{color:#40759b!important;background:#FFF!important}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li{background:none!important;border-bottom:1px solid #e6e6e6}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active{border:1px solid #e6e6e6;border-radius:10px 10px 0 0;border-bottom:none}#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li .title-name-gw div.title-name-gw-tag{background:#5483b1!important;border-radius:3px}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type div.cmt-list-border{background-color:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item{border:1px solid #e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo{text-align:center;line-height:40px;border-radius:50%!important;background:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo:before{content:"畅";font-size:22px;color:#FFF}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text,#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text i{color:#5483b1!important}#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w{background:#FFF!important}');};
})();</script><script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script></body></html>