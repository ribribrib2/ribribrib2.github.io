<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人的技术分享和生活点滴记录"><meta name="keywords" content="Rearib"><title>python-多进程 | Rearib的个人博客</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">python-多进程</h1><a id="logo" href="/.">Rearib的个人博客</a><p class="description">一生温暖纯良，不舍爱与自由</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">python-多进程</h1><div class="post-meta"><a href="/2018/09/15/Python-多进程/#comments" class="comment-count"></a><p><span class="date">Sep 15, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>&emsp;&emsp;进程之间是相互独立的，进程没有GIL锁，而且不存在锁的概念，进程之间的数据式不能共享的，而线程是可以的。<br><a id="more"></a></p>
<h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><h2 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h2><p>&emsp;&emsp;用muliprocessing这个包中的Process来定义多进程，跟定义多线程类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process   # 导入进程模块</span><br><span class="line">import time</span><br><span class="line"> </span><br><span class="line">def run(name):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;hello&quot;, name)</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    p_obj_list = list()    # 存放进程对象</span><br><span class="line">    for i in range(10):    # 启动10个进程</span><br><span class="line">        p = Process(target=run, args=(&quot;QQ&#123;0&#125;&quot;.format(i),))  # 产生一个进程实例</span><br><span class="line">        p.start()   # 启动进程</span><br><span class="line">        p_obj_list.append(p)</span><br><span class="line">  </span><br><span class="line">    for p in p_obj_list:</span><br><span class="line">        p.join()   # 等待进程结果</span><br></pre></td></tr></table></figure><br><img src="/python-多进程/20181026112021180.png" alt=""></p>
<h2 id="进程中加入线程"><a href="#进程中加入线程" class="headerlink" title="进程中加入线程"></a>进程中加入线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import time,threading</span><br><span class="line"> </span><br><span class="line">def thread_run(name):   # 定义线程执行的方法</span><br><span class="line">    print(&quot;&#123;0&#125;:&#123;1&#125;&quot;.format(name, threading.get_ident()))  # thread.get_ident ()返回当前线程的标识符，标识符是一个非零整数</span><br><span class="line"> </span><br><span class="line">def run(name):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;hello&quot;, name)</span><br><span class="line">    t = threading.Thread(target=thread_run, args=(name,))   # 嵌入线程</span><br><span class="line">    t.start()   # 执行线程</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    p_obj_list = list()</span><br><span class="line">    for i in range(10):</span><br><span class="line">        p = Process(target=run, args=(&quot;QQ&#123;0&#125;&quot;.format(i),))</span><br><span class="line">        p.start()</span><br><span class="line">        p_obj_list.append(p)</span><br><span class="line"> </span><br><span class="line">    for p in p_obj_list:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure>
<p><img src="/python-多进程/20181026112235923.png" alt=""></p>
<h2 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h2><p>每个子进程都是由一个父进程启动的，每个程序也是有一个父进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line"> </span><br><span class="line">def info(title):</span><br><span class="line">    print(title)</span><br><span class="line">    print(&apos;module name:&apos;, __name__)</span><br><span class="line">    print(&apos;parent process:&apos;, os.getppid())  # 获得父进程ID</span><br><span class="line">    print(&apos;process id:&apos;, os.getpid())  # 获得子进程ID</span><br><span class="line">    print(&apos;\n&apos;)</span><br><span class="line"> </span><br><span class="line">def f(name):</span><br><span class="line">    info(&apos;function f&apos;)</span><br><span class="line">    print(&apos;hello&apos;, name)</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    info(&apos;main process line&apos;)</span><br><span class="line">    p = Process(target=f, args=(&apos;QQ&apos;,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><br><img src="/python-多进程/20181026112550916.png" alt=""></p>
<h1 id="进程间数据交互与共享"><a href="#进程间数据交互与共享" class="headerlink" title="进程间数据交互与共享"></a>进程间数据交互与共享</h1><p>&emsp;&emsp;知道不同进程之间内存是不共享的，要想实现两个进程间的通信需要用到multiprocessing库中的queue（队列）模块，这个multiprocessing库中的queue模块跟单纯的queue库是不一样的。进程导入前者（这里的queue是专门为进程之间的通信设计的）不出错，导入后者（这里的queue主要是线程间数据交互）出错。</p>
<h3 id="线程访问queue"><a href="#线程访问queue" class="headerlink" title="线程访问queue"></a>线程访问queue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import queue,threading</span><br><span class="line"></span><br><span class="line">def f(q):</span><br><span class="line">    q.put([66, None, &apos;hello word&apos;])</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    q = queue.Queue()   # 把这个q传给了子线程</span><br><span class="line">    p = threading.Thread(target=f, args=(q,))   # 子线程访问父线程的q</span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>
<p><img src="http://qiniu.rearib.top/python-多进程/20181026112944166.png" alt=""></p>
<h3 id="进程访问queue"><a href="#进程访问queue" class="headerlink" title="进程访问queue"></a>进程访问queue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import queue</span><br><span class="line"></span><br><span class="line">def f(q):</span><br><span class="line">    q.put([66, None, &apos;hello word&apos;])</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    q = queue.Queue()   # 把这个q传给了子线程</span><br><span class="line">    p = Process(target=f, args=(q,))   # 子线程访问父线程的q</span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>
<p><img src="http://qiniu.rearib.top/python-多进程/20181026113140101.png" alt=""></p>
<h3 id="进程访问multiprocessing库中的Queue模块"><a href="#进程访问multiprocessing库中的Queue模块" class="headerlink" title="进程访问multiprocessing库中的Queue模块"></a>进程访问multiprocessing库中的Queue模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process,Queue</span><br><span class="line"> </span><br><span class="line">def f(q):</span><br><span class="line">    q.put([66, None, &apos;hello word&apos;])</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    q = Queue()   # 把这个q传给了子线程</span><br><span class="line">    p = Process(target=f, args=(q,))   # 子线程访问父线程的q</span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>
<p><img src="http://qiniu.rearib.top/python-多进程/20181026113249257.png" alt=""><br>&emsp;&emsp;父进程相当于克隆一个Q，把自己的Q克隆了一份交给子进程，子进程这个时候往Q里面放了一份数据，然后父进程又能实际的获取到。但是你克隆了一份是不是就和父进程没有关系了，为什么还能联系在一起呢？但是实际上：等于这两个Q里面的数据又把它序列化了，序列化到一个中间的地方，类似于翻译，然后反序列化给这个父进程这边来了，其实这两个Q就是通过pickle来序列化的，不是一个真正的Q。<br><strong>小结：两个线程之间可以修改一个数据，不加锁，可能就会出错。现在进程中的Queue，是实现了数据的传递，不是在修改同一份数据，只是实现一个进程的数据传给了另外一个进程。</strong></p>
<h2 id="Pipe-实现进程间的数据交互，manger实现数据共享"><a href="#Pipe-实现进程间的数据交互，manger实现数据共享" class="headerlink" title="Pipe()实现进程间的数据交互，manger实现数据共享"></a>Pipe()实现进程间的数据交互，manger实现数据共享</h2><p>&emsp;&emsp;上面的例子是通过进程中的Queue，来进行数据共享的，其实还有一种方式实现数据共享，那就是管道，pipe，以及数据共享manger。</p>
<h3 id="Pipe-函数"><a href="#Pipe-函数" class="headerlink" title="Pipe()函数"></a>Pipe()函数</h3><p>&emsp;&emsp;管道函数会返回由管道双方连接的一组连接对象，该管道默认是双向的(双向的)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, Pipe</span><br><span class="line"> </span><br><span class="line">def f(conn):</span><br><span class="line">    conn.send([66, None, &apos;hello,word&apos;])  # 发送消息给父进程</span><br><span class="line">    conn.send([66, None, &apos;hello,word2&apos;])  # 发送消息给父进程</span><br><span class="line">    conn.close()</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    parent_conn, child_conn = Pipe()  # 管道生成返回两个实例，是双向的，这边把第1个作为父连接，第2个作为子连接。也可以，两者角色调换一下</span><br><span class="line">    p = Process(target=f, args=(child_conn,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(parent_conn.recv())   # 接收子进程的消息</span><br><span class="line">    print(parent_conn.recv())   # 接收子进程的消息</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-多进程/20181027010733552.png" alt=""><br><strong>如果父进程在接收,但是子进程没有发,那么父进程就会一直等待下去</strong></p>
<h3 id="manger"><a href="#manger" class="headerlink" title="manger()"></a>manger()</h3><p>&emsp;&emsp;manger可以完成数据间的共享。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, Manager</span><br><span class="line">import os</span><br><span class="line"> </span><br><span class="line">def f(d, l):</span><br><span class="line">    d[os.getpid()] = os.getpid()</span><br><span class="line">    l.append(os.getpid())</span><br><span class="line">    print(l)</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    with Manager() as manager:</span><br><span class="line">        d = manager.dict()   # 声明一个字典，这个字典是用manger声明的，不是用dict()声明的</span><br><span class="line">        # manger.dict()是用专门的语法生产一个可在多进程之间进行传递和共享的一个字典</span><br><span class="line">        l = manager.list(range(5))  # 同样声明一个列表</span><br><span class="line">        p_list = []</span><br><span class="line">        for i in range(10):</span><br><span class="line">            p = Process(target=f, args=(d, l))</span><br><span class="line">            p.start()</span><br><span class="line">            p_list.append(p)</span><br><span class="line">        for res in p_list:</span><br><span class="line">            res.join()</span><br><span class="line">        print(d)</span><br><span class="line">        print(l)</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-多进程/20181027012451920.png" alt=""><br><strong>线程修改同一份数据的时候需要加锁，进程修改数据呢：不用加锁，因为这个manger已经帮你加锁了，它就默认不允许两个进程同时修改一份数据。两个进程没有办法同时修改一份数据，进程之间是独立的，它自己也要加锁，因为它把自己的东西同时copy好几份，跟刚刚的那个Queue一样，copy10个字典最终合成一个字典</strong></p>
<h1 id="进程锁和进程池"><a href="#进程锁和进程池" class="headerlink" title="进程锁和进程池"></a>进程锁和进程池</h1><h2 id="进程锁"><a href="#进程锁" class="headerlink" title="进程锁"></a>进程锁</h2><p>&emsp;&emsp;通过multiprocessing中的Lock模块来实现进程锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process,Lock   # 导入进程锁</span><br><span class="line"> </span><br><span class="line">def f(l, i):</span><br><span class="line">    l.acquire()    # 加锁</span><br><span class="line">    print(&quot;hello word&quot;, i)</span><br><span class="line">    l.release()   # 释放锁</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    lock = Lock()     # 定义锁</span><br><span class="line">    for num in range(10):</span><br><span class="line">        Process(target=f, args=(lock, num,)).start()  # 把锁传入进程中</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-多进程/20181027014001015.png" alt=""><br><strong>进程中不是相互独立的吗？为什么还要加锁：虽然每个进程都是独立运行的，但是问题来了，它们共享一块屏幕。这个锁存在的意义就是屏幕共享。如果进程1想着打印数据，而进程2想也想打印数据的情况，就有可能乱套了，然后通过这个锁来控制，去打印的时候，这个屏幕只有我独占，导致屏幕不会乱。</strong></p>
<h2 id="进程池apply和apply-saync"><a href="#进程池apply和apply-saync" class="headerlink" title="进程池apply和apply_saync"></a>进程池apply和apply_saync</h2><h3 id="appley"><a href="#appley" class="headerlink" title="appley"></a>appley</h3><p>&emsp;&emsp;同步执行，也就是<strong>串行执行</strong>的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool  # 导入进程池模块pool</span><br><span class="line">import time,os</span><br><span class="line"> </span><br><span class="line">def foo(i):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;in process&quot;, os.getpid())  # 打印进程号</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    pool = Pool(processes=5)   # 设置进程池个数为5，也可以写成pool = Pool(5)，允许进程池同时放入5个进程，并且这5个进程交给cpu去运行</span><br><span class="line">    for i in range(10):</span><br><span class="line">        pool.apply(func=foo, args=(i,))   # 同步执行挂起进程</span><br><span class="line">    print(&apos;end&apos;)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  # 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</span><br></pre></td></tr></table></figure><br><strong>一个一个打印</strong><br><img src="http://qiniu.rearib.top/python-多进程/20181027015536404.png" alt=""></p>
<h3 id="apply-saync"><a href="#apply-saync" class="headerlink" title="apply_saync"></a>apply_saync</h3><p>&emsp;&emsp;异步执行，也就是<strong>并行执行</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool  # 导入进程池模块pool</span><br><span class="line">import time,os</span><br><span class="line"> </span><br><span class="line">def foo(i):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;in process&quot;, os.getpid())  # 打印进程号</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    pool = Pool(processes=5)   # 设置进程池个数为5，也可以写成pool = Pool(5)，允许进程池同时放入5个进程，并且这5个进程交给cpu去运行</span><br><span class="line">    for i in range(10):</span><br><span class="line">        pool.apply_async(func=foo, args=(i,))   # 采用异步方式执行foo函数</span><br><span class="line">    print(&apos;end&apos;)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  # 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-多进程/20181027015657931.png" alt=""></p>
<h3 id="异步下回调函数"><a href="#异步下回调函数" class="headerlink" title="异步下回调函数"></a>异步下回调函数</h3><p>&emsp;&emsp;程序执行完毕之后，再回调过来执行这个Bar函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process,Pool</span><br><span class="line">import time,os</span><br><span class="line"> </span><br><span class="line">def foo(i):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;in process&quot;, os.getpid())  # 打印子进程的进程号</span><br><span class="line">    return i</span><br><span class="line"> </span><br><span class="line">def bar(arg):</span><br><span class="line">    print(&apos;--&gt;exec done:&apos;, arg, os.getpid())   # 打印进程号</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    pool = Pool(processes=2)</span><br><span class="line">    print(&quot;主进程&quot;, os.getpid())   # 主进程的进程号</span><br><span class="line">    for i in range(3):</span><br><span class="line">        pool.apply_async(func=foo, args=(i,), callback=bar)   # 执行回调函数callback=Bar,在主进程中执行</span><br><span class="line">    print(&apos;end&apos;)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  # 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</span><br></pre></td></tr></table></figure><br><strong>五个五个打印</strong><br><img src="http://qiniu.rearib.top/python-多进程/20181027015941615.png" alt=""><br><strong>回调函数在主进程执行,传入的参数来自子进程</strong></p>
<ul>
<li>回调函数说明fun=Foo干不完就不执行bar函数，等Foo执行完就去执行Bar</li>
<li>这个回调函数是主进程去调用的，而不是每个子进程去调用的。</li>
<li>回调函数的用处：<blockquote>
<p>比如说你从各个机器上备份完毕，在回调函数中自动写一个脚本，说备份完毕</p>
</blockquote>
</li>
<li>回调函数是主进程调用的原因？<blockquote>
<p>如果是子进程去调用这个回调函数，有多少个子进程就有多少个连接，如果是主进程的话，只需要一次长连接就可以了，这个效率就高了</p>
</blockquote>
</li>
</ul>
</div><div class="tags"><a href="/tags/Python/">Python</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/09/17/Python-协程/" class="pre">python-协程</a><a href="/2018/09/08/Python-线程与进程/" class="next">python-线程与进程</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#多进程"><span class="toc-text">多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程的定义"><span class="toc-text">进程的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程中加入线程"><span class="toc-text">进程中加入线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#父子进程"><span class="toc-text">父子进程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程间数据交互与共享"><span class="toc-text">进程间数据交互与共享</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程访问queue"><span class="toc-text">线程访问queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程访问queue"><span class="toc-text">进程访问queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程访问multiprocessing库中的Queue模块"><span class="toc-text">进程访问multiprocessing库中的Queue模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipe-实现进程间的数据交互，manger实现数据共享"><span class="toc-text">Pipe()实现进程间的数据交互，manger实现数据共享</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pipe-函数"><span class="toc-text">Pipe()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#manger"><span class="toc-text">manger()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程锁和进程池"><span class="toc-text">进程锁和进程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程锁"><span class="toc-text">进程锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程池apply和apply-saync"><span class="toc-text">进程池apply和apply_saync</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#appley"><span class="toc-text">appley</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#apply-saync"><span class="toc-text">apply_saync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步下回调函数"><span class="toc-text">异步下回调函数</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/10/Vagrant-使用vagrant搭建虚拟开发环境/">使用vagrant搭建虚拟开发环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/05/Django-缓存/">Django-缓存</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/05/Django-对cookie、session、token、jwt的理解/">Django-对cookie、session、token、jwt的理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/04/Django-中间件MiddleWare/">Django-中间件MiddleWare</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/02/Django-model模型知识点总结/">Django-model模型知识点总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/Django-Web框架本质探究/">Django-Web框架本质探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/28/Python-socket编程/">python-socket编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/21/Python-队列与生产者消费者模式/">python-队列与生产者消费者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/21/Python-RabbitMQ 安装、基本示例、轮询机制/">python-RabbitMQ 安装、基本示例、轮询机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/18/Python-事件驱动和IO介绍/">python-事件驱动和IO介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/文本编辑/" style="font-size: 15px;">文本编辑</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/Tool/" style="font-size: 15px;">Tool</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/项目部署/" style="font-size: 15px;">项目部署</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.tendcode.com/" title="Tendcode" target="_blank">Tendcode</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Rearib.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c7a5758117d8eb934731041ec33d337";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>