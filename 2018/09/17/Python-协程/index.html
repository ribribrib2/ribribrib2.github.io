<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人的技术分享和生活点滴记录"><meta name="keywords" content="Rearib"><title>python-协程 | Rearib的个人博客</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">python-协程</h1><a id="logo" href="/.">Rearib的个人博客</a><p class="description">一生温暖纯良，不舍爱与自由</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">python-协程</h1><div class="post-meta"><a href="/2018/09/17/Python-协程/#comments" class="comment-count"></a><p><span class="date">Sep 17, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>&emsp;&emsp;协程，又称微线程。英文名Coroutine。一句话说明什么是协程：协程是一种用户态的轻量级线程。<br>&emsp;&emsp;协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：<br>&emsp;&emsp;协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。<br><a id="more"></a></p>
<h2 id="协程的好处："><a href="#协程的好处：" class="headerlink" title="协程的好处："></a>协程的好处：</h2><ul>
<li>无需线程上下文切换的开销</li>
<li>无需原子操作锁定及同步的开销(协程是单线程,串行)</li>
<li>“原子操作(atomic operation)是不需要synchronized”，所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序是不可以被打乱，或者切割掉只执行部分。视作整体是原子性的核心。</li>
<li>方便切换控制流，简化编程模型</li>
<li>高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</li>
</ul>
<h2 id="协程的缺点："><a href="#协程的缺点：" class="headerlink" title="协程的缺点："></a>协程的缺点：</h2><ul>
<li>无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。</li>
<li><p>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序。</p>
<h2 id="yield实现协程"><a href="#yield实现协程" class="headerlink" title="yield实现协程"></a>yield实现协程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def consumer(name):</span><br><span class="line">    print(&quot;---&gt;starting eating baozi...&quot;)</span><br><span class="line">    while True:</span><br><span class="line">        new_baozi = yield   # yield设置生成器</span><br><span class="line">        print(&quot;[&#123;0&#125;] is eating baozi &#123;1&#125;&quot;.format(name, new_baozi))</span><br><span class="line"> </span><br><span class="line">def producer():</span><br><span class="line">    r = con.__next__()  # 调用生成器开始执行</span><br><span class="line">    r = con2.__next__()</span><br><span class="line">    n = 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        print(&quot;producer is making baozi &#123;0&#125;&quot;.format(n))</span><br><span class="line">        con.send(n)  # 唤醒生成器，并且向生成器传值</span><br><span class="line">        con2.send(n)</span><br><span class="line">        n += 1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    con = consumer(&quot;c1&quot;)    # 创建一个生成器c1,但是不会开始执行</span><br><span class="line">    con2 = consumer(&quot;c2&quot;)   # 创建一个生产器C2,但是不会开始执行</span><br><span class="line">    p = producer()</span><br></pre></td></tr></table></figure>
<p><img src="http://qiniu.rearib.top/python-协程/20181029094850452.png" alt=""></p>
</li>
<li><p><strong>send有两个作用？</strong><br>1.唤醒生产器<br>2.给yield传一个值，就是yield接收到的这个值。这个说明yield在被唤醒的时候可以接收数据。</p>
</li>
<li><strong>怎么实现我们的单线程实现并发的效果呢？</strong><br>&emsp;&emsp;<font color="red">遇到IO操作就切换</font>，IO比较耗时，协程之所以能处理大并发，就是IO操作会挤掉大量的时间。<font color="red">没有IO操作的话，整个程序只有cpu在运算了</font>，因为cpu很快，所以你感觉是在并发执行的。</li>
<li><strong>IO操作完成了，程序什么时候切回去</strong>？<br>&emsp;&emsp;IO操作一旦完成，我们就自动切回去。</li>
<li><strong>IO是什么?</strong><br>&emsp;&emsp;Python中的io模块是用来处理各种类型的I/O操作流。主要有三种类型的I/O类型：文本I/O(Text I/O)，二进制I/O(Binary I/O)和原始I/O(Raw I/O)。它们都是通用类别，每一种都有不同的后备存储。属于这些类别中的任何一个的具体对象称为文件对象，其他常用的术语为流或者类文件对象。<br>&emsp;&emsp;除了它的类别，每一种具体的流对象也具有各种功能：它仅仅允许读，或者仅仅允许写，或者既能读又能写。它也允许任意随机访问（向前或者向后寻找任何位置），或者仅仅顺序访问（例如在套接字或管道中）。<br>&emsp;&emsp;所有的流对于提供给它们的数据的数据类型都很严格。例如，如果用一个二进制流的write（）方法写一个字符类型的数据，那么将会触发一个TypeError错误。用文本流的write()方法来写字节对象数据也是一样的，会触发该错误。<h2 id="手动实现切换IO"><a href="#手动实现切换IO" class="headerlink" title="手动实现切换IO"></a>手动实现切换IO</h2>&emsp;&emsp;Greenlet是python的一个C扩展，来源于Stackless python，旨在提供可自行调度的‘微线程’， 即协程。它可以使你在任意函数之间随意切换，而不需把这个函数先声明为generator<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from greenlet import greenlet</span><br><span class="line"> </span><br><span class="line">def test1():</span><br><span class="line">    print(12)</span><br><span class="line">    gr2.switch()  # 切换到test2</span><br><span class="line">    print(34)</span><br><span class="line">    gr2.switch()   # 切换到test2</span><br><span class="line"> </span><br><span class="line">def test2():</span><br><span class="line">    print(56)</span><br><span class="line">    gr1.switch()   # 切换到test1</span><br><span class="line">    print(78)</span><br><span class="line"> </span><br><span class="line">gr1 = greenlet(test1)  # 启动一个协程</span><br><span class="line">gr2 = greenlet(test2)</span><br><span class="line">gr1.switch()   # 切换到test1，这个switch不写的话，会无法输出打印</span><br></pre></td></tr></table></figure>
<img src="http://qiniu.rearib.top/python-协程/20181029101816499.png" alt=""><br><strong>小结：</strong></li>
<li>cpu只认识线程，而不认识协程，协程是用户自己控制的，cpu根本都不知道它们的存在。</li>
<li>线程的上下文切换保存在cpu的寄存器中，但是协程拥有自己的寄存上下文和栈。</li>
<li>协程是串行的，无需锁。</li>
<li>虽然greenlet确实用着比generator（生成器）还简单了，但好像还没有解决一个问题，就是遇到IO操作，自动切换，对不对？<h2 id="协程遇IO操作自动切换"><a href="#协程遇IO操作自动切换" class="headerlink" title="协程遇IO操作自动切换"></a>协程遇IO操作自动切换</h2>&emsp;&emsp;接下来就说说如何遇到IO就自动切换切换，Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import gevent</span><br><span class="line"> </span><br><span class="line">def foo():</span><br><span class="line">    print(&quot;Running in foo&quot;)</span><br><span class="line">    gevent.sleep(3)  # 模仿io操作，一遇到io操作就切换</span><br><span class="line">    print(&quot;Explicit context switch to foo again&quot;)</span><br><span class="line"> </span><br><span class="line">def bar():</span><br><span class="line">    print(&quot;Explicit context to bar&quot;)</span><br><span class="line">    gevent.sleep(1)</span><br><span class="line">    print(&quot;Implicit context switch back to bar&quot;)</span><br><span class="line"> </span><br><span class="line">def fun3():</span><br><span class="line">    print(&quot;running fun3&quot;)</span><br><span class="line">    gevent.sleep(0)   # 虽然是0秒，但是会触发一次切换</span><br><span class="line">    print(&quot;running fun3 again&quot;)</span><br><span class="line"> </span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(foo),  # 生成协程</span><br><span class="line">    gevent.spawn(bar),</span><br><span class="line">    gevent.spawn(fun3)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<img src="http://qiniu.rearib.top/python-协程/20181029103346052.png" alt=""><br>&emsp;&emsp;当foo遇到sleep(3)的时候，切自动切换到bar函数，执行遇到sleep(1)的时候自动切换到fun3函数，遇到sleep(0)又自动切换到foo。这个时候sleep(3)还没有执行完毕，又切换到bar的sleep(1)这边，发现又没有执行完毕，就有执行fun3这边，发现sleep(0)执行完毕，则继续执行，然后又切换到foo,发现sleep(3)又没有执行完毕，就切换到bar的sleep(1)这边，发现执行完了，有切回到foo这边，执行完毕。<br>&emsp;&emsp;<strong>比如说你现在有50处IO，然后总共加起来串行的的话，要花100秒，但是50处IO最长的那个IO只花了5秒钟，那代表中你的这个程序就是协程最多5秒就执行完毕了。</strong></li>
</ul>
<p><strong>符合下面四个条件才能称之为协程：</strong></p>
<ul>
<li>必须在只有一个单线程里实现并发</li>
<li>修改共享数据不需加锁</li>
<li>用户程序里自己保存多个控制流的上下文栈</li>
<li>一个协程遇到IO操作自动切换到其它协程</li>
</ul>
<h2 id="协程（gevent）并发爬网页"><a href="#协程（gevent）并发爬网页" class="headerlink" title="协程（gevent）并发爬网页"></a>协程（gevent）并发爬网页</h2><p>&emsp;&emsp;上面例子gevent遇到io自动切换，现在就来实际演示协程爬虫的例子<br><strong>正常（串行）爬网页</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line">import time</span><br><span class="line"> </span><br><span class="line">def run(url):</span><br><span class="line">    print(&quot;GET:&#123;0&#125;&quot;.format(url))</span><br><span class="line">    resp = request.urlopen(url)    # request.urlopen()函数 用来打开网页</span><br><span class="line">    data = resp.read()    # 读取爬到的数据</span><br><span class="line">    with open(&quot;url.html&quot;, &quot;wb&quot;) as f:</span><br><span class="line">        f.write(data)</span><br><span class="line">    print(&apos;&#123;0&#125; bytes received from &#123;1&#125;&apos;.format(len(data), url))</span><br><span class="line"> </span><br><span class="line">urls = [</span><br><span class="line">    &apos;http://www.163.com/&apos;,</span><br><span class="line">    &apos;https://www.yahoo.com/&apos;,</span><br><span class="line">    &apos;https://github.com/&apos;</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">time_start = time.time()    # 开始时间</span><br><span class="line">for url in urls:</span><br><span class="line">    run(url)</span><br><span class="line">print(&quot;同步cost&quot;, time.time() - time_start)  # 程序执行消耗的时间</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-协程/20181029020845792.png" alt=""></p>
<p><strong>协程(gevent)爬虫(gevent并发执行)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line">import time,gevent</span><br><span class="line"> </span><br><span class="line">def run(url):</span><br><span class="line">    print(&quot;GET:&#123;0&#125;&quot;.format(url))</span><br><span class="line">    resp = request.urlopen(url)    # request.urlopen()函数 用来打开网页</span><br><span class="line">    data = resp.read()    # 读取爬到的数据</span><br><span class="line">    with open(&quot;url.html&quot;, &quot;wb&quot;) as f:</span><br><span class="line">        f.write(data)</span><br><span class="line">    print(&apos;&#123;0&#125; bytes received from &#123;1&#125;&apos;.format(len(data), url))</span><br><span class="line"> </span><br><span class="line">urls = [</span><br><span class="line">    &apos;http://www.163.com/&apos;,</span><br><span class="line">    &apos;https://www.yahoo.com/&apos;,</span><br><span class="line">    &apos;https://github.com/&apos;</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">time_start = time.time()    # 开始时间</span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(run,&apos;http://www.163.com/&apos;),  # 生成协程</span><br><span class="line">    gevent.spawn(run,&apos;https://www.yahoo.com/&apos;),</span><br><span class="line">    gevent.spawn(run,&apos;https://github.com/&apos;)</span><br><span class="line">])</span><br><span class="line">print(&quot;异步cost&quot;, time.time() - time_start)  # 程序执行消耗的时间</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-协程/20181029023531205.png" alt=""><br><strong>对比1、2爬网页的例子，发现执行耗费时间上并没有得到明显提升，并没有并发爬网页的神奇快感，其实主要是因为gevent现在检测不到urllib的IO操作。它都不知道urllib进行了IO操作，感受不到阻塞，它都不会进行切换，所以它就串行了。</strong></p>
<p><strong>打个补丁，告诉gevent,urllib正在进行IO操作</strong><br>通过导入monkey模块，来打这个补丁，原代码不变，就添加一行monkey.patch_all()即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line">import gevent,time</span><br><span class="line">from gevent import monkey  # 导入monkey模块</span><br><span class="line"> </span><br><span class="line">monkey.patch_all()  # 把当前程序的所有的IO操作给作上标记</span><br><span class="line"> </span><br><span class="line">def run(url):</span><br><span class="line">    print(&quot;GET:&#123;0&#125;&quot;.format(url))</span><br><span class="line">    resp = request.urlopen(url)    # request.urlopen()函数 用来打开网页</span><br><span class="line">    data = resp.read()    # 读取爬到的数据</span><br><span class="line">    with open(&quot;url.html&quot;, &quot;wb&quot;) as f:</span><br><span class="line">        f.write(data)</span><br><span class="line">    print(&apos;&#123;0&#125; bytes received from &#123;1&#125;&apos;.format(len(data), url))</span><br><span class="line"> </span><br><span class="line">urls = [</span><br><span class="line">    &apos;http://www.163.com/&apos;,</span><br><span class="line">    &apos;https://www.yahoo.com/&apos;,</span><br><span class="line">    &apos;https://github.com/&apos;</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">time_start = time.time()    # 开始时间</span><br><span class="line">gevent.joinall([                     # 用gevent启动协程</span><br><span class="line">    gevent.spawn(run, &apos;http://www.163.com/&apos;),  # 第二个值是传入参数，之前我们没有讲，因为前面没有传参</span><br><span class="line">    gevent.spawn(run, &apos;https://www.yahoo.com/&apos;),</span><br><span class="line">    gevent.spawn(run, &apos;https://github.com/&apos;),</span><br><span class="line">])</span><br><span class="line">print(&quot;异步cost&quot;, time.time() - time_start)  # 程序执行消耗的时间</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-协程/20181029023811804.png" alt=""><br><strong><font color="red">时间会受到网络状态的影响</font></strong><br>&emsp;&emsp;通过打补丁来检测urllib，它就把urllib里面所有涉及到的有可能进行IO操作的地方直接花在前面加一个标记，这个标记就相当于gevent.sleep()，所以把urllib变成一个一有阻塞，它就切换了</p>
<h2 id="gevent实现单线程下的多socket并发"><a href="#gevent实现单线程下的多socket并发" class="headerlink" title="gevent实现单线程下的多socket并发"></a>gevent实现单线程下的多socket并发</h2><h3 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import sys,gevent,socket,time</span><br><span class="line">from gevent import socket,monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line">   </span><br><span class="line">def server(port):</span><br><span class="line">    s = socket.socket()</span><br><span class="line">    s.bind((&apos;0.0.0.0&apos;, port))</span><br><span class="line">    s.listen(500)</span><br><span class="line">    while True:</span><br><span class="line">        cli, addr = s.accept()</span><br><span class="line">        gevent.spawn(handle_request, cli)   #协程</span><br><span class="line">  </span><br><span class="line">def handle_request(conn):</span><br><span class="line">    try:</span><br><span class="line">        while True:</span><br><span class="line">            data = conn.recv(1024)</span><br><span class="line">            print(&quot;recv:&quot;, data)</span><br><span class="line">            conn.send(data)</span><br><span class="line">            if not data:</span><br><span class="line">                conn.shutdown(socket.SHUT_WR)</span><br><span class="line">    except Exception as  ex:</span><br><span class="line">        print(ex)</span><br><span class="line">    finally:</span><br><span class="line">        conn.close()</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    server(8888)</span><br></pre></td></tr></table></figure>
<h3 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">   </span><br><span class="line">HOST = &apos;localhost&apos;    # The remote host</span><br><span class="line">PORT = 8888           # The same port as used by the server</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((HOST, PORT))</span><br><span class="line">while True:</span><br><span class="line">    msg = bytes(input(&quot;&gt;&gt;:&quot;),encoding=&quot;utf8&quot;)</span><br><span class="line">    s.sendall(msg)</span><br><span class="line">    data = s.recv(1024)</span><br><span class="line">    print(&apos;Received&apos;, repr(data))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/Python/">Python</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/09/18/Python-事件驱动和IO介绍/" class="pre">python-事件驱动和IO介绍</a><a href="/2018/09/15/Python-多进程/" class="next">python-多进程</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#协程的好处："><span class="toc-text">协程的好处：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协程的缺点："><span class="toc-text">协程的缺点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yield实现协程"><span class="toc-text">yield实现协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#手动实现切换IO"><span class="toc-text">手动实现切换IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协程遇IO操作自动切换"><span class="toc-text">协程遇IO操作自动切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协程（gevent）并发爬网页"><span class="toc-text">协程（gevent）并发爬网页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gevent实现单线程下的多socket并发"><span class="toc-text">gevent实现单线程下的多socket并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#server端"><span class="toc-text">server端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#client端"><span class="toc-text">client端</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/07/Python-函数/">python-函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/05/Django-对cookie、session、token、jwt的理解/">Django-对cookie、session、token、jwt的理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/04/Django-中间件MiddleWare/">Django-中间件MiddleWare</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/02/Django-model模型知识点总结/">Django-model模型知识点总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/Django-Web框架本质探究/">Django-Web框架本质探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/21/Python-队列与生产者消费者模式/">python-队列与生产者消费者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/21/Python-RabbitMQ 安装、基本示例、轮询机制/">python-RabbitMQ 安装、基本示例、轮询机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/18/Python-事件驱动和IO介绍/">python-事件驱动和IO介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/17/Python-协程/">python-协程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/15/Python-多进程/">python-多进程</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/文本编辑/" style="font-size: 15px;">文本编辑</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/Tool/" style="font-size: 15px;">Tool</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.tendcode.com/" title="Tendcode" target="_blank">Tendcode</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Rearib.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c7a5758117d8eb934731041ec33d337";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>