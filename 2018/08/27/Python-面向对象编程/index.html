<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人的技术分享和生活点滴记录"><meta name="keywords" content="Rearib"><title>Python-面向对象编程 | Rearib的个人博客</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Python-面向对象编程</h1><a id="logo" href="/.">Rearib的个人博客</a><p class="description">一生温暖纯良，不舍爱与自由</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Python-面向对象编程</h1><div class="post-meta"><a href="/2018/08/27/Python-面向对象编程/#comments" class="comment-count"></a><p><span class="date">Aug 27, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="变量和方法"><a href="#变量和方法" class="headerlink" title="变量和方法"></a>变量和方法</h3><ul>
<li>类的变量存在类的内存中, 实例变量存在实例内存中</li>
<li>对于变量,先找实例本身是否有,如果找不到就去类中找</li>
<li>静态属性就是变量, 动态属性就是方法</li>
<li>实例变量作用域是实例本身</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>类的实例化是以类为模板在内存中开辟空间存数据, 赋予变量名</p>
<p><img src="http://qiniu.rearib.top/FuQ3v-ubBtP6maXxQegXDPx71ziE" alt=""></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是一种创建新类的方式，在python中，新建的类可以继承一个或多个父类，父类又可称为基类或超类，新建的类称为派生类或子类</p>
<ul>
<li><p>多继承的查找方式</p>
</li>
<li><p><img src="http://qiniu.rearib.top/FifhvwxpCCdwGjNJI0You12g8rvN" alt=""></p>
</li>
</ul>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul>
<li>类的继承: 子类中重新定义某个方法会覆盖父类的同名方法, 如果要同时实现父类的功能, 就要使用super</li>
<li>super是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用等种种问题。</li>
<li><a href="https://zhuanlan.zhihu.com/p/23625909" target="_blank" rel="noopener">Python: 你不知道的 super</a></li>
<li><a href="https://blog.csdn.net/qq_14898613/article/details/53792270" target="_blank" rel="noopener">Python’s super() considered super!</a></li>
</ul>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p><img src="http://qiniu.rearib.top/FnQ_DDNvyepThkcuPsgUezZ8C0gM" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 类中所有双下划线开头的名称如__x都会在类定义时自动变形成：_类名__x的形式</span><br><span class="line">class A():</span><br><span class="line">    __N = 0</span><br><span class="line">    _M = 1   # 可以在外部调用, 只是给程序员提示</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__N = 10  # _A__N</span><br><span class="line"></span><br><span class="line">    def read(self):</span><br><span class="line">        print(self.__N)</span><br><span class="line"></span><br><span class="line">    def __write(self): # _A__write</span><br><span class="line">        self.__N = 20</span><br><span class="line">        print(self.__N)</span><br><span class="line"></span><br><span class="line">    def write(self):</span><br><span class="line">        self.__write() # 可以在内部调用</span><br><span class="line"></span><br><span class="line">print(dir(A))</span><br><span class="line">a = A()</span><br><span class="line">print(a._M)</span><br><span class="line">a.read()</span><br><span class="line"># a.__write() # 无法调用</span><br><span class="line">a.write()</span><br><span class="line">print(a._A__N) # 可以调用</span><br><span class="line">a._A__write() # 可以调用</span><br><span class="line"></span><br><span class="line">[&apos;_A__N&apos;, &apos;_A__write&apos;, &apos;_M&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;read&apos;, &apos;write&apos;]</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">20</span><br><span class="line">20</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/36173202" target="_blank" rel="noopener">Python中下划线的5种含义</a></li>
</ul>
<h3 id="抽象类与接口类"><a href="#抽象类与接口类" class="headerlink" title="抽象类与接口类"></a>抽象类与接口类</h3><ul>
<li>抽象类: 只能被继承, 不能实例化, 只能有抽象方法, 没有实现功能, 子类必须实现抽象方法(规范化)</li>
<li><p>接口继承实现归一化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">python3:</span><br><span class="line">from abc import ABCMeta, abstractmethod</span><br><span class="line">class Pay(metaclass=ABCMeta):</span><br><span class="line">    # 规范一个方法上面加一句@abstractmethod</span><br><span class="line">    @abstractmethod       </span><br><span class="line">    def pay(self):</span><br><span class="line">        pass  </span><br><span class="line"></span><br><span class="line">python2:</span><br><span class="line">class Pay(object):</span><br><span class="line">    __metaclass__ = ABCMeta</span><br><span class="line">    # 规范一个方法上面加一句@abstractmethod</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def pay(self):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.cnblogs.com/0627zhou/p/9374698.html" target="_blank" rel="noopener">Python_015(面向对象(接口类,抽象类,多态,封装)</a></p>
</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Animal(object):</span><br><span class="line">    def __init__(self, name):  # Constructor of the class</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def talk(self):</span><br><span class="line">        raise NotImplementedError(&quot;Subclass must implement abstract method&quot;)</span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line">    def talk(self):</span><br><span class="line">        print(&apos;%s: 喵喵喵!&apos; % self.name)</span><br><span class="line"></span><br><span class="line">class Dog(Animal):</span><br><span class="line">    def talk(self):</span><br><span class="line">        print(&apos;%s: 汪！汪！汪！&apos; % self.name)</span><br><span class="line"></span><br><span class="line">def func(obj):  # 一个接口，多种形态</span><br><span class="line">    obj.talk()</span><br><span class="line"></span><br><span class="line">c1 = Cat(&apos;小晴&apos;)</span><br><span class="line">d1 = Dog(&apos;李磊&apos;)</span><br><span class="line"></span><br><span class="line">func(c1)</span><br><span class="line">func(d1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 多态性带来的好处，比如Python的序列类型有多种形态：字符串，列表，元组，多态性体现</span><br><span class="line"># str,list,tuple都是序列类型</span><br><span class="line">s=str(&apos;hello&apos;)</span><br><span class="line">l=list([1,2,3])</span><br><span class="line">t=tuple((4,5,6))</span><br><span class="line"></span><br><span class="line"># 我们可以在不考虑三者类型的前提下使用s,l,t</span><br><span class="line">s.__len__()</span><br><span class="line">l.__len__()</span><br><span class="line">t.__len__()</span><br></pre></td></tr></table></figure></p>
<h3 id="三种方法"><a href="#三种方法" class="headerlink" title="三种方法"></a>三种方法</h3><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><ul>
<li>可以访问实例变量和类变量</li>
<li>只能实例对象调用</li>
</ul>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><ul>
<li>@staticmethod</li>
<li>静态方法是不可以访问实例变量或类变量</li>
<li>可通过实例对象或类对象调用</li>
<li>不会主动传入self, 调用时可以传入实例本身或者去掉self</li>
</ul>
<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><ul>
<li>@classmethod</li>
<li>类方法只能访问类变量，不能访问实例变量</li>
<li>可通过实例对象或类对象调用</li>
<li>需要传入cls参数, cls参数指向的是一开始定义的类对象（不是实例对象）</li>
<li>Django中classonlymethod继承了classmethod，但是classonlymethod只能通过类对象调用，而不能通过实例对象调用as_view()方法，即‘阉割’了实例调用的方式。</li>
</ul>
<h4 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h4><ul>
<li>@property</li>
<li>调用不需要添加()</li>
<li>传参<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@property</span><br><span class="line">def password(self):</span><br><span class="line">    return self._password</span><br><span class="line"></span><br><span class="line">@password.setter</span><br><span class="line">def password(self, raw):</span><br><span class="line">    self._password = generate_password_hash(raw)</span><br><span class="line"></span><br><span class="line">self.password = &apos;123456&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="对比和适用场景"><a href="#对比和适用场景" class="headerlink" title="对比和适用场景"></a>对比和适用场景</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class MyClass(object):</span><br><span class="line">    # 实例方法</span><br><span class="line">    def instance_method(self):</span><br><span class="line">        print(&apos;instance method called&apos;, self)</span><br><span class="line"></span><br><span class="line">    # 类方法</span><br><span class="line">    @classmethod</span><br><span class="line">    def class_method(cls):</span><br><span class="line">        print(&apos;class method called&apos;, cls)</span><br><span class="line"></span><br><span class="line">    # 静态方法</span><br><span class="line">    @staticmethod</span><br><span class="line">    def static_method():</span><br><span class="line">        print(&apos;static method called&apos;)</span><br><span class="line"></span><br><span class="line"># 通过实例对象调用</span><br><span class="line">my_class = MyClass()        # 实例化</span><br><span class="line">my_class.static_method()    # 静态方法</span><br><span class="line">my_class.class_method()     # 类方法</span><br><span class="line">my_class.instance_method()  # 实例方法</span><br><span class="line"></span><br><span class="line"># 通过类对象调用</span><br><span class="line">MyClass.static_method()     # 静态方法</span><br><span class="line">MyClass.class_method()      # 类方法</span><br><span class="line">MyClass.instance_method()   # 实例方法</span><br><span class="line"></span><br><span class="line">static method called</span><br><span class="line">class method called &lt;class &apos;__main__.MyClass&apos;&gt;</span><br><span class="line">instance method called &lt;__main__.MyClass object at 0x0000021CE87A1160&gt;</span><br><span class="line"></span><br><span class="line">static method called</span><br><span class="line">class method called &lt;class &apos;__main__.MyClass&apos;&gt;</span><br><span class="line"># 报错 instance_method() missing 1 required positional argument: &apos;self&apos;</span><br></pre></td></tr></table></figure>
<ol>
<li>类方法无须创建实例对象调用，所以类方法的调用较实例方法更为灵活</li>
<li>静态方法有点像附属于类对象的“工具”, 将对象的相关处理逻辑“束缚”在对象体内，这样封装得会更好些。</li>
<li>实例方法只能通过实例对象调用；类方法和静态方法可以通过类对象或者实例对象调用，如果是使用实例对象调用的类方法或静态方法，最终都会转而通过类对象调用。</li>
<li>实例方法使用最多，可以直接处理实例对象的逻辑；类方法不需要创建实例对象，直接处理类对象的逻辑；静态方法将与类对象相关的某些逻辑抽离出来，不仅可以用于测试，还能便于代码后期维护。</li>
<li>实例方法和类方法，能够改变实例对象或类对象的状态，而静态方法不能。</li>
</ol>
<h3 id="类的特殊方法"><a href="#类的特殊方法" class="headerlink" title="类的特殊方法"></a>类的特殊方法</h3><ul>
<li>__doc__ 类的描述信息(注释)</li>
<li>__str__ 打印对象时，默认输出该方法的返回值。</li>
<li>__init__ 创建对象后，python解释器默认调用该方法</li>
<li>__del__ 当删除一个对象时，python解释器也会默认调用该方法</li>
<li>__call__ 对象后加()时执行, 对象 = 类名()</li>
<li>__module__ 表示当前操作的对象在哪个模块</li>
<li>__class__ 表示当前操作的对象的类是哪个</li>
<li>__dict__ 查看类或对象中的所有成员 　　</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MyClass(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;init&apos;)</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(&apos;call&apos;)</span><br><span class="line"></span><br><span class="line"># init</span><br><span class="line">myclass = MyClass()</span><br><span class="line"># call</span><br><span class="line">myclass()</span><br></pre></td></tr></table></figure>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>执行某个方法, 调用某个变量,要确定该方法或者属性是否存在</p>
<ul>
<li>hasattr：否有存在对应属性或者方法</li>
<li>getattr: 获取属性或者方法</li>
<li>setattr: 添加属性或者方法</li>
<li>delattr：删除属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &apos;rearib&apos;</span><br><span class="line">    def func(self):</span><br><span class="line">        print(&apos;func&apos;)</span><br><span class="line">obj = Foo()</span><br><span class="line"> </span><br><span class="line"># 检查是否含有成员</span><br><span class="line">hasattr(obj, &apos;name&apos;) # Ture</span><br><span class="line">hasattr(obj, &apos;func&apos;) # Ture</span><br><span class="line"> </span><br><span class="line"># 获取成员</span><br><span class="line">getattr(obj, &apos;name&apos;) # rearib</span><br><span class="line">getattr(obj, &apos;func&apos;) # &lt;bound method Foo.func of &lt;__main__.Foo object at 0x00000268D131EA58&gt;&gt;</span><br><span class="line"> </span><br><span class="line"># 设置成员</span><br><span class="line">setattr(obj, &apos;age&apos;, 18)</span><br><span class="line">setattr(obj, &apos;show&apos;, lambda num: num + 1)</span><br><span class="line"> </span><br><span class="line"># #### 删除成员 ####</span><br><span class="line">delattr(obj, &apos;name&apos;)</span><br><span class="line">delattr(obj, &apos;name&apos;) # 如果属性不存在, 报错</span><br><span class="line">delattr(obj, &apos;func&apos;) # 不能删除对象方法, 报错</span><br></pre></td></tr></table></figure>
</li>
</ul>
</div><div class="tags"><a href="/tags/Python/">Python</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/08/30/Markdown-常用语法说明/" class="pre">常用Markdown语法说明</a><a href="/2018/08/13/Python-常用模块/" class="next">Python-常用模块</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象编程"><span class="toc-text">面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#变量和方法"><span class="toc-text">变量和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#封装"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super"><span class="toc-text">super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#下划线"><span class="toc-text">下划线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类与接口类"><span class="toc-text">抽象类与接口类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三种方法"><span class="toc-text">三种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实例方法"><span class="toc-text">实例方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态方法"><span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类方法"><span class="toc-text">类方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类属性"><span class="toc-text">类属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对比和适用场景"><span class="toc-text">对比和适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的特殊方法"><span class="toc-text">类的特殊方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反射"><span class="toc-text">反射</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/10/Vagrant-使用vagrant搭建虚拟开发环境/">使用vagrant搭建虚拟开发环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/05/Django-缓存/">Django-缓存</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/05/Django-对cookie、session、token、jwt的理解/">Django-对cookie、session、token、jwt的理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/04/Django-中间件MiddleWare/">Django-中间件MiddleWare</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/02/Django-model模型知识点总结/">Django-model模型知识点总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/Django-Web框架本质探究/">Django-Web框架本质探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/28/Python-socket编程/">python-socket编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/21/Python-队列与生产者消费者模式/">python-队列与生产者消费者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/21/Python-RabbitMQ 安装、基本示例、轮询机制/">python-RabbitMQ 安装、基本示例、轮询机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/18/Python-事件驱动和IO介绍/">python-事件驱动和IO介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/文本编辑/" style="font-size: 15px;">文本编辑</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/Tool/" style="font-size: 15px;">Tool</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/项目部署/" style="font-size: 15px;">项目部署</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.tendcode.com/" title="Tendcode" target="_blank">Tendcode</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Rearib.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c7a5758117d8eb934731041ec33d337";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>