<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rearib的个人博客</title>
  
  <subtitle>一生温暖纯良，不舍爱与自由</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-12T05:57:23.271Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Rearib</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Django(1)-Web框架本质探究</title>
    <link href="http://yoursite.com/2018/10/01/Django(1)-Web%E6%A1%86%E6%9E%B6%E6%9C%AC%E8%B4%A8%E6%8E%A2%E7%A9%B6/"/>
    <id>http://yoursite.com/2018/10/01/Django(1)-Web框架本质探究/</id>
    <published>2018-10-01T14:46:43.000Z</published>
    <updated>2018-12-12T05:57:23.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web框架本质"><a href="#Web框架本质" class="headerlink" title="Web框架本质"></a>Web框架本质</h2><p>&emsp;&emsp;对于所有的Web应用，本质上其实就是一个socket服务端，用户的浏览器其实就是一个socket客户端。对于真实开发中的python web程序来说，一般会分为两部分：<strong>服务器程序</strong>和<strong>应用程序</strong>。服务器程序负责对socket服务器进行封装，并在请求到来时，对请求的各种数据进行整理。应用程序则负责具体的逻辑处理。<br><a id="more"></a><br>&emsp;&emsp;为了方便应用程序的开发,就会出现许多的Web框架,而所有的web框架都需要与服务器程序配合才能为用户服务，所以web框架和web服务器之间需要标准化。</p><h2 id="一般Web框架架构"><a href="#一般Web框架架构" class="headerlink" title="一般Web框架架构"></a>一般Web框架架构</h2><p><img src="http://qiniu.rearib.top/20181804/1421-S.png" alt=""><br>&emsp;&emsp;大多数基于Python的web框架，如Django、tornado、flask、webpy都是在这个范围内进行增删裁剪的。例如Tornado用的是自己的异步非阻塞“WSGI”网关接口，Flask则只提供了最精简和基本的框架，Django则是直接使用了现成的WSGI，并实现了大部分功能，提供了大量的应用工具。</p><blockquote><p>MTV设计模式</p></blockquote><p><img src="http://qiniu.rearib.top/20181804/1436-C.png" alt=""></p><h3 id="WSGI-uwsgi-uWSGI区别"><a href="#WSGI-uwsgi-uWSGI区别" class="headerlink" title="WSGI-uwsgi-uWSGI区别"></a>WSGI-uwsgi-uWSGI区别</h3><p>&emsp;&emsp;<strong>WSGI</strong>：全称是Web Server Gateway Interface，WSGI不是服务器、python模块、框架、API或者任何软件，只是一种<strong>网关接口</strong>，它是一个Web服务器（如nginx，uWSGI等服务器）与web应用（如用Django框架写的程序）通信的一种规范。<br>&emsp;&emsp;<strong>uwsgi</strong>：一种传输协议，常用于在uWSGI服务器与其他网络服务器的数据通信。<br>&emsp;&emsp;<strong>uWSGI</strong>：是一个web服务器，实现了WSGI协议、uwsgi协议、http协议等。<br><img src="http://qiniu.rearib.top/20181830/0933-9.png" alt=""><br><strong>工作流程:</strong></p><ol><li>首先客户端请求服务资源。</li><li>nginx作为直接对外的服务接口,接收到客户端发送过来的http请求,会解包、分析。</li></ol><ul><li>如果是静态文件请求就根据nginx配置的静态文件目录，返回请求的资源。</li><li>如果是动态的请求,nginx就通过配置文件,将请求传递给uWSGI。</li></ul><ol><li>uWSGI将接收到的包进行处理，转发给wsgi。</li><li>wsgi根据请求调用django工程的某个文件或函数，处理完后django将返回值交给wsgi。</li><li>wsgi将返回值进行打包，转发给uWSGI。</li><li>uWSGI接收后转发给nginx,nginx最终将返回值返回给客户端(如浏览器)。</li></ol><p>&emsp;&emsp;第一级的nginx并不是必须的，uwsgi完全可以完成整个的和浏览器交互的流程，但是要考虑到某些情况：</p><ul><li>安全问题：程序不能直接被浏览器访问到，而是通过nginx。nginx只开放某个接口，这样运维人员在nginx上加上安全性的限制，可以达到保护程序的作用。</li><li>负载均衡问题：一个uwsgi很可能不够用，有了nginx做代理，一个nginx可以代理多台uwsgi完成uwsgi的负载均衡。</li><li>静态文件问题：用django或是uwsgi这种东西来负责静态文件的处理是很浪费的行为，而且他们本身对文件的处理也不如nginx好，所以整个静态文件的处理都直接由nginx完成，静态文件的访问完全不去经过uwsgi以及其后面的东西。</li></ul><h3 id="通过对Django的启动研究socket的启动"><a href="#通过对Django的启动研究socket的启动" class="headerlink" title="通过对Django的启动研究socket的启动"></a>通过对Django的启动研究socket的启动</h3><p>&emsp;&emsp;<strong>使用runserver是启动Django自带的WSGI服务器</strong>，常用于开发调试，分析Django的源码:</p><ul><li>执行<code>python manage.py runserver 127.0.0.1:8000</code>后，会在<code>\Django1.11.6\Lib\site-packages\django\core\management\__init__.py</code>中执行<code>self.fetch_command(subcommand).run_from_argv(self.argv)</code>。</li><li>调用<code>fetch_command</code>返回的<code>runserver</code>模块下的<code>Command</code>对象，其中Command对象是<code>&lt;django.contrib.staticfiles.management.commands.runserver.Command object&gt;</code>，继续调用<code>Command</code>对象的<code>run_from_argv</code>方法，然后执行<code>self.handle(*args, **options)</code>调用<code>Command</code>下的<code>handle</code>。</li><li><p>从<code>Command.handle</code>–&gt;<code>Command.run</code>–&gt;<code>Command.inner_run</code>，并在inner_run中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handler = self.get_handler(*args, **options)</span><br><span class="line">run(self.addr, int(self.port), handler,</span><br><span class="line">    ipv6=self.use_ipv6, threading=threading, server_cls=self.server_cls)</span><br></pre></td></tr></table></figure></li><li><p>在<code>get_handler</code>中会在通过<code>wsgi.py</code>返回<code>WSGIHandler()</code>，继承于<code>class WSGIHandler(base.BaseHandler)</code>，然后会执行run:</p></li><li><p>而run就是启动一个线程一直监听，其中<code>wsgi_handler</code>是<code>WSGIHandler()</code>，<code>server_cls=WSGIServer</code>是继承于<code>class WSGIServer(simple_server.WSGIServer, object)</code>，而<code>simple_server</code>来自于<code>from wsgiref import simple_server</code>，而wsgiref就是Python内置的一个WSGI服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def run(addr, port, wsgi_handler, ipv6=False, threading=False, server_cls=WSGIServer):</span><br><span class="line">    server_address = (addr, port)</span><br><span class="line">    if threading:</span><br><span class="line">        httpd_cls = type(str(&apos;WSGIServer&apos;), (socketserver.ThreadingMixIn, server_cls), &#123;&#125;)</span><br><span class="line">    else:</span><br><span class="line">        httpd_cls = server_cls</span><br><span class="line">    httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)</span><br><span class="line">    if threading:</span><br><span class="line">        # ThreadingMixIn.daemon_threads indicates how threads will behave on an</span><br><span class="line">        # abrupt shutdown; like quitting the server by the user or restarting</span><br><span class="line">        # by the auto-reloader. True means the server will not wait for thread</span><br><span class="line">        # termination before it quits. This will make auto-reloader faster</span><br><span class="line">        # and will prevent the need to kill the server manually if a thread</span><br><span class="line">        # isn&apos;t terminating correctly.</span><br><span class="line">        httpd.daemon_threads = True</span><br><span class="line">    httpd.set_app(wsgi_handler)</span><br><span class="line">    httpd.serve_forever()</span><br></pre></td></tr></table></figure></li><li><p>wsgiref是用纯Python编写的WSGI服务器的参考实现。所谓“参考实现”是指该实现完全符合WSGI标准，但是不考虑任何运行效率，仅供开发和测试使用。</p></li></ul><p>参考文章:</p><ul><li><a href="https://www.cnblogs.com/luchuangao/articles/7374415.html" target="_blank" rel="noopener">由django.setup()引发得对Django启动过程解读</a></li><li><a href="http://www.javabin.cn/2018/django_start.html" target="_blank" rel="noopener">Django 源码学习之搭建环境和django启动流程(一)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Web框架本质&quot;&gt;&lt;a href=&quot;#Web框架本质&quot; class=&quot;headerlink&quot; title=&quot;Web框架本质&quot;&gt;&lt;/a&gt;Web框架本质&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;对于所有的Web应用，本质上其实就是一个socket服务端，用户的浏览器其实就是一个socket客户端。对于真实开发中的python web程序来说，一般会分为两部分：&lt;strong&gt;服务器程序&lt;/strong&gt;和&lt;strong&gt;应用程序&lt;/strong&gt;。服务器程序负责对socket服务器进行封装，并在请求到来时，对请求的各种数据进行整理。应用程序则负责具体的逻辑处理。&lt;br&gt;
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
</feed>
