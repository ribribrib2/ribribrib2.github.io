<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rearib的个人博客</title>
  
  <subtitle>一生温暖纯良，不舍爱与自由</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-27T06:55:42.825Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Rearib</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python-函数</title>
    <link href="http://yoursite.com/2018/11/07/Python-%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/11/07/Python-函数/</id>
    <published>2018-11-07T11:33:42.000Z</published>
    <updated>2019-03-27T06:55:42.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def info(name, age, country = &apos;CN&apos;, *args, **kwargs): # 必填参数、默认值参数、可变参数、关键字参数</span><br><span class="line">    name = &apos;rearib&apos;  # 局部变量</span><br><span class="line">    print(name)</span><br><span class="line">func(&apos;rearib&apos;, 12)   # 位置测试</span><br><span class="line">func(age=22, name=&apos;rearib&apos;)   # 关键字参数</span><br></pre></td></tr></table></figure><ul><li>name是形式参数</li><li>‘rearib’是传入的实参</li><li>country是默认参数, 传入了默认值</li><li>位置参数传参，需要按顺序</li><li>关键字参数传参，可以不按顺序</li><li>局部变量作用域在函数内部，不影响外部</li><li>*args会把多传入的参数变成一个元祖形式</li><li>**kwargs会把多传入的参数变成一个dict形式</li></ul><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>一个函数在内部调用自身, 就叫递归函数</p><ul><li>必须有一个明确的结束条件；</li><li>每次进入更深一层递归时，问题规模相比上次递归都应有所减少；</li><li>递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出</li></ul><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>满足下列条件之一就可称函数为高阶函数</p><ul><li>某一函数当做参数传入另一个函数中</li><li>函数的返回值包含一个或多个函数</li></ul><h4 id="map-函数"><a href="#map-函数" class="headerlink" title="map()函数"></a>map()函数</h4><p>map()是Python内置的高阶函数，它接收一个函数f和一个list，并通过把函数f依次作用在list的每个元素上，得到一个新的list并返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def func(x):</span><br><span class="line">    return x * x</span><br><span class="line">a= map(func,range(1,10))</span><br><span class="line">print(list(a))</span><br><span class="line"></span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure></p><h4 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter()函数"></a>filter()函数</h4><p>filter()函数接收一个函数f和一个list，这个函数f的作用是对每个元素进行判断，返回True或False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(x):</span><br><span class="line">    return x % 2 == 1</span><br><span class="line">a = filter(is_odd,[1,2,3,4,5,6,7,8])</span><br><span class="line">print(list(a))</span><br><span class="line"></span><br><span class="line">[1, 3, 5, 7]</span><br></pre></td></tr></table></figure></p><h3 id="匿名函数lambda"><a href="#匿名函数lambda" class="headerlink" title="匿名函数lambda"></a>匿名函数lambda</h3><p>lambda函数是一种快速定义单行的最小函数</p><p>lambda 传入的参数:参数处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fun(x,y):</span><br><span class="line">    return x + y</span><br><span class="line"></span><br><span class="line">a = lambda x,y:x + y</span><br><span class="line"></span><br><span class="line">fun(1,2)</span><br><span class="line">a(1,2)</span><br></pre></td></tr></table></figure></p><h3 id="函数嵌套和作用域"><a href="#函数嵌套和作用域" class="headerlink" title="函数嵌套和作用域"></a>函数嵌套和作用域</h3><p>在一个函数中定义了另外一个函数, 参数依据就近原则, 从里往外找</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li><a href="https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">学习Javascript闭包</a></li></ul><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><ul><li>高阶+嵌套<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def outer(func):</span><br><span class="line">    def inner(name):</span><br><span class="line">        print(&apos;start&apos;)</span><br><span class="line">        func(name)</span><br><span class="line">        print(&apos;stop&apos;)</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@outer  # hello = outer(hello)(name)</span><br><span class="line">def hello(name):</span><br><span class="line">    print(&apos;welcome&apos;, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hello(&apos;Tom&apos;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="多个装饰器"><a href="#多个装饰器" class="headerlink" title="多个装饰器"></a>多个装饰器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def outer1(func1):</span><br><span class="line">    print(&apos;outer1&apos;)</span><br><span class="line">    def inner1(*args, **kwargs):</span><br><span class="line">        print(&apos;start&apos;)</span><br><span class="line">        r = func1(*args, **kwargs)</span><br><span class="line">        print(&apos;end&apos;)</span><br><span class="line">        return r</span><br><span class="line">    return inner1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def outer2(func2):</span><br><span class="line">    print(&apos;outer2&apos;)</span><br><span class="line">    def inner2(*args, **kwargs):</span><br><span class="line">        print(&apos;开始&apos;)</span><br><span class="line">        r = func2(*args, **kwargs)</span><br><span class="line">        print(&apos;结束&apos;)</span><br><span class="line">        return r</span><br><span class="line">    return inner2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@outer1   </span><br><span class="line">@outer2 </span><br><span class="line">def f():</span><br><span class="line">    print(&apos;f 函数&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f()</span><br></pre></td></tr></table></figure><ul><li>执行@outer1和@outer2时会重下往上执行, 先执行outer2并返回inner2, 所以f = outer2(f) = inner2</li><li>然后执行outer1, 所以f = outer1(inner2) = inner1, </li><li>然后执行f()相对于执行innrt1(inner2), 所以先打印’start’之后跳到inner2执行打印’开始’、’f 函数’、’结束’</li><li>最后返回到inner1中打印’end’</li></ul><h4 id="多个装饰器的应用"><a href="#多个装饰器的应用" class="headerlink" title="多个装饰器的应用"></a>多个装饰器的应用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@is_login</span><br><span class="line">@is_admin</span><br><span class="line">def add_student(name):</span><br><span class="line">    print(&quot;添加学生信息.....&quot;)</span><br></pre></td></tr></table></figure><p>首先我们调用的is_admin函数，在运行完is_admin外层函数时发现还有一个装饰器函数，然后把参数传向is_login函数，把is_login函数外层函数运行结束后，系统发现并没有第三个装饰器，那么is_login里的warpper函数就是最底层函数，那么它就依次执行完is_login里的所有函数，再原路返回去寻找上一层函数直到函数运行结束；</p><h4 id="装饰器再传递一层参数"><a href="#装饰器再传递一层参数" class="headerlink" title="装饰器再传递一层参数"></a>装饰器再传递一层参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def timer(parameter):</span><br><span class="line"></span><br><span class="line">    def outer_wrapper(func):</span><br><span class="line"></span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            if parameter == &apos;task1&apos;:</span><br><span class="line">                start = time.time()</span><br><span class="line">                func(*args, **kwargs)</span><br><span class="line">                stop = time.time()</span><br><span class="line">                print(&quot;the task1 run time is :&quot;, stop - start)</span><br><span class="line">            elif parameter == &apos;task2&apos;:</span><br><span class="line">                start = time.time()</span><br><span class="line">                func(*args, **kwargs)</span><br><span class="line">                stop = time.time()</span><br><span class="line">                print(&quot;the task2 run time is :&quot;, stop - start)</span><br><span class="line"></span><br><span class="line">        return wrapper</span><br><span class="line"></span><br><span class="line">    return outer_wrapper</span><br><span class="line"></span><br><span class="line">@timer(parameter=&apos;task1&apos;)</span><br><span class="line">def task1():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;in the task1&quot;)</span><br><span class="line"></span><br><span class="line">@timer(parameter=&apos;task2&apos;)</span><br><span class="line">def task2():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;in the task2&quot;)</span><br><span class="line"></span><br><span class="line">task1()</span><br><span class="line">task2()</span><br></pre></td></tr></table></figure><h3 id="Python内置函数"><a href="#Python内置函数" class="headerlink" title="Python内置函数"></a>Python内置函数</h3><ul><li><p><a href="https://www.cnblogs.com/derek1184405959/p/8065488.html" target="_blank" rel="noopener">Python3的内置函数</a></p></li><li><p>bytes() 将一个字符串转换成字节类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &apos;王&apos;</span><br><span class="line">&gt;&gt;&gt; s = bytes(a, encoding=&apos;utf-8&apos;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">b&apos;\xe7\x8e\x8b&apos;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;h3 id=&quot;参数&quot;&gt;&lt;a href=&quot;#参数&quot; class=&quot;headerlink&quot; title=&quot;参数&quot;&gt;&lt;/a&gt;参数&lt;/h3&gt;&lt;figur
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Django-对cookie、session、token、jwt的理解</title>
    <link href="http://yoursite.com/2018/10/05/Django-%E5%AF%B9cookie%E3%80%81session%E3%80%81token%E3%80%81jwt%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/10/05/Django-对cookie、session、token、jwt的理解/</id>
    <published>2018-10-05T14:46:43.000Z</published>
    <updated>2019-03-27T07:21:54.777Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;HTTP协议是一个无状态的协议，也就是说每个请求都是一个独立的请求，请求与请求之间并无关系。但在实际的应用场景，这种方式并不能满足我们的需求。举个大家都喜欢用的例子，把商品加入购物车，单独考虑这个请求，服务端并不知道这个商品是谁的，应该加入谁的购物车？因此这个请求的上下文环境实际上应该包含用户的相关信息，在每次用户发出请求时把这一小部分额外信息，也做为请求的一部分，这样服务端就可以根据上下文中的信息，针对具体的用户进行操作。所以这几种技术的出现都是对HTTP协议的一个补充。使得我们可以用HTTP协议+状态管理构建一个的面向用户的WEB应用。<br><a id="more"></a></p><h2 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h2><p>&emsp;&emsp;Session与Cookie最核心区别在于额外信息由谁来维护：</p><ul><li>利用cookie来实现会话管理时，用户的相关信息或者其他我们想要保持在每个请求中的信息，都是放在cookie中，<strong>而cookie是由客户端来保存</strong>，每当客户端发出新请求时，就会稍带上cookie，服务端会根据其中的信息进行操作。</li><li>利用session来进行会话管理时，客户端实际上只存了一个由服务端发送的session_id，而由这个session_id，可以在服务端还原出所需要的所有状态信息，<strong>所以Session是由服务端来维护的</strong>。<h3 id="cookie是怎么工作的？"><a href="#cookie是怎么工作的？" class="headerlink" title="cookie是怎么工作的？"></a>cookie是怎么工作的？</h3>&emsp;&emsp;当网页要发http请求时，浏览器会先检查是否有相应的cookie，有则自动添加在request header中的cookie字段中。这些是浏览器自动帮我们做的，而且每一次http请求浏览器都会自动帮我们做。<blockquote><p>Cookie的设置</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rep = HttpResponse(...) 或 rep ＝ render(request, ...)</span><br><span class="line">rep.set_cookie(&apos;username&apos;,&apos;admin&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>示例代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def login(request):</span><br><span class="line">    if request.method == &apos;GET&apos;:</span><br><span class="line">        return render(request,&apos;login.html&apos;)</span><br><span class="line"></span><br><span class="line">    if request.method == &apos;POST&apos;:</span><br><span class="line">        u = request.POST.get(&apos;username&apos;)</span><br><span class="line">        p = request.POST.get(&apos;pwd&apos;)</span><br><span class="line">        dic = user_info.get(u)</span><br><span class="line">        if not dic:</span><br><span class="line">            return render(request,&apos;login.html&apos;)</span><br><span class="line">        if dic[&apos;pwd&apos;] == p:</span><br><span class="line">            result = redirect(&apos;/index/&apos;)</span><br><span class="line">            result.set_cookie(&apos;username&apos;,u)</span><br><span class="line">            return result</span><br><span class="line">        else:</span><br><span class="line">            return render(request,&apos;login.html&apos;)</span><br><span class="line">def auth(func):</span><br><span class="line">    def inner(request,*args,**kwargs):</span><br><span class="line">        v = request.COOKIES.get(&apos;username&apos;)</span><br><span class="line">        if not v:</span><br><span class="line">            return redirect(&apos;/login/&apos;)</span><br><span class="line">        return func(request,*args,**kwargs)</span><br><span class="line">    return inner</span><br><span class="line">@auth</span><br><span class="line">def index(request):</span><br><span class="line">    v = request.COOKIES.get(&apos;username&apos;)</span><br><span class="line">    return render(request,&apos;index.html&apos;,&#123;&apos;current_user&apos;:v&#125;)</span><br></pre></td></tr></table></figure><p>第一次打开浏览器，进入index，会自动跳转到login，因为没有cookie：<br><img src="http://qiniu.rearib.top/20181811/1344-H.png" alt=""><br>现输入用户名密码登录，通过上面的代码可得会在返回的时候set_cookie，以key-value的形式：<br><img src="http://qiniu.rearib.top/20181811/1347-E.png" alt=""><br>再将浏览器关闭，重新打开index，发现会跳转到login，是因为默认设置为浏览器关闭就会删除cookie。<br>现修改<code>result.set_cookie(&#39;username&#39;,&#39;u&#39; ,max_age=60)</code>，重新登录：<br><img src="http://qiniu.rearib.top/20181811/1355-q.png" alt=""><br>过期时间是一分钟之后，在此期间就算关闭浏览器再次打开cookie还是有效。</p><ul><li>cookie使用key-value的形式保存数据在客户端</li><li><p>创建一个cookie的生命周期默认为-1，即max_age=-1，表示当浏览器关闭时cookie消失，如果设置max_age=0，表示通知浏览器删除cookie。</p><blockquote><p>cookie 参数</p></blockquote></li><li><p><strong>key</strong>：键</p></li><li><strong>value=’’</strong>：值</li><li><strong>max_age=None</strong>：超时时间（秒）</li><li><strong>expires=None</strong>：超时时间(IE requires expires, so set it if hasn’t been already.) 单位日期</li><li><strong>secure=False</strong>：当secure值为true时，cookie在HTTP中是无效，在HTTPS中才有效。</li><li><strong>httponly=False</strong>：浏览器不允许脚本操作 document.cookie去更改cookie。一般情况下都应该设置这个为true，这样可以避免被xss攻击拿到cookie。</li><li><strong>path</strong>：表示cookie所在的目录，默认为/，就是根目录。假如在同一个服务器上有目录如下：/test/,/test/cd/,/test/dd/，现设一个cookie1的path为/test/，cookie2的path为/test/cd/，那么test下的所有页面都可以访问到cookie1，而/test/和/test/dd/的子页面不能访问cookie2。这是因为cookie只能让其path路径下的页面访问。</li><li><strong>domain</strong>：表示的是cookie所在的域，默认为请求的地址，如网址为<a href="http://www.test.com/test/test.aspx，那么domain默认为www.test.com。而跨域访问，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。" target="_blank" rel="noopener">www.test.com/test/test.aspx，那么domain默认为www.test.com。而跨域访问，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。</a></li></ul><blockquote><p>利用cookie登录</p></blockquote><p>首先使用谷歌浏览器打开博客园登录，然后进入调试状态，查看cookie：<br><img src="http://qiniu.rearib.top/20181811/1446-w.png" alt=""><br>打开火狐浏览器，进入博客园，现在是未登录状态：<br><img src="http://qiniu.rearib.top/20181811/1448-1.png" alt=""><br>使用cookie Editor编辑cookie:<br><img src="http://qiniu.rearib.top/20181811/1449-S.png" alt=""><br>再重新刷新页面：<br><img src="http://qiniu.rearib.top/20181811/1450-S.png" alt=""></p><blockquote><p>cookie缺点</p></blockquote><ul><li>cookie的长度和数量有限制</li><li>cookie安全性不高，不适合存放敏感数据</li><li>每次请求需要带上cookie信息，增加流量消耗</li><li>Cookie具有不可跨域名性。Google也只能操作Google的Cookie，而不能操作Baidu的Cookie。</li></ul><h3 id="session是怎么工作的"><a href="#session是怎么工作的" class="headerlink" title="session是怎么工作的?"></a>session是怎么工作的?</h3><p>&emsp;&emsp;session的运作通过一个session_id来进行。session_id通常是存放在客户端的cookie中，当你下次访问时，cookie会带有这个字符串，然后浏览器就知道你是上次访问过的某某某，然后从服务器的存储中取出上次记录在你身上的数据。由于字符串是随机产生的，而且位数足够多，所以也不担心有人能够伪造。<br><img src="http://qiniu.rearib.top/20181811/1457-K.png" alt=""></p><blockquote><p>Django的session</p></blockquote><p>&emsp;&emsp;Django中默认支持Session，其内部提供了5种类型的Session供开发者使用：</p><ul><li>数据库（默认）</li><li>缓存</li><li>文件</li><li>缓存+数据库</li><li>加密cookie</li></ul><p>编辑MIDDLEWARE设置，并确保它包含<code>django.contrib.sessions.middleware.SessionMiddleware</code>，在中间件的process_request中获取request的cookie，其中<code>SESSION_COOKIE_NAME = &#39;sessionid&#39;</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def process_request(self, request):</span><br><span class="line">    session_key = request.COOKIES.get(settings.SESSION_COOKIE_NAME)</span><br><span class="line">    request.session = self.SessionStore(session_key)</span><br></pre></td></tr></table></figure></p><p>在process_response中设置cookie：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">response.set_cookie(settings.SESSION_COOKIE_NAME,</span><br><span class="line">                    request.session.session_key, max_age=max_age,</span><br><span class="line">                    expires=expires, domain=settings.SESSION_COOKIE_DOMAIN,</span><br><span class="line">                    path=settings.SESSION_COOKIE_PATH,</span><br><span class="line">                    secure=settings.SESSION_COOKIE_SECURE or None,</span><br><span class="line">                    httponly=settings.SESSION_COOKIE_HTTPONLY or None,</span><br><span class="line">                    )</span><br></pre></td></tr></table></figure></p><blockquote><p>session的缺点</p></blockquote><p>&emsp;&emsp;session在一定的时间里，需要存放在服务端，因此当拥有大量用户时，也会大幅度降低服务端的性能。<br>&emsp;&emsp;当有多台机器时，如何共享session也会是一个问题，也就是说，用户第一个访问的时候是服务器A，而第二个请求被转发给了服务器B，那服务器B如何得知其状态。</p><h2 id="Token验证"><a href="#Token验证" class="headerlink" title="Token验证"></a>Token验证</h2><p>&emsp;&emsp;API应该被设计成无状态的。这意味着没有登陆，注销的方法，也没有sessions，API的设计者同样也不能依赖Cookie，因为不能保证这些request是由浏览器所发出的。自然，我们需要一个新的机制。所以提出了Token验证。</p><blockquote><p>流程</p></blockquote><ul><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li><li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li><li>如果用户退出登录，token会在客户端销毁，这一步与服务器无关</li></ul><blockquote><p>token与session及cookie的关系</p></blockquote><p>&emsp;&emsp;借助session识别用户是否登录的方式，<strong>客户端cookie中用于追踪session的那个值（sessionId）可被称为token</strong>，这个token通常是用户名+密码认证成功后所得到的。由此可见session与cookie跟token产生联系，是因为token的概念恰好有一个用session+cookie实现的场景。</p><p>&emsp;&emsp;<strong>token就是token，只是在特定场景中与session、cookie产生了联系，因此我们完全可以选择不借助session与cookie而使用token，比如在HTTP请求头中使用x-token头部传输token的值，又或者是在URL中携带token，这两者在如今都是较常见的做法。</strong></p><ul><li>session的传递一般都是通过cookie来传递的，或者url重写的方式；而token在服务器是可以不需要存储用户的信息的，而token的传递方式也不限于cookie传递，当然，token也是可以保存起来的。</li><li>浏览器第一次访问服务器，根据传过来的唯一标识userId，服务端会通过一些算法，如常用的HMAC-SHA256算法，然后加一个密钥，生成一个token，然后通过BASE64编码一下之后将这个token发送给客户端；客户端将token保存起来，下次请求时，带着token，服务器收到请求后，然后会用相同的算法和密钥去验证token，如果通过，执行业务操作，不通过，返回不通过信息。</li><li>session一般翻译为会话，而token更多的时候是翻译为令牌，session是空间换时间，而token是时间换空间。</li></ul><blockquote><p>drf的token</p></blockquote><p>&emsp;&emsp;关于drf如何使用token参考文章<a href="http://www.cnblogs.com/derek1184405959/p/8813641.html" target="_blank" rel="noopener">Django REST framework+Vue 打造生鲜超市（六）</a></p><p>1.访问<code>url(r&#39;^api-token-auth/&#39;, views.obtain_auth_token)</code>,<br>传过来的是username和password,会生成一个token返回回去</p><p>2.访问其他网页在header中携带token就可以获取到user<br><code>Authorization:Token 89bd7209bf9d5c4656a4f24bb120a1e3b9587ccd</code></p><p>drf的token缺点</p><ul><li>保存在数据库中，如果是一个分布式的系统，就非常麻烦</li><li>token永久有效，没有过期时间。</li></ul><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>&emsp;&emsp;本质上来说 JWT 也是 token，它是 JSON 结构的 token，由三部分组成：1) header 2) payload 3) signature 。<br>&emsp;&emsp;JWT 的目的不是为了隐藏或者保密数据，而是为了确保数据确实来自被授权的人创建的（不被篡改） </p><ul><li>JWT和Token区别:<br>JWT经过加密不易修改,而且可以设置过期时间,比如7天,7天后携带该JWT过来会要求重新登录</li></ul><p>参考文章:</p><ul><li><a href="https://www.cnblogs.com/andy-zhou/p/5360107.html" target="_blank" rel="noopener">理解Cookie和Session机制</a></li><li><a href="https://www.cnblogs.com/xiaozhang2014/p/7750200.html" target="_blank" rel="noopener">Session,Token相关区别</a></li><li><a href="https://blog.csdn.net/tobetheender/article/details/52485948" target="_blank" rel="noopener">Token ，Cookie和Session的区别</a></li><li><a href="http://lion1ou.win/2017/01/18/" target="_blank" rel="noopener">前后端分离之JWT用户认证</a></li><li><a href="https://segmentfault.com/a/1190000005783306" target="_blank" rel="noopener">Node 实作jwt 验证API</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;HTTP协议是一个无状态的协议，也就是说每个请求都是一个独立的请求，请求与请求之间并无关系。但在实际的应用场景，这种方式并不能满足我们的需求。举个大家都喜欢用的例子，把商品加入购物车，单独考虑这个请求，服务端并不知道这个商品是谁的，应该加入谁的购物车？因此这个请求的上下文环境实际上应该包含用户的相关信息，在每次用户发出请求时把这一小部分额外信息，也做为请求的一部分，这样服务端就可以根据上下文中的信息，针对具体的用户进行操作。所以这几种技术的出现都是对HTTP协议的一个补充。使得我们可以用HTTP协议+状态管理构建一个的面向用户的WEB应用。&lt;br&gt;
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django-中间件MiddleWare</title>
    <link href="http://yoursite.com/2018/10/04/Django-%E4%B8%AD%E9%97%B4%E4%BB%B6MiddleWare/"/>
    <id>http://yoursite.com/2018/10/04/Django-中间件MiddleWare/</id>
    <published>2018-10-04T14:46:43.000Z</published>
    <updated>2019-03-27T07:21:58.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h2><p>&emsp;&emsp;中间件是一个用来处理Django的请求和响应的框架级别的钩子。它是一个轻量、低级别的插件系统，用于在全局范围内改变Django的输入和输出。每个中间件组件都负责做一些特定的功能。<strong>但是由于其影响的是全局，所以需要谨慎使用，使用不当会影响性能。</strong><br><a id="more"></a></p><h3 id="中间件配置"><a href="#中间件配置" class="headerlink" title="中间件配置"></a>中间件配置</h3><p>&emsp;&emsp;在django项目的settings模块中，有一个 MIDDLEWARE 变量，其中每一个元素就是一个中间件。<br><img src="http://qiniu.rearib.top/20181807/1124-a.png" alt=""></p><h3 id="中间件方法和执行顺序"><a href="#中间件方法和执行顺序" class="headerlink" title="中间件方法和执行顺序"></a>中间件方法和执行顺序</h3><p>&emsp;&emsp;对于中间件，可以定义下面五种方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process_request(self,request)</span><br><span class="line">process_view(self, request, callback, callback_args, callback_kwargs)</span><br><span class="line">process_template_response(self,request,response)</span><br><span class="line">process_exception(self, request, exception)</span><br><span class="line">process_response(self, request, response)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;以上方法的返回值可以是None或一个HttpResponse对象，如果是None，则继续按照django定义的规则向后继续执行，如果是HttpResponse对象，则直接将该对象返回给用户。</p><blockquote><p>process_request</p></blockquote><p>&emsp;&emsp;process_request有一个参数，就是request，这个request和视图函数中的request是一样的。<br>&emsp;&emsp;它的返回值可以是None也可以是HttpResponse对象。返回值是None的话，按正常流程继续走，交给下一个中间件处理，如果是HttpResponse对象，Django将不执行视图函数，而将相应对象返回给浏览器。</p><ul><li>中间件的process_request方法是在执行视图函数之前执行的。</li><li>当配置多个中间件时，会按照MIDDLEWARE中的注册顺序，也就是列表的索引值，从前到后依次执行的。</li><li><strong>不同中间件之间传递的request都是同一个对象</strong></li></ul><blockquote><p>process_view</p></blockquote><p><code>process_view(self, request, view_func, view_args, view_kwargs)</code></p><ol><li>request是HttpRequest对象。</li><li>view_func是Django即将使用的视图函数。 （它是实际的函数对象，而不是函数的名称作为字符串。）</li><li>view_args是将传递给视图的位置参数的列表.</li><li>view_kwargs是将传递给视图的关键字参数的字典。 view_args和view_kwargs都不包含第一个视图参数（request）。</li></ol><ul><li>Django会在调用视图函数之前调用process_view方法。</li></ul><p>&emsp;&emsp;它应该返回None或一个HttpResponse对象。 如果返回None，Django将继续处理这个请求，执行任何其他中间件的process_view方法，然后在执行相应的视图。 如果它返回一个HttpResponse对象，Django不会调用适当的视图函数。 它将执行中间件的process_response方法并将应用到该HttpResponse并返回结果。</p><blockquote><p>process_exception</p></blockquote><p><code>process_exception(self, request, exception)</code></p><ol><li>request是HttpRequest对象。</li><li>exception是视图函数异常产生的Exception对象。</li></ol><ul><li>如果视图函数中无异常，process_exception方法不执行。</li></ul><p>&emsp;&emsp;这个方法只有在视图函数中出现异常了才执行，它返回的值可以是一个None也可以是一个HttpResponse对象。如果是HttpResponse对象，Django将调用模板和中间件中的process_response方法，并返回给浏览器，否则将默认处理异常。如果返回一个None，则交给下一个中间件的process_exception方法来处理异常。它的执行顺序也是按照中间件注册顺序的倒序执行。</p><blockquote><p>process_template_response（用的比较少）</p></blockquote><p><code>process_template_response(self, request, response)</code></p><ol><li>request是HttpRequest对象。</li><li>response是TemplateResponse对象（由视图函数或者中间件产生）。</li></ol><p>&emsp;&emsp;process_template_response是在视图函数执行完成后立即执行，但是它有一个前提条件，那就是视图函数返回的对象有一个render()方法（或者表明该对象是一个TemplateResponse对象或等价方法）</p><blockquote><p>process_response</p></blockquote><p>&emsp;&emsp;它有两个参数，一个是request，一个是response，request就是上述例子中一样的对象，response是视图函数返回的HttpResponse对象。该方法的返回值也必须是HttpResponse对象。</p><ul><li>多个中间件中的process_response方法是按照MIDDLEWARE中的注册顺序倒序执行的，也就是说第一个中间件的process_request方法首先执行，而它的process_response方法最后执行，最后一个中间件的process_request方法最后一个执行，它的process_response方法是最先执行。</li></ul><h3 id="中间件的执行流程图"><a href="#中间件的执行流程图" class="headerlink" title="中间件的执行流程图"></a>中间件的执行流程图</h3><p>&emsp;&emsp;请求到达中间件之后，先按照正序执行每个注册中间件的process_request方法，process_request方法返回的值是None，就依次执行，如果返回的值是HttpResponse对象，不再执行后面的process_request方法，而是执行当前对应中间件的process_response方法，将HttpResponse对象返回给浏览器。也就是说：如果MIDDLEWARE中注册了6个中间件，执行过程中，第3个中间件返回了一个HttpResponse对象，那么第4,5,6中间件的process_request和process_response方法都不执行，顺序执行3,2,1中间件的process_response方法。<br>&emsp;&emsp;process_request方法都执行完后，匹配路由，找到要执行的视图函数，先不执行视图函数，先执行中间件中的process_view方法，process_view方法返回None，继续按顺序执行，所有process_view方法执行完后执行视图函数。加入中间件3 的process_view方法返回了HttpResponse对象，则4,5,6的process_view以及视图函数都不执行，直接从最后一个中间件，也就是中间件6的process_response方法开始倒序执行。<br>process_template_response和process_exception两个方法的触发是有条件的，执行顺序也是倒序。总结所有的执行流程如下：<br><img src="http://qiniu.rearib.top/20181807/1150-n.png" alt=""><br><img src="http://qiniu.rearib.top/20181807/1152-F.png" alt=""><br>&emsp;&emsp;<strong>在执行完RequestMiddlewares后先到urls.py然后再执行ViewMiddlewares中间件</strong></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>&emsp;&emsp;在前面我们探究过web框架的本质，在实例化一个WSGIHander对象的时候，在<code>__init__()</code>中通过<code>self.load_middleware()</code>会加载setting中设置的中间件。<br>&emsp;&emsp;从<code>settings</code>配置文件读取设置的<code>middleware</code>，然后初始化<code>WSGIHandler</code>类中的各个<code>middleware</code>的相关变量，这些变量主要包括<code>self._request_middleware</code>，<code>self._view_middleware</code>，<code>self._template_response_middleware</code>，<code>self._response_middleware</code>，<code>self._exception_middleware</code>，均为存放中间件方法的列表。</p><h2 id="中间件的应用"><a href="#中间件的应用" class="headerlink" title="中间件的应用"></a>中间件的应用</h2><p>&emsp;&emsp;由于中间件工作在视图函数执行前、执行后（像不像所有视图函数的装饰器！）适合所有的请求/一部分请求做批量处理。</p><ul><li>做IP限制：<br>  放在 中间件类的列表中，阻止某些IP访问；</li><li>URL访问过滤<ol><li>如果用户访问的是login视图（放过）</li><li>如果访问其他视图（需要检测是不是有session已经有了放行，没有返回login），这样就省得在多个视图函数上写装饰器了！</li></ol></li><li>缓存<br>  客户端请求来了，中间件去缓存看看有没有数据，有直接返回给用户，没有再去逻辑层执行视图函数</li></ul><p>参考文章:</p><ul><li><a href="https://www.jianshu.com/p/1ff05dfb3d0d" target="_blank" rel="noopener">django源码分析之请求响应流程</a></li><li><a href="https://www.jianshu.com/p/eacea630e078" target="_blank" rel="noopener">Django 中间件原理及源码分析</a></li><li><a href="https://blog.csdn.net/miaoqinian/article/details/80816474" target="_blank" rel="noopener">Django 中间件</a></li><li><a href="https://yiyibooks.cn/xx/Django_1.11.6/topics/http/middleware.html" target="_blank" rel="noopener">官方文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是中间件&quot;&gt;&lt;a href=&quot;#什么是中间件&quot; class=&quot;headerlink&quot; title=&quot;什么是中间件&quot;&gt;&lt;/a&gt;什么是中间件&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;中间件是一个用来处理Django的请求和响应的框架级别的钩子。它是一个轻量、低级别的插件系统，用于在全局范围内改变Django的输入和输出。每个中间件组件都负责做一些特定的功能。&lt;strong&gt;但是由于其影响的是全局，所以需要谨慎使用，使用不当会影响性能。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django-model模型知识点总结</title>
    <link href="http://yoursite.com/2018/10/02/Django-model%E6%A8%A1%E5%9E%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/10/02/Django-model模型知识点总结/</id>
    <published>2018-10-02T14:46:43.000Z</published>
    <updated>2019-03-27T07:21:46.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="model梳理与难点剖析"><a href="#model梳理与难点剖析" class="headerlink" title="model梳理与难点剖析"></a>model梳理与难点剖析</h2><h3 id="Python操作数据库"><a href="#Python操作数据库" class="headerlink" title="Python操作数据库"></a>Python操作数据库</h3><p>&emsp;&emsp;用Python语法来写，然后使用一个中间工具将Python代码翻译成原生的SQL语句，这个中间工具就是所谓的ORM（对象关系映射）！ORM将一个Python的对象映射为数据库中的一张关系表。它将SQL封装起来，程序员不再需要关心数据库的具体操作，只需要专注于自己本身代码和业务逻辑的实现。于是，整体的实现过程就是：Python代码，通过ORM转换成SQL语句，再通过pymysql去实际操作数据库。<br>&emsp;&emsp;最典型的ORM就是<a href="www.sqlalchemy.org">SQLAlchemy</a>了，但是Django自带ORM系统，不需要额外安装别的ORM。</p><h3 id="字段选项和字段类型"><a href="#字段选项和字段类型" class="headerlink" title="字段选项和字段类型"></a>字段选项和字段类型</h3><blockquote><p>阅读文章 </p></blockquote><ul><li><a href="https://yiyibooks.cn/xx/Django_1.11.6/ref/models/fields.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="http://www.liujiangblog.com/course/django/94" target="_blank" rel="noopener">刘江的个人博客</a></li></ul><blockquote><p>null和Black的区别:</p></blockquote><p>&emsp;&emsp;如果null为True，Django将在数据库中将空值存储为NUL，blank=True，表单验证时将允许输入空值，null 纯粹是数据库范畴的概念，而blank 是数据验证范畴的。</p><blockquote><p>自增字段</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id = models.AutoField(primary_key=True)</span><br></pre></td></tr></table></figure><blockquote><p>auto_now_add和auto_add</p></blockquote><ul><li>auto_now:每当对象被保存时将字段设为当前日期，常用于保存最后修改时间。</li><li>auto_now_add：每当对象被创建时，设为当前日期，常用于保存创建日期(注意，它是不可修改的)。</li></ul><blockquote><p>db_column字段列名称</p></blockquote><p>&emsp;&emsp;数据库中用db_column来表示该字段的列名称。 如果未指定，那么Django将会使用字段名作为列名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id = models.AutoField(max_length=11,db_column=&apos;UID&apos;,primary_key=True)</span><br></pre></td></tr></table></figure></p><blockquote><p>unique_for_date</p></blockquote><p>&emsp;&emsp;如果你有一个title 字段设置unique_for_date=”pub_date”，那么Django 将不允许两个记录具有相同的title 和pub_date。unique_for_month类似unique_for_date，只是要求字段对于月份是唯一的。</p><blockquote><p>upload_to</p></blockquote><p>&emsp;&emsp;用于设置上传地址的目录和文件名:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyModel(models.Model):</span><br><span class="line">    # 文件被传至`MEDIA_ROOT/uploads`目录，MEDIA_ROOT由你在settings文件中设置</span><br><span class="line">    upload = models.FileField(upload_to=&apos;uploads/&apos;)</span><br><span class="line">    # 或者</span><br><span class="line">    # 被传到`MEDIA_ROOT/uploads/2015/01/30`目录，增加了一个时间划分</span><br><span class="line">    upload = models.FileField(upload_to=&apos;uploads/%Y/%m/%d/&apos;)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;也可以接收回调函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def user_directory_path(instance, filename):</span><br><span class="line">    #文件上传到MEDIA_ROOT/user_&lt;id&gt;/&lt;filename&gt;目录中</span><br><span class="line">    return &apos;user_&#123;0&#125;/&#123;1&#125;&apos;.format(instance.user.id, filename)</span><br><span class="line"></span><br><span class="line">class MyModel(models.Model):</span><br><span class="line">    upload = models.FileField(upload_to=user_directory_path)</span><br></pre></td></tr></table></figure></p><blockquote><p>评论系统的外键</p></blockquote><p>&emsp;&emsp;什么时候需要自己引用自己的外键呢？典型的例子就是评论系统！一条评论可以被很多人继续评论:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent_comment = models.ForeignKey(&apos;self&apos;, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure></p><blockquote><p>choice</p></blockquote><p>&emsp;&emsp;在choices中，每个元组中的第一个元素，是存储在数据库中的值；第二个元素是使人容易理解的描述。给定一个模型实例，可以使用get_FOO_display()方法来访问选项字段的显示值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YEAR_IN_SCHOOL_CHOICES = (</span><br><span class="line">    (&apos;FR&apos;, &apos;Freshman&apos;),</span><br><span class="line">    (&apos;SO&apos;, &apos;Sophomore&apos;),</span><br><span class="line">    (&apos;JR&apos;, &apos;Junior&apos;),</span><br><span class="line">    (&apos;SR&apos;, &apos;Senior&apos;),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><blockquote><p>related_name和related_query_name的使用：<a href="https://yiyibooks.cn/xx/Django_1.11.6/topics/db/models.html#abstract-related-name" target="_blank" rel="noopener">官方文档</a></p></blockquote><p>&emsp;&emsp;假如有下面两个模型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person(models.Model);</span><br><span class="line">    name = models.CharField(verbose_name=&apos;作者姓名&apos;, max_length=10)</span><br><span class="line">    age = models.IntegerField(verbose_name=&apos;作者年龄&apos;)</span><br><span class="line"></span><br><span class="line">class Book(models.Model):</span><br><span class="line">    person = models.ForeignKey(Person, related_name=&apos;person_book&apos;)</span><br><span class="line">    title = models.CharField(verbose_name=&apos;书籍名称&apos;, max_length=10)</span><br><span class="line">    pubtime = models.DateField(verbose_name=&apos;出版时间&apos;)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果我们要查询一个作者出版了哪些书籍的话,先查询到作者的信息,<code>person = Person.objects.fiter(你的条件)</code>,返回一个person对象,然后反向查询:<code>book = person.book_set.all()</code>,但是如果定义了<code>related_name</code>,就可以使用<code>person.person_books.all()</code>。</p><blockquote><p>关联关系字段</p></blockquote><ul><li><p>on_delete设置</p><p>&emsp;&emsp;ForeignKey.on_delete：当删除由ForeignKey引用的对象时，Django将模拟由on_delete参数指定的SQL约束的行为。</p><ul><li>through和through_fields的作用</li></ul><p>&emsp;&emsp;ManyToMany时会自动创建第三张表用于管理多对多关系，如果想在第三张表添加额外字段，可以使用through：<a href="http://www.cnblogs.com/linyuhong/p/9640078.html" target="_blank" rel="noopener">参考链接</a><br>&emsp;&emsp;当中间模型具有多个外键指向多对多关联关系模型中的任何一个（或两个），你必须指定through_fields：<a href="https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/models/fields.html#manytomanyfield" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class Person(models.Model):</span><br><span class="line">    name = models.CharField(max_length=50)</span><br><span class="line"></span><br><span class="line">class Group(models.Model):</span><br><span class="line">    name = models.CharField(max_length=128)</span><br><span class="line">    members = models.ManyToManyField(</span><br><span class="line">        Person,</span><br><span class="line">        through=&apos;Membership&apos;,</span><br><span class="line">        through_fields=(&apos;group&apos;, &apos;person&apos;),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">class Membership(models.Model):</span><br><span class="line">    group = models.ForeignKey(Group, on_delete=models.CASCADE)</span><br><span class="line">    person = models.ForeignKey(Person, on_delete=models.CASCADE)</span><br><span class="line">    //邀请者</span><br><span class="line">    inviter = models.ForeignKey(</span><br><span class="line">        Person,</span><br><span class="line">        on_delete=models.CASCADE,</span><br><span class="line">        related_name=&quot;membership_invites&quot;,</span><br><span class="line">    )</span><br><span class="line">    invite_reason = models.CharField(max_length=64)</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;Membership有两个 foreign keys指向 Person (person and inviter), 这样会导致关系不清晰，Django不知道使用哪一个外键。 在这种情况下，你必须使用through_fields 明确指定Django 应该使用哪些外键，就像上面例子一样。<br>&emsp;&emsp;<strong>通俗的说，就是through_fields参数指定从中间表模型Membership中选择哪两个字段，作为关系连接字段。</strong></p><blockquote><p>模型的Meta选项</p></blockquote><ul><li><a href="https://yiyibooks.cn/xx/Django_1.11.6/ref/models/options.html" target="_blank" rel="noopener">官方文档</a></li><li>abstract = True：就表示模型是抽象基类，抽象模型本身不实际生成数据库表。</li><li>verbose_name = “pizza”：对象的一个易于理解的名称</li><li>unique_together = (“driver”, “restaurant”)：用来设置的不重复的字段组合,当unique_together的约束被违反时，模型校验期间会抛出ValidationError异常。</li><li>ordering = [‘-order_date’]：对象默认的顺序</li></ul><blockquote><p>model的Manager示例</p></blockquote><p>&emsp;&emsp;每个非抽象的Model 类必须给自己添加一个Manager实例。 Django 确保在你的模型类中至少有一个默认的Manager。 如果你没有添加自己的管理器，Django将添加一个属性objects。<br>&emsp;&emsp;<a href="https://yiyibooks.cn/__trs__/xx/Django_1.11.6/topics/db/managers.html#custom-managers" target="_blank" rel="noopener">自定义管理器</a></p><blockquote><p>验证对象 <a href="https://yiyibooks.cn/xx/Django_1.11.6/ref/models/instances.html#validating-objects" target="_blank" rel="noopener">官方文档</a></p></blockquote><p>&emsp;&emsp;验证一个模型涉及三个步骤：</p><ul><li>验证模型的字段 —— Model.clean_fields()</li><li>验证模型的完整性 —— Model.clean()</li><li>验证模型的唯一性 —— Model.validate_unique()</li></ul><p>&emsp;&emsp;当你调用模型的full_clean() 方法时，这三个方法都将执行。</p><blockquote><p>信号</p></blockquote><ol><li>发出预先保存的信号。 发送pre_save信号，允许监听该信号的任何函数执行某些操作。</li><li>预处理数据。 调用每个字段的pre_save()方法来执行所需的任何自动数据修改。 例如，日期/时间字段覆盖pre_save()来实现auto_now_add和auto_now。</li><li>准备数据库的数据。 要求每个字段的get_db_prep_save()方法将其当前值提供给可写入数据库的数据类型。大多数字段不需要数据准备。 简单的数据类型，例如整数和字符串，是可以直接写入的Python 对象。 但是，复杂的数据类型通常需要一些改动。例如，DateField 字段使用Python 的 datetime 对象来保存数据。 数据库保存的不是datetime 对象，所以该字段的值必须转换成ISO兼容的日期字符串才能插入到数据库中。</li><li>将数据插入数据库。 预处理的准备数据组成一个用于插入数据库的SQL语句。</li><li>发出一个保存后的信号。 发送post_save信号，允许监听该信号的任何函数执行某些操作。</li></ol><blockquote><p>现有字段更新</p></blockquote><p>&emsp;&emsp;有时候你需要在一个字段上执行简单的算法操作，例如增加或者减少当前值。 实现这点的简单方法是像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; product = Product.objects.get(name=&apos;Venezuelan Beaver Cheese&apos;)</span><br><span class="line">&gt;&gt;&gt; product.number_sold += 1</span><br><span class="line">&gt;&gt;&gt; product.save()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果从数据库中读取的旧的number_sold 值为10，那么写回到数据库中的值将为11。<br>&emsp;&emsp;通过将更新基于原始字段的值而不是显式赋予一个新值，这个过程可以避免竞态条件而且更快。 Django提供F表达式用于这种类型的相对更新。 利用F表达式，前面的示例可以表示成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from django.db.models import F</span><br><span class="line">&gt;&gt;&gt; product = Product.objects.get(name=&apos;Venezuelan Beaver Cheese&apos;)</span><br><span class="line">&gt;&gt;&gt; product.number_sold = F(&apos;number_sold&apos;) + 1</span><br><span class="line">&gt;&gt;&gt; product.save()</span><br></pre></td></tr></table></figure></p><blockquote><p>指定要保存的字段</p></blockquote><p>&emsp;&emsp;如果传递给save() 的update_fields 关键字参数一个字段名称列表，那么将只有该列表中的字段会被更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">product.name = &apos;Name changed again&apos;</span><br><span class="line">product.save(update_fields=[&apos;name&apos;])</span><br></pre></td></tr></table></figure></p><blockquote><p>实例方法</p></blockquote><ul><li>__str__() 方法返回模型的一个友好的、人类可读的形式。</li><li>get_absolute_url() 方法告诉Django 如何计算对象的标准URL。</li><li>get_FOO_display():对于每个具有choices 的字段，每个对象将具有一个get_FOO_display() 方法，其中FOO 为该字段的名称。 这个方法返回该字段对“人类可读”的值。</li></ul><blockquote><p>QuerySet</p></blockquote><ul><li>QuerySet何时求值<a href="https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/models/querysets.html#when-querysets-are-evaluated" target="_blank" rel="noopener">官方文档</a></li><li>返回新的QuerySet的方法<a href="https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/models/querysets.html#methods-that-return-new-querysets" target="_blank" rel="noopener">官方文档</a></li><li>不返回QuerySet的方法<a href="https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/models/querysets.html#methods-that-do-not-return-querysets" target="_blank" rel="noopener">官方文档</a></li><li><p>聚合函数<a href="https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/models/querysets.html#aggregation-functions" target="_blank" rel="noopener">官方文档</a></p></li><li><p>exists()方法</p></li></ul><p>&emsp;&emsp;如果你需要知道是否存在至少一条记录（而不需要真实的对象），使用 exists() 将更加高效。</p><ul><li>aggregate和annotate</li></ul><p>&emsp;&emsp;博客：<a href="https://blog.csdn.net/AyoCross/article/details/68951413" target="_blank" rel="noopener">django中聚合aggregate和annotate GROUP BY的使用方法</a><br>&emsp;&emsp;官方文档：<a href="https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/models/expressions.html#aggregate-expressions" target="_blank" rel="noopener">Aggregate()表达式</a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href="https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/models/querysets.html#annotate" target="_blank" rel="noopener">annotate表达式</a></p><ul><li>order_by方法</li></ul><p>&emsp;&emsp; 升序是隐含的。 要随机订购，请使用”?”。</p><ul><li><p>values方法</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blog.objects.filter(name__startswith=&apos;Beatles&apos;).values()</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;返回一个返回字典的QuerySet，而不是使用模型实例作为一个迭代。每个字典表示一个对象，键对应于模型对象的属性名称。</p><ul><li>value_list()方法</li></ul><p>&emsp;&emsp;与values() 类似，只是在迭代时返回的是元组而不是字典。</p><blockquote><p>Django的Q对象和F对象</p></blockquote><p>&emsp;&emsp;博客：<a href="https://blog.csdn.net/qq_33733970/article/details/78403455?locationNum=3&amp;fps=1" target="_blank" rel="noopener">Python3之Django Web框架F对象，Q对象</a><br>&emsp;&emsp;官方文档：<a href="https://yiyibooks.cn/__trs__/xx/Django_1.11.6/ref/models/expressions.html#f-expressions" target="_blank" rel="noopener">F()表达式</a></p><blockquote><p>抽象模型</p></blockquote><ul><li><a href="http://www.liujiangblog.com/course/django/100" target="_blank" rel="noopener">刘江的个人博客</a></li><li>多表继承(默认隐含一个OneToOneField来链接子类与父类)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class Place(models.Model):</span><br><span class="line">    name = models.CharField(max_length=50)</span><br><span class="line">    address = models.CharField(max_length=80)</span><br><span class="line"></span><br><span class="line">class Restaurant(Place):</span><br><span class="line">    serves_hot_dogs = models.BooleanField(default=False)</span><br><span class="line">    serves_pizza = models.BooleanField(default=False)</span><br></pre></td></tr></table></figure></li></ul><p>Restaurant可以看做是Place的扩展,所以调用只能:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p = Place.objects.get(id=12)</span><br><span class="line"># 如果p也是一个Restaurant对象，那么下面的调用可以获得该Restaurant对象。</span><br><span class="line">&gt;&gt;&gt; p.restaurant</span><br><span class="line">&lt;Restaurant: ...&gt;</span><br></pre></td></tr></table></figure></p><p><strong>在多表继承的情况下，由于父类和子类都在数据库内有物理存在的表，父类的Meta类会对子类造成不确定的影响，因此，Django在这种情况下关闭了子类继承父类的Meta功能。这一点和抽象基类的继承方式有所不同。</strong></p><ul><li>代理模型<br>&emsp;&emsp;只需要将Meta中proxy的值设为True。<br>&emsp;&emsp;可以在代理模型中改变默认的排序方式和默认的manager管理器等等，而不会对原始模型产生影响。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class Person(models.Model):</span><br><span class="line">    first_name = models.CharField(max_length=30)</span><br><span class="line">    last_name = models.CharField(max_length=30)</span><br><span class="line"></span><br><span class="line">class MyPerson(Person):</span><br><span class="line">    class Meta:</span><br><span class="line">        proxy = True</span><br><span class="line"></span><br><span class="line">    def do_something(self):</span><br><span class="line">        # ...</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>字段查询</p></blockquote><p>&emsp;&emsp;字段查询其实就是filter()、exclude()和get()等方法的关键字参数。 其基本格式是：field__lookuptype=value，注意其中是双下划线。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;model梳理与难点剖析&quot;&gt;&lt;a href=&quot;#model梳理与难点剖析&quot; class=&quot;headerlink&quot; title=&quot;model梳理与难点剖析&quot;&gt;&lt;/a&gt;model梳理与难点剖析&lt;/h2&gt;&lt;h3 id=&quot;Python操作数据库&quot;&gt;&lt;a href=&quot;#Py
      
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django-Web框架本质探究</title>
    <link href="http://yoursite.com/2018/10/01/Django-Web%E6%A1%86%E6%9E%B6%E6%9C%AC%E8%B4%A8%E6%8E%A2%E7%A9%B6/"/>
    <id>http://yoursite.com/2018/10/01/Django-Web框架本质探究/</id>
    <published>2018-10-01T14:46:43.000Z</published>
    <updated>2019-03-27T07:21:50.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web框架本质"><a href="#Web框架本质" class="headerlink" title="Web框架本质"></a>Web框架本质</h2><p>&emsp;&emsp;对于所有的Web应用，本质上其实就是一个socket服务端，用户的浏览器其实就是一个socket客户端。对于真实开发中的python web程序来说，一般会分为两部分：<strong>服务器程序</strong>和<strong>应用程序</strong>。服务器程序负责对socket服务器进行封装，并在请求到来时，对请求的各种数据进行整理。应用程序则负责具体的逻辑处理。<br><a id="more"></a><br>&emsp;&emsp;为了方便应用程序的开发,就会出现许多的Web框架,而所有的web框架都需要与服务器程序配合才能为用户服务，所以web框架和web服务器之间需要标准化。</p><h2 id="一般Web框架架构"><a href="#一般Web框架架构" class="headerlink" title="一般Web框架架构"></a>一般Web框架架构</h2><p><img src="http://qiniu.rearib.top/20181804/1421-S.png" alt=""><br>&emsp;&emsp;大多数基于Python的web框架，如Django、tornado、flask、webpy都是在这个范围内进行增删裁剪的。例如Tornado用的是自己的异步非阻塞“WSGI”网关接口，Flask则只提供了最精简和基本的框架，Django则是直接使用了现成的WSGI，并实现了大部分功能，提供了大量的应用工具。</p><blockquote><p>MTV设计模式</p></blockquote><p><img src="http://qiniu.rearib.top/20181804/1436-C.png" alt=""></p><h3 id="WSGI-uwsgi-uWSGI区别"><a href="#WSGI-uwsgi-uWSGI区别" class="headerlink" title="WSGI-uwsgi-uWSGI区别"></a>WSGI-uwsgi-uWSGI区别</h3><p>&emsp;&emsp;<strong>WSGI</strong>：全称是Web Server Gateway Interface，WSGI不是服务器、python模块、框架、API或者任何软件，只是一种<strong>网关接口</strong>，它是一个Web服务器（如nginx，uWSGI等服务器）与web应用（如用Django框架写的程序）通信的一种规范。<br>&emsp;&emsp;<strong>uwsgi</strong>：一种传输协议，常用于在uWSGI服务器与其他网络服务器的数据通信。<br>&emsp;&emsp;<strong>uWSGI</strong>：是一个web服务器，实现了WSGI协议、uwsgi协议、http协议等。<br><img src="http://qiniu.rearib.top/20181830/0933-9.png" alt=""><br><strong>工作流程:</strong></p><ol><li>首先客户端请求服务资源。</li><li>nginx作为直接对外的服务接口,接收到客户端发送过来的http请求,会解包、分析。</li></ol><ul><li>如果是静态文件请求就根据nginx配置的静态文件目录，返回请求的资源。</li><li>如果是动态的请求,nginx就通过配置文件,将请求传递给uWSGI。</li></ul><ol><li>uWSGI将接收到的包进行处理，转发给wsgi。</li><li>wsgi根据请求调用django工程的某个文件或函数，处理完后django将返回值交给wsgi。</li><li>wsgi将返回值进行打包，转发给uWSGI。</li><li>uWSGI接收后转发给nginx,nginx最终将返回值返回给客户端(如浏览器)。</li></ol><p>&emsp;&emsp;第一级的nginx并不是必须的，uwsgi完全可以完成整个的和浏览器交互的流程，但是要考虑到某些情况：</p><ul><li>安全问题：程序不能直接被浏览器访问到，而是通过nginx。nginx只开放某个接口，这样运维人员在nginx上加上安全性的限制，可以达到保护程序的作用。</li><li>负载均衡问题：一个uwsgi很可能不够用，有了nginx做代理，一个nginx可以代理多台uwsgi完成uwsgi的负载均衡。</li><li>静态文件问题：用django或是uwsgi这种东西来负责静态文件的处理是很浪费的行为，而且他们本身对文件的处理也不如nginx好，所以整个静态文件的处理都直接由nginx完成，静态文件的访问完全不去经过uwsgi以及其后面的东西。</li></ul><h3 id="通过对Django的启动研究socket的启动"><a href="#通过对Django的启动研究socket的启动" class="headerlink" title="通过对Django的启动研究socket的启动"></a>通过对Django的启动研究socket的启动</h3><p>&emsp;&emsp;<strong>使用runserver是启动Django自带的WSGI服务器</strong>，常用于开发调试，分析Django的源码:</p><ul><li>执行<code>python manage.py runserver 127.0.0.1:8000</code>后，会在<code>\Django1.11.6\Lib\site-packages\django\core\management\__init__.py</code>中执行<code>self.fetch_command(subcommand).run_from_argv(self.argv)</code>。</li><li>调用<code>fetch_command</code>返回的<code>runserver</code>模块下的<code>Command</code>对象，其中Command对象是<code>&lt;django.contrib.staticfiles.management.commands.runserver.Command object&gt;</code>，继续调用<code>Command</code>对象的<code>run_from_argv</code>方法，然后执行<code>self.handle(*args, **options)</code>调用<code>Command</code>下的<code>handle</code>。</li><li><p>从<code>Command.handle</code>–&gt;<code>Command.run</code>–&gt;<code>Command.inner_run</code>，并在inner_run中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handler = self.get_handler(*args, **options)</span><br><span class="line">run(self.addr, int(self.port), handler,</span><br><span class="line">    ipv6=self.use_ipv6, threading=threading, server_cls=self.server_cls)</span><br></pre></td></tr></table></figure></li><li><p>在<code>get_handler</code>中会在通过<code>wsgi.py</code>返回<code>WSGIHandler()</code>，继承于<code>class WSGIHandler(base.BaseHandler)</code>，然后会执行run:</p></li><li><p>而run就是启动一个线程一直监听，其中<code>wsgi_handler</code>是<code>WSGIHandler()</code>，<code>server_cls=WSGIServer</code>是继承于<code>class WSGIServer(simple_server.WSGIServer, object)</code>，而<code>simple_server</code>来自于<code>from wsgiref import simple_server</code>，而wsgiref就是Python内置的一个WSGI服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def run(addr, port, wsgi_handler, ipv6=False, threading=False, server_cls=WSGIServer):</span><br><span class="line">    server_address = (addr, port)</span><br><span class="line">    if threading:</span><br><span class="line">        httpd_cls = type(str(&apos;WSGIServer&apos;), (socketserver.ThreadingMixIn, server_cls), &#123;&#125;)</span><br><span class="line">    else:</span><br><span class="line">        httpd_cls = server_cls</span><br><span class="line">    httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)</span><br><span class="line">    if threading:</span><br><span class="line">        # ThreadingMixIn.daemon_threads indicates how threads will behave on an</span><br><span class="line">        # abrupt shutdown; like quitting the server by the user or restarting</span><br><span class="line">        # by the auto-reloader. True means the server will not wait for thread</span><br><span class="line">        # termination before it quits. This will make auto-reloader faster</span><br><span class="line">        # and will prevent the need to kill the server manually if a thread</span><br><span class="line">        # isn&apos;t terminating correctly.</span><br><span class="line">        httpd.daemon_threads = True</span><br><span class="line">    httpd.set_app(wsgi_handler)</span><br><span class="line">    httpd.serve_forever()</span><br></pre></td></tr></table></figure></li><li><p>wsgiref是用纯Python编写的WSGI服务器的参考实现。所谓“参考实现”是指该实现完全符合WSGI标准，但是不考虑任何运行效率，仅供开发和测试使用。</p></li></ul><p>参考文章:</p><ul><li><a href="https://www.cnblogs.com/luchuangao/articles/7374415.html" target="_blank" rel="noopener">由django.setup()引发得对Django启动过程解读</a></li><li><a href="http://www.javabin.cn/2018/django_start.html" target="_blank" rel="noopener">Django 源码学习之搭建环境和django启动流程(一)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Web框架本质&quot;&gt;&lt;a href=&quot;#Web框架本质&quot; class=&quot;headerlink&quot; title=&quot;Web框架本质&quot;&gt;&lt;/a&gt;Web框架本质&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;对于所有的Web应用，本质上其实就是一个socket服务端，用户的浏览器其实就是一个socket客户端。对于真实开发中的python web程序来说，一般会分为两部分：&lt;strong&gt;服务器程序&lt;/strong&gt;和&lt;strong&gt;应用程序&lt;/strong&gt;。服务器程序负责对socket服务器进行封装，并在请求到来时，对请求的各种数据进行整理。应用程序则负责具体的逻辑处理。&lt;br&gt;
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>python-队列与生产者消费者模式</title>
    <link href="http://yoursite.com/2018/09/21/Python-%E9%98%9F%E5%88%97%E4%B8%8E%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/21/Python-队列与生产者消费者模式/</id>
    <published>2018-09-21T11:47:08.000Z</published>
    <updated>2018-12-07T07:55:04.509Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。<br><a id="more"></a><br>1、为什么要使用生产者和消费者模式<br>&emsp;&emsp;在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。<br>2、什么是生产者消费者模式<br>&emsp;&emsp;生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>&emsp;&emsp;队列（Queue）:在多个线程之间安全的交换数据信息，队列在多线程编程中特别有用<br><strong>队列的好处：</strong></p><ul><li>提高双方的效率，你只需要把数据放到队列中，中间去干别的事情。</li><li>完成了程序的解耦性，两者关系依赖性没有不大。</li></ul><h2 id="队列的类型："><a href="#队列的类型：" class="headerlink" title="队列的类型："></a>队列的类型：</h2><ul><li>lass queue.Queue(maxsize=0) <strong>先进先出，后进后出</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue()   # 生成先入先出队列实例</span><br><span class="line">q.put(1)            # 先放进1，再放入2</span><br><span class="line">q.put(2)</span><br><span class="line">print(q.get())  </span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">1</span><br></pre></td></tr></table></figure></li><li>class queue.LifoQueue(maxsize=0) <strong>先进后出，后进先出</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.LifoQueue()   # 生成先入先出队列实例</span><br><span class="line">q.put(1)            # 先放进1，再放入2</span><br><span class="line">q.put(2)</span><br><span class="line">print(q.get())  </span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">2</span><br></pre></td></tr></table></figure></li><li>class queue.PriorityQueue(maxsize=0)<br><strong>优先级来取数据。存放数据的格式 : Queue.put((priority_number,data))，priority_number越小，优先级越高，data代表存入的值</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.PriorityQueue()</span><br><span class="line">q.put((1, &quot;d1&quot;))</span><br><span class="line">q.put((-1, &quot;d2&quot;))</span><br><span class="line">q.put((6, &quot;d3&quot;))</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get()) </span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">(-1, &apos;d2&apos;)</span><br><span class="line">(1, &apos;d1&apos;)</span><br><span class="line">(6, &apos;d3&apos;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>maxsize代表这个队列最大能够put的长度，如果xsize &lt;= 0，则队列大小为无限大。</strong></p><h2 id="队列的内置方法"><a href="#队列的内置方法" class="headerlink" title="队列的内置方法"></a>队列的内置方法</h2><ul><li><p>exception queue.Empty<br><strong>队列中的数据为空时，就会抛出这个异常。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue()</span><br><span class="line">q.get(block=False)   #获取不到的时候</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 161, in get</span><br><span class="line">    raise Empty</span><br><span class="line">queue.Empty</span><br></pre></td></tr></table></figure></li><li><p>exception queue.Full<br><strong>当队列中满了以后，再放数据的话，就会抛出此异常。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue(maxsize=1)  </span><br><span class="line">q.put(1)</span><br><span class="line">q.put(1,block=False)</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 184, in put_nowait</span><br><span class="line">    return self.put(item, block=False)</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 130, in put</span><br><span class="line">    raise Full</span><br><span class="line">queue.Full</span><br></pre></td></tr></table></figure></li><li><p>Queue.qsize()<br><strong>查看队列的大小。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue()  </span><br><span class="line">q.put(20)</span><br><span class="line">q.put(21)</span><br><span class="line">print(q.qsize())   #查看队列的大小</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">2</span><br></pre></td></tr></table></figure></li><li><p>Queue.empty()<br><strong>队列如果为空返回True，不为空返回False。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue()  </span><br><span class="line">q.put(1)</span><br><span class="line">print(q.empty())   #查看队列是否为空</span><br><span class="line">q.get()</span><br><span class="line">print(q.empty())   #查看队列是否为空</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure></li><li><p>Queue.full()<br><strong>队列如果满了，返回True，没有满返回False。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue(maxsize=1)  </span><br><span class="line">q.put(1)</span><br><span class="line">print(q.full())   #查看队列是否满</span><br><span class="line">q.get()</span><br><span class="line">print(q.full())   #查看队列是否满</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li><li><p>Queue.put(item,block=True,timeout=None)<br><strong>把数据插入队列中。block参数默认为true，timeout默认值是None。如果blcok为false的话，那么在put时候超过设定的maxsize的值，就会报full 异常。如果timeout设置值得话，说明put值得个数超过maxsize值，那么会在timeout几秒之后抛出full异常。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue(maxsize=1)  #是定队列的大小为1</span><br><span class="line">q.put(1)</span><br><span class="line">q.put(1,block=False)   #block不会阻塞，会full异常</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 130, in put</span><br><span class="line">    raise Full</span><br><span class="line">queue.Full</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue(maxsize=1)  #是定队列的大小为1</span><br><span class="line">q.put(1)</span><br><span class="line">q.put(1,timeout=1)    #超过1秒，则会报full异常</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 130, in put</span><br><span class="line">    raise Full</span><br><span class="line">queue.Full</span><br></pre></td></tr></table></figure></li><li><p>Queue.put_nowait(item)<br><strong>等同于Queue.put(item,block=False)或者是Queue.put(item,False)。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue(maxsize=1)</span><br><span class="line">q.put(1)</span><br><span class="line">q.put_nowait(1)   #等同于q.put(1,block=False)</span><br><span class="line">#输出</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 184, in put_nowait</span><br><span class="line">    return self.put(item, block=False)</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 130, in put</span><br><span class="line">    raise Full</span><br><span class="line">queue.Full</span><br></pre></td></tr></table></figure></li><li><p>Queue.get(block=True,timeout=None)<br><strong>移除并返回队列中的序列。参数block=true并且timeout=None。如果block=false的话，那么队列为空的情况下，就直接Empty异常。如果timeout有实际的值，这个时候队列为空，执行get的时候，则时隔多长时间则报出Empty的异常。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue()</span><br><span class="line">q.put(1)</span><br><span class="line">q.get()</span><br><span class="line">q.get(block=False)    #获取不到值，直接抛Empty异常</span><br><span class="line">#输出</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 161, in get</span><br><span class="line">    raise Empty</span><br><span class="line">queue.Empty</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue()</span><br><span class="line">q.put(1)</span><br><span class="line">q.get()</span><br><span class="line">q.get(timeout=1)    #设置超时时间，抛出Empty异常</span><br><span class="line">#输出</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 172, in get</span><br><span class="line">    raise Empty</span><br><span class="line">queue.Empty</span><br></pre></td></tr></table></figure></li><li><p>Queue.get_nowait(item)<br><strong>等同于Queue.get(block=False)或者Queue.get(False)。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue()</span><br><span class="line">q.put(1)</span><br><span class="line">q.get()</span><br><span class="line">q.get_nowait()   #等同于q.get(block=False)</span><br><span class="line">#输出</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 192, in get_nowait</span><br><span class="line">    return self.get(block=False)</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 161, in get</span><br><span class="line">    raise Empty</span><br><span class="line">queue.Empty</span><br></pre></td></tr></table></figure></li><li><p>Queue.task_done()<br><strong>get()用于获取任务，task_done()则是用来告诉队列之前获取的任务已经处理完成</strong></p></li><li><p>Queue.join()<br><strong>block(阻塞)直到queue（队列）被消费完毕,如果生产者生产10个包子，那么要等消费者把这个10个包子全部消费完毕，生产者才能继续往下执行。</strong></p></li></ul><p><strong>task_done和jion的理解</strong></p><h2 id="生成者消费者模型例子"><a href="#生成者消费者模型例子" class="headerlink" title="生成者消费者模型例子"></a>生成者消费者模型例子</h2><h3 id="生产者生产完毕，消费者再消费例子："><a href="#生产者生产完毕，消费者再消费例子：" class="headerlink" title="生产者生产完毕，消费者再消费例子："></a>生产者生产完毕，消费者再消费例子：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import queue</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def producer():</span><br><span class="line">    for i in range(10):</span><br><span class="line">        q.put(&quot;骨头 %s&quot; % i)</span><br><span class="line"> </span><br><span class="line">    print(&quot;开始等待所有的骨头被取走...&quot;)</span><br><span class="line">    q.join()  # 等待这个骨头队列被消费完毕</span><br><span class="line">    print(&quot;所有的骨头被取完了...&quot;)</span><br><span class="line"></span><br><span class="line">def consumer(n):</span><br><span class="line">    while q.qsize() &gt; 0:</span><br><span class="line">        print(&quot;%s 取到&quot; % n, q.get())</span><br><span class="line">        q.task_done()  # 每去到一个骨头，便告知队列这个任务执行完了</span><br><span class="line"> </span><br><span class="line">q = queue.Queue()</span><br><span class="line"> </span><br><span class="line">p = threading.Thread(target=producer,)</span><br><span class="line">p.start()</span><br><span class="line"> </span><br><span class="line">c1 = consumer(&quot;QQ&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/python-队列/20181026091046063.png" alt=""></p><h3 id="边生产边消费的模型例子"><a href="#边生产边消费的模型例子" class="headerlink" title="边生产边消费的模型例子"></a>边生产边消费的模型例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import time,random</span><br><span class="line">import queue,threading</span><br><span class="line">q = queue.Queue()</span><br><span class="line"> </span><br><span class="line">def producer(name):</span><br><span class="line">  count = 0</span><br><span class="line"> </span><br><span class="line">  while count &lt; 10:</span><br><span class="line">    time.sleep(random.randrange(3))</span><br><span class="line">    q.put(count)  # 在队列里放包子</span><br><span class="line">    print&apos;Producer %s has produced %s baozi..&apos; (% (name, count))</span><br><span class="line">    count += 1</span><br><span class="line"> </span><br><span class="line">def consumer(name):</span><br><span class="line">  count = 0</span><br><span class="line">  while count &lt; 10:</span><br><span class="line">    time.sleep(random.randrange(4))</span><br><span class="line">    if not q.empty():  # 如果还有包子</span><br><span class="line">        data = q.get()  # 就继续获取保证</span><br><span class="line">        print(data)</span><br><span class="line">        print(&apos;Consumer %s has eat %s baozi...&apos; % (name, data))</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;-----no baozi anymore----&quot;)</span><br><span class="line">    count += 1</span><br><span class="line"> </span><br><span class="line">p1 = threading.Thread(target=producer, args=(&apos;A&apos;,))</span><br><span class="line">c1 = threading.Thread(target=consumer, args=(&apos;B&apos;,))</span><br><span class="line">p1.start()</span><br><span class="line">c1.start()</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/python-队列/20181026091459130.png" alt=""><br>流程图:<br><img src="http://qiniu.rearib.top/python-队列/20181026091531607.png" alt=""></p><ul><li>生产者生产，消费者消费。</li><li>消费者每消费一次，都要去执行以下task_done()方法，来告诉消费者已经消费成功，相当于吃完饭，消费者应该给钱了。</li><li>消费者每消费一次，则队列中计数器会做减1操作。</li><li>当队列中的计数器为0的时候，则生产者不阻塞，继续执行，不为0的时候，则阻塞，直到消费者消费完毕为止。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python-RabbitMQ 安装、基本示例、轮询机制</title>
    <link href="http://yoursite.com/2018/09/21/Python-RabbitMQ%20%E5%AE%89%E8%A3%85%E3%80%81%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B%E3%80%81%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/09/21/Python-RabbitMQ 安装、基本示例、轮询机制/</id>
    <published>2018-09-21T05:23:47.000Z</published>
    <updated>2018-12-07T07:52:15.130Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;MQ全称为Message Queue, 是一种分布式应用程序的的通信方法，它是<strong>消费-生产者模型的一个典型的代表</strong>，producer往消息队列中不断写入消息，而另一端consumer则可以读取或者订阅队列中的消息。RabbitMQ是MQ产品的典型代表，是一款基于AMQP协议可复用的企业消息系统。业务上，可以实现服务提供者和消费者之间的数据解耦，提供高可用性的消息传输机制，在实际生产中应用相当广泛。本文意在介绍Rabbitmq的基本原理，以及在python下的各种应用。<br><a id="more"></a></p><h2 id="python中的queue概念："><a href="#python中的queue概念：" class="headerlink" title="python中的queue概念："></a>python中的queue概念：</h2><ul><li>线程queue：只是用于多个线程之间，进行数据同步交互的。</li><li>进程queue：只是用户父进程与子进程进行交互，或者属于同一父进程下的多个子进程进行交互。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;MQ全称为Message Queue, 是一种分布式应用程序的的通信方法，它是&lt;strong&gt;消费-生产者模型的一个典型的代表&lt;/strong&gt;，producer往消息队列中不断写入消息，而另一端consumer则可以读取或者订阅队列中的消息。RabbitMQ是MQ产品的典型代表，是一款基于AMQP协议可复用的企业消息系统。业务上，可以实现服务提供者和消费者之间的数据解耦，提供高可用性的消息传输机制，在实际生产中应用相当广泛。本文意在介绍Rabbitmq的基本原理，以及在python下的各种应用。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python-事件驱动和IO介绍</title>
    <link href="http://yoursite.com/2018/09/18/Python-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%92%8CIO%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2018/09/18/Python-事件驱动和IO介绍/</id>
    <published>2018-09-18T03:33:42.000Z</published>
    <updated>2019-03-27T06:55:47.449Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;通常，我们写服务器处理模型的程序时，有以下几种模型：</p><ol><li>每收到一个请求，创建一个新的进程，来处理该请求；</li><li>每收到一个请求，创建一个新的线程，来处理该请求；</li><li>每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求<a id="more"></a>&emsp;&emsp;上面的几种方式，各有千秋：</li></ol><ul><li>第1中方法，由于创建新的进程的开销比较大，所以，会导致服务器性能比较差,但实现比较简单。</li><li>第2种方式，由于要涉及到线程的同步，有可能会面临死锁等问题。</li><li>第3种方式，在写应用程序代码时，逻辑比前面两种都复杂。<br>&emsp;&emsp;综合考虑各方面因素，一般普遍认为第（3）种方式是大多数网络服务器采用的方式<h2 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h2>&emsp;&emsp;在UI编程中，常常要对鼠标点击进行相应，首先如何获得鼠标点击呢？</li></ul><blockquote><p>方式一：创建一个线程，该线程一直循环检测是否有鼠标点击，那么这个方式有以下几个缺点：</p></blockquote><ol><li>CPU资源浪费，可能鼠标点击的频率非常小，但是扫描线程还是会一直循环检测，这会造成很多的CPU资源浪费；如果扫描鼠标点击的接口是阻塞的呢？</li><li>如果是堵塞的，又会出现下面这样的问题，如果我们不但要扫描鼠标点击，还要扫描键盘是否按下，由于扫描鼠标时被堵塞了，那么可能永远不会去扫描键盘；</li><li>如果一个循环需要扫描的设备非常多，这又会引来响应时间的问题；<br>所以，该方式是非常不好的。</li></ol><blockquote><p>方式二：就是事件驱动模型,目前大部分的UI编程都是事件驱动模型，如很多UI平台都会提供onClick()事件，这个事件就代表鼠标按下事件。事件驱动模型大体思路如下：</p></blockquote><ol><li>有一个事件（消息）队列；</li><li>鼠标按下时，往这个队列中增加一个点击事件（消息）；</li><li>有个循环，不断从队列取出事件，根据不同的事件，调用不同的函数，如onClick()、onKeyDown()等；</li><li>事件（消息）一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数；<br><img src="http://qiniu.rearib.top/20181829/2317-9.png" alt=""></li></ol><p>&emsp;&emsp;事件驱动编程是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。另外两种常见的编程范式是（单线程）同步以及多线程编程。</p><p>&emsp;&emsp;让我们用例子来比较和对比一下<strong>单线程、多线程以及事件驱动编程模型</strong>。下图展示了随着时间的推移，这三种模式下程序所做的工作。这个程序有3个任务需要完成，每个任务都在等待I/O操作时阻塞自身。阻塞在I/O操作上所花费的时间已经用灰色框标示出来了。</p><p><img src="http://qiniu.rearib.top/20181829/2320-H.png" alt=""></p><p>&emsp;&emsp;在单线程同步模型中，任务按照顺序执行。<strong>如果某个任务因为I/O而阻塞，其他所有的任务都必须等待，直到它完成之后它们才能依次执行</strong>。这种明确的执行顺序和串行化处理的行为是很容易推断得出的。如果任务之间并没有互相依赖的关系，但仍然需要互相等待的话这就使得程序不必要的降低了运行速度。</p><p>&emsp;&emsp;在多线程版本中，这3个任务分别在独立的线程中执行。这些线程由操作系统来管理，在多处理器系统上可以并行处理，或者在单处理器系统上交错执行。这使得当某个线程阻塞在某个资源的同时其他线程得以继续执行。与完成类似功能的同步程序相比，这种方式更有效率，<strong>但程序员必须写代码来保护共享资源，防止其被多个线程同时访问。</strong>多线程程序更加难以推断，因为这类程序不得不通过线程同步机制如锁、可重入函数、线程局部存储或者其他机制来处理线程安全问题，如果实现不当就会导致出现微妙且令人痛不欲生的bug。</p><p>&emsp;&emsp;在事件驱动版本的程序中，3个任务交错执行，但仍然在一个单独的线程控制中。当处理I/O或者其他昂贵的操作时，注册一个回调到事件循环中，然后当I/O操作完成时继续执行。回调描述了该如何处理某个事件。事件循环轮询所有的事件，当事件到来时将它们分配给等待处理事件的回调函数。这种方式让程序尽可能的得以执行而不需要用到额外的线程。事件驱动型程序比多线程程序更容易推断出行为，因为程序员不需要关心线程安全问题。</p><p>&emsp;&emsp;当我们面对如下的环境时，事件驱动模型通常是一个好的选择：</p><ul><li>程序中有许多任务，而且任务之间高度独立（因此它们不需要互相通信，或者等待彼此）,而且在等待事件到来时，某些任务会阻塞。</li><li>当应用程序需要在任务间共享可变的数据时，这也是一个不错的选择，因为这里不需要采用同步处理。</li></ul><blockquote><p><strong>网络应用程序通常都有上述这些特点，这使得它们能够很好的契合事件驱动编程模型。</strong></p></blockquote><p>&emsp;&emsp;上面的事件驱动模型中，只要一遇到IO就注册一个事件，然后主程序就可以继续干其它的事情了，只到io处理完毕后，继续恢复之前中断的任务，这本质上是怎么实现的呢？<br><img src="http://qiniu.rearib.top/20181829/2326-A.png" alt=""></p><h2 id="阻塞IO-非阻塞IO-同步IO-异步IO介绍"><a href="#阻塞IO-非阻塞IO-同步IO-异步IO介绍" class="headerlink" title="阻塞IO,非阻塞IO,同步IO,异步IO介绍"></a>阻塞IO,非阻塞IO,同步IO,异步IO介绍</h2><p>&emsp;&emsp;对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p><ol><li>等待数据准备 (Waiting for the data to be ready)</li><li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li></ol><p>&emsp;&emsp;正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。</p><ul><li>阻塞 I/O（blocking IO）</li><li>非阻塞 I/O（nonblocking IO）</li><li>I/O 多路复用（ IO multiplexing）</li><li>信号驱动 I/O（ signal driven IO）</li><li>异步 I/O（asynchronous IO）</li></ul><p><strong>注：由于signal driven IO在实际中并不常用，所以只提及剩下的四种IO Model。</strong></p><h3 id="1、概念说明"><a href="#1、概念说明" class="headerlink" title="1、概念说明"></a>1、概念说明</h3><blockquote><p>1.1、用户空间与内核空间</p></blockquote><p>&emsp;&emsp;现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。<strong>操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。</strong>为了保证用户进程不能直接操作内核（kernel），保证内核的安全，<strong>操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</strong>针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><blockquote><p>1.2、进程切换</p></blockquote><p>&emsp;&emsp;为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>&emsp;&emsp;从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ol><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ol><p>&emsp;&emsp;总而言之就是很耗资源，具体的可以参考这篇文章：<a href="http://guojing.me/linux-kernel-architecture/posts/process-switch/" target="_blank" rel="noopener">进程切换</a></p><p>&emsp;&emsp;注：进程控制块（Processing Control Block），是操作系统核心中一种数据结构，主要表示进程状态。其作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位或与其它进程并发执行的进程。或者说，OS是根据PCB来对并发执行的进程进行控制和管理的。 PCB通常是系统内存占用区中的一个连续存区，它存放着操作系统用于描述进程情况及控制进程运行所需的全部信息</p><blockquote><p>1.3、进程阻塞</p></blockquote><p>&emsp;&emsp;正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p><blockquote><p>1.4、文件描述符fd</p></blockquote><p>&emsp;&emsp;文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p><p>&emsp;&emsp;文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><blockquote><p>1.5、缓存I/O</p></blockquote><p>&emsp;&emsp;缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p>&emsp;&emsp;缓存 I/O 的缺点：数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h3 id="五种IO网络模式"><a href="#五种IO网络模式" class="headerlink" title="五种IO网络模式"></a>五种IO网络模式</h3><blockquote><p>阻塞 I/O（blocking IO）</p></blockquote><p>&emsp;&emsp;在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：<br><img src="http://qiniu.rearib.top/20181829/2336-5.png" alt=""><br>&emsp;&emsp;当用户进程调用了recvfrom这个系统调用，kernel（内核）就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><p><strong>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</strong></p><blockquote><p>非阻塞 I/O（nonblocking IO）</p></blockquote><p>&emsp;&emsp;linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：<br><img src="http://qiniu.rearib.top/20181829/2338-s.png" alt=""></p><p> &emsp;&emsp;当用户进程发出read操作时，如果kernel（内核）中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><p><strong>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</strong></p><blockquote><p>I/O 多路复用（ IO multiplexing）</p></blockquote><p> &emsp;&emsp;IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。<br><img src="http://qiniu.rearib.top/20181829/2342-E.png" alt=""></p><p>&emsp;&emsp;当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel（内核）拷贝到用户进程。</p><p>&emsp;&emsp;这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p><p>&emsp;&emsp;所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p><p>&emsp;&emsp;在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p><p><strong>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</strong></p><blockquote><p>异步 I/O（asynchronous IO）</p></blockquote><p>&emsp;&emsp;Linux下的asynchronous IO其实用得很少。先看一下它的流程：<br><img src="http://qiniu.rearib.top/20181829/2345-B.png" alt=""><br>&emsp;&emsp;用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel（内核）会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><blockquote><p>blocking和non-blocking的区别</p></blockquote><p>&emsp;&emsp;调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel（内核）还准备数据的情况下会立刻返回。</p><blockquote><p>synchronous IO和asynchronous IO的区别</p></blockquote><p>&emsp;&emsp;两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p><p>&emsp;&emsp;有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p><p>&emsp;&emsp;而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p><p><strong>各个IO Model的比较如图所示：</strong><br><img src="http://qiniu.rearib.top/20181829/2348-D.png" alt=""></p><h2 id="IO多路复用（select、poll、epoll）介绍及select、epoll的实现"><a href="#IO多路复用（select、poll、epoll）介绍及select、epoll的实现" class="headerlink" title="IO多路复用（select、poll、epoll）介绍及select、epoll的实现"></a>IO多路复用（select、poll、epoll）介绍及select、epoll的实现</h2><p>&emsp;&emsp;IO多路复用中包括 select、pool、epoll，这些都属于同步，还不属于异步</p><h3 id="1、select"><a href="#1、select" class="headerlink" title="1、select"></a>1、select</h3><p>&emsp;&emsp;select最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。</p><p>&emsp;&emsp;select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，事实上从现在看来，这也是它所剩不多的优点之一。</p><p>&emsp;&emsp;select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。</p><p>&emsp;&emsp;另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。</p><h3 id="2、poll"><a href="#2、poll" class="headerlink" title="2、poll"></a>2、poll</h3><p>&emsp;&emsp;poll在1986年诞生于System V Release 3，它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。</p><p>&emsp;&emsp;poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p><p>&emsp;&emsp;另外，select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll()的时候将再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。</p><h3 id="3、epoll"><a href="#3、epoll" class="headerlink" title="3、epoll"></a>3、epoll</h3><p>&emsp;&emsp;直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll，它几乎具备了之前所说的一切优点，被公认为Linux2.6下性能最好的多路I/O就绪通知方法。</p><p>&emsp;&emsp;epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。</p><p>&emsp;&emsp;epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。</p><p>&emsp;&emsp;另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。<br><img src="http://qiniu.rearib.top/20181829/2352-b.png" alt=""></p><h3 id="select-IO多路复用"><a href="#select-IO多路复用" class="headerlink" title="select IO多路复用"></a>select IO多路复用</h3><p>&emsp;&emsp;Python的select()方法直接调用操作系统的IO接口，它监控sockets,open files, and pipes(所有带fileno()方法的文件句柄)何时变成readable 和writeable, 或者通信错误，select()使得同时监控多个连接变的简单，并且这比写一个长循环来等待和监控多客户端连接要高效，因为select直接通过操作系统提供的C的网络接口进行操作，而不是通过Python的解释器。</p><p>&emsp;&emsp;select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样会造成效率的降低</p><p><a href="https://www.cnblogs.com/Keep-Ambition/p/7598740.html" target="_blank" rel="noopener">继续看</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;通常，我们写服务器处理模型的程序时，有以下几种模型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每收到一个请求，创建一个新的进程，来处理该请求；&lt;/li&gt;
&lt;li&gt;每收到一个请求，创建一个新的线程，来处理该请求；&lt;/li&gt;
&lt;li&gt;每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python-协程</title>
    <link href="http://yoursite.com/2018/09/17/Python-%E5%8D%8F%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/09/17/Python-协程/</id>
    <published>2018-09-17T11:36:42.000Z</published>
    <updated>2018-12-07T07:54:25.587Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;协程，又称微线程。英文名Coroutine。一句话说明什么是协程：协程是一种用户态的轻量级线程。<br>&emsp;&emsp;协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：<br>&emsp;&emsp;协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。<br><a id="more"></a></p><h2 id="协程的好处："><a href="#协程的好处：" class="headerlink" title="协程的好处："></a>协程的好处：</h2><ul><li>无需线程上下文切换的开销</li><li>无需原子操作锁定及同步的开销(协程是单线程,串行)</li><li>“原子操作(atomic operation)是不需要synchronized”，所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序是不可以被打乱，或者切割掉只执行部分。视作整体是原子性的核心。</li><li>方便切换控制流，简化编程模型</li><li>高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</li></ul><h2 id="协程的缺点："><a href="#协程的缺点：" class="headerlink" title="协程的缺点："></a>协程的缺点：</h2><ul><li>无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。</li><li><p>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序。</p><h2 id="yield实现协程"><a href="#yield实现协程" class="headerlink" title="yield实现协程"></a>yield实现协程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def consumer(name):</span><br><span class="line">    print(&quot;---&gt;starting eating baozi...&quot;)</span><br><span class="line">    while True:</span><br><span class="line">        new_baozi = yield   # yield设置生成器</span><br><span class="line">        print(&quot;[&#123;0&#125;] is eating baozi &#123;1&#125;&quot;.format(name, new_baozi))</span><br><span class="line"> </span><br><span class="line">def producer():</span><br><span class="line">    r = con.__next__()  # 调用生成器开始执行</span><br><span class="line">    r = con2.__next__()</span><br><span class="line">    n = 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        print(&quot;producer is making baozi &#123;0&#125;&quot;.format(n))</span><br><span class="line">        con.send(n)  # 唤醒生成器，并且向生成器传值</span><br><span class="line">        con2.send(n)</span><br><span class="line">        n += 1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    con = consumer(&quot;c1&quot;)    # 创建一个生成器c1,但是不会开始执行</span><br><span class="line">    con2 = consumer(&quot;c2&quot;)   # 创建一个生产器C2,但是不会开始执行</span><br><span class="line">    p = producer()</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/python-协程/20181029094850452.png" alt=""></p></li><li><p><strong>send有两个作用？</strong><br>1.唤醒生产器<br>2.给yield传一个值，就是yield接收到的这个值。这个说明yield在被唤醒的时候可以接收数据。</p></li><li><strong>怎么实现我们的单线程实现并发的效果呢？</strong><br>&emsp;&emsp;<font color="red">遇到IO操作就切换</font>，IO比较耗时，协程之所以能处理大并发，就是IO操作会挤掉大量的时间。<font color="red">没有IO操作的话，整个程序只有cpu在运算了</font>，因为cpu很快，所以你感觉是在并发执行的。</li><li><strong>IO操作完成了，程序什么时候切回去</strong>？<br>&emsp;&emsp;IO操作一旦完成，我们就自动切回去。</li><li><strong>IO是什么?</strong><br>&emsp;&emsp;Python中的io模块是用来处理各种类型的I/O操作流。主要有三种类型的I/O类型：文本I/O(Text I/O)，二进制I/O(Binary I/O)和原始I/O(Raw I/O)。它们都是通用类别，每一种都有不同的后备存储。属于这些类别中的任何一个的具体对象称为文件对象，其他常用的术语为流或者类文件对象。<br>&emsp;&emsp;除了它的类别，每一种具体的流对象也具有各种功能：它仅仅允许读，或者仅仅允许写，或者既能读又能写。它也允许任意随机访问（向前或者向后寻找任何位置），或者仅仅顺序访问（例如在套接字或管道中）。<br>&emsp;&emsp;所有的流对于提供给它们的数据的数据类型都很严格。例如，如果用一个二进制流的write（）方法写一个字符类型的数据，那么将会触发一个TypeError错误。用文本流的write()方法来写字节对象数据也是一样的，会触发该错误。<h2 id="手动实现切换IO"><a href="#手动实现切换IO" class="headerlink" title="手动实现切换IO"></a>手动实现切换IO</h2>&emsp;&emsp;Greenlet是python的一个C扩展，来源于Stackless python，旨在提供可自行调度的‘微线程’， 即协程。它可以使你在任意函数之间随意切换，而不需把这个函数先声明为generator<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from greenlet import greenlet</span><br><span class="line"> </span><br><span class="line">def test1():</span><br><span class="line">    print(12)</span><br><span class="line">    gr2.switch()  # 切换到test2</span><br><span class="line">    print(34)</span><br><span class="line">    gr2.switch()   # 切换到test2</span><br><span class="line"> </span><br><span class="line">def test2():</span><br><span class="line">    print(56)</span><br><span class="line">    gr1.switch()   # 切换到test1</span><br><span class="line">    print(78)</span><br><span class="line"> </span><br><span class="line">gr1 = greenlet(test1)  # 启动一个协程</span><br><span class="line">gr2 = greenlet(test2)</span><br><span class="line">gr1.switch()   # 切换到test1，这个switch不写的话，会无法输出打印</span><br></pre></td></tr></table></figure><img src="http://qiniu.rearib.top/python-协程/20181029101816499.png" alt=""><br><strong>小结：</strong></li><li>cpu只认识线程，而不认识协程，协程是用户自己控制的，cpu根本都不知道它们的存在。</li><li>线程的上下文切换保存在cpu的寄存器中，但是协程拥有自己的寄存上下文和栈。</li><li>协程是串行的，无需锁。</li><li>虽然greenlet确实用着比generator（生成器）还简单了，但好像还没有解决一个问题，就是遇到IO操作，自动切换，对不对？<h2 id="协程遇IO操作自动切换"><a href="#协程遇IO操作自动切换" class="headerlink" title="协程遇IO操作自动切换"></a>协程遇IO操作自动切换</h2>&emsp;&emsp;接下来就说说如何遇到IO就自动切换切换，Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import gevent</span><br><span class="line"> </span><br><span class="line">def foo():</span><br><span class="line">    print(&quot;Running in foo&quot;)</span><br><span class="line">    gevent.sleep(3)  # 模仿io操作，一遇到io操作就切换</span><br><span class="line">    print(&quot;Explicit context switch to foo again&quot;)</span><br><span class="line"> </span><br><span class="line">def bar():</span><br><span class="line">    print(&quot;Explicit context to bar&quot;)</span><br><span class="line">    gevent.sleep(1)</span><br><span class="line">    print(&quot;Implicit context switch back to bar&quot;)</span><br><span class="line"> </span><br><span class="line">def fun3():</span><br><span class="line">    print(&quot;running fun3&quot;)</span><br><span class="line">    gevent.sleep(0)   # 虽然是0秒，但是会触发一次切换</span><br><span class="line">    print(&quot;running fun3 again&quot;)</span><br><span class="line"> </span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(foo),  # 生成协程</span><br><span class="line">    gevent.spawn(bar),</span><br><span class="line">    gevent.spawn(fun3)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><img src="http://qiniu.rearib.top/python-协程/20181029103346052.png" alt=""><br>&emsp;&emsp;当foo遇到sleep(3)的时候，切自动切换到bar函数，执行遇到sleep(1)的时候自动切换到fun3函数，遇到sleep(0)又自动切换到foo。这个时候sleep(3)还没有执行完毕，又切换到bar的sleep(1)这边，发现又没有执行完毕，就有执行fun3这边，发现sleep(0)执行完毕，则继续执行，然后又切换到foo,发现sleep(3)又没有执行完毕，就切换到bar的sleep(1)这边，发现执行完了，有切回到foo这边，执行完毕。<br>&emsp;&emsp;<strong>比如说你现在有50处IO，然后总共加起来串行的的话，要花100秒，但是50处IO最长的那个IO只花了5秒钟，那代表中你的这个程序就是协程最多5秒就执行完毕了。</strong></li></ul><p><strong>符合下面四个条件才能称之为协程：</strong></p><ul><li>必须在只有一个单线程里实现并发</li><li>修改共享数据不需加锁</li><li>用户程序里自己保存多个控制流的上下文栈</li><li>一个协程遇到IO操作自动切换到其它协程</li></ul><h2 id="协程（gevent）并发爬网页"><a href="#协程（gevent）并发爬网页" class="headerlink" title="协程（gevent）并发爬网页"></a>协程（gevent）并发爬网页</h2><p>&emsp;&emsp;上面例子gevent遇到io自动切换，现在就来实际演示协程爬虫的例子<br><strong>正常（串行）爬网页</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line">import time</span><br><span class="line"> </span><br><span class="line">def run(url):</span><br><span class="line">    print(&quot;GET:&#123;0&#125;&quot;.format(url))</span><br><span class="line">    resp = request.urlopen(url)    # request.urlopen()函数 用来打开网页</span><br><span class="line">    data = resp.read()    # 读取爬到的数据</span><br><span class="line">    with open(&quot;url.html&quot;, &quot;wb&quot;) as f:</span><br><span class="line">        f.write(data)</span><br><span class="line">    print(&apos;&#123;0&#125; bytes received from &#123;1&#125;&apos;.format(len(data), url))</span><br><span class="line"> </span><br><span class="line">urls = [</span><br><span class="line">    &apos;http://www.163.com/&apos;,</span><br><span class="line">    &apos;https://www.yahoo.com/&apos;,</span><br><span class="line">    &apos;https://github.com/&apos;</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">time_start = time.time()    # 开始时间</span><br><span class="line">for url in urls:</span><br><span class="line">    run(url)</span><br><span class="line">print(&quot;同步cost&quot;, time.time() - time_start)  # 程序执行消耗的时间</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-协程/20181029020845792.png" alt=""></p><p><strong>协程(gevent)爬虫(gevent并发执行)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line">import time,gevent</span><br><span class="line"> </span><br><span class="line">def run(url):</span><br><span class="line">    print(&quot;GET:&#123;0&#125;&quot;.format(url))</span><br><span class="line">    resp = request.urlopen(url)    # request.urlopen()函数 用来打开网页</span><br><span class="line">    data = resp.read()    # 读取爬到的数据</span><br><span class="line">    with open(&quot;url.html&quot;, &quot;wb&quot;) as f:</span><br><span class="line">        f.write(data)</span><br><span class="line">    print(&apos;&#123;0&#125; bytes received from &#123;1&#125;&apos;.format(len(data), url))</span><br><span class="line"> </span><br><span class="line">urls = [</span><br><span class="line">    &apos;http://www.163.com/&apos;,</span><br><span class="line">    &apos;https://www.yahoo.com/&apos;,</span><br><span class="line">    &apos;https://github.com/&apos;</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">time_start = time.time()    # 开始时间</span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(run,&apos;http://www.163.com/&apos;),  # 生成协程</span><br><span class="line">    gevent.spawn(run,&apos;https://www.yahoo.com/&apos;),</span><br><span class="line">    gevent.spawn(run,&apos;https://github.com/&apos;)</span><br><span class="line">])</span><br><span class="line">print(&quot;异步cost&quot;, time.time() - time_start)  # 程序执行消耗的时间</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-协程/20181029023531205.png" alt=""><br><strong>对比1、2爬网页的例子，发现执行耗费时间上并没有得到明显提升，并没有并发爬网页的神奇快感，其实主要是因为gevent现在检测不到urllib的IO操作。它都不知道urllib进行了IO操作，感受不到阻塞，它都不会进行切换，所以它就串行了。</strong></p><p><strong>打个补丁，告诉gevent,urllib正在进行IO操作</strong><br>通过导入monkey模块，来打这个补丁，原代码不变，就添加一行monkey.patch_all()即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line">import gevent,time</span><br><span class="line">from gevent import monkey  # 导入monkey模块</span><br><span class="line"> </span><br><span class="line">monkey.patch_all()  # 把当前程序的所有的IO操作给作上标记</span><br><span class="line"> </span><br><span class="line">def run(url):</span><br><span class="line">    print(&quot;GET:&#123;0&#125;&quot;.format(url))</span><br><span class="line">    resp = request.urlopen(url)    # request.urlopen()函数 用来打开网页</span><br><span class="line">    data = resp.read()    # 读取爬到的数据</span><br><span class="line">    with open(&quot;url.html&quot;, &quot;wb&quot;) as f:</span><br><span class="line">        f.write(data)</span><br><span class="line">    print(&apos;&#123;0&#125; bytes received from &#123;1&#125;&apos;.format(len(data), url))</span><br><span class="line"> </span><br><span class="line">urls = [</span><br><span class="line">    &apos;http://www.163.com/&apos;,</span><br><span class="line">    &apos;https://www.yahoo.com/&apos;,</span><br><span class="line">    &apos;https://github.com/&apos;</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">time_start = time.time()    # 开始时间</span><br><span class="line">gevent.joinall([                     # 用gevent启动协程</span><br><span class="line">    gevent.spawn(run, &apos;http://www.163.com/&apos;),  # 第二个值是传入参数，之前我们没有讲，因为前面没有传参</span><br><span class="line">    gevent.spawn(run, &apos;https://www.yahoo.com/&apos;),</span><br><span class="line">    gevent.spawn(run, &apos;https://github.com/&apos;),</span><br><span class="line">])</span><br><span class="line">print(&quot;异步cost&quot;, time.time() - time_start)  # 程序执行消耗的时间</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-协程/20181029023811804.png" alt=""><br><strong><font color="red">时间会受到网络状态的影响</font></strong><br>&emsp;&emsp;通过打补丁来检测urllib，它就把urllib里面所有涉及到的有可能进行IO操作的地方直接花在前面加一个标记，这个标记就相当于gevent.sleep()，所以把urllib变成一个一有阻塞，它就切换了</p><h2 id="gevent实现单线程下的多socket并发"><a href="#gevent实现单线程下的多socket并发" class="headerlink" title="gevent实现单线程下的多socket并发"></a>gevent实现单线程下的多socket并发</h2><h3 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import sys,gevent,socket,time</span><br><span class="line">from gevent import socket,monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line">   </span><br><span class="line">def server(port):</span><br><span class="line">    s = socket.socket()</span><br><span class="line">    s.bind((&apos;0.0.0.0&apos;, port))</span><br><span class="line">    s.listen(500)</span><br><span class="line">    while True:</span><br><span class="line">        cli, addr = s.accept()</span><br><span class="line">        gevent.spawn(handle_request, cli)   #协程</span><br><span class="line">  </span><br><span class="line">def handle_request(conn):</span><br><span class="line">    try:</span><br><span class="line">        while True:</span><br><span class="line">            data = conn.recv(1024)</span><br><span class="line">            print(&quot;recv:&quot;, data)</span><br><span class="line">            conn.send(data)</span><br><span class="line">            if not data:</span><br><span class="line">                conn.shutdown(socket.SHUT_WR)</span><br><span class="line">    except Exception as  ex:</span><br><span class="line">        print(ex)</span><br><span class="line">    finally:</span><br><span class="line">        conn.close()</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    server(8888)</span><br></pre></td></tr></table></figure><h3 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">   </span><br><span class="line">HOST = &apos;localhost&apos;    # The remote host</span><br><span class="line">PORT = 8888           # The same port as used by the server</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((HOST, PORT))</span><br><span class="line">while True:</span><br><span class="line">    msg = bytes(input(&quot;&gt;&gt;:&quot;),encoding=&quot;utf8&quot;)</span><br><span class="line">    s.sendall(msg)</span><br><span class="line">    data = s.recv(1024)</span><br><span class="line">    print(&apos;Received&apos;, repr(data))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;协程，又称微线程。英文名Coroutine。一句话说明什么是协程：协程是一种用户态的轻量级线程。&lt;br&gt;&amp;emsp;&amp;emsp;协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：&lt;br&gt;&amp;emsp;&amp;emsp;协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python-多进程</title>
    <link href="http://yoursite.com/2018/09/15/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/09/15/Python-多进程/</id>
    <published>2018-09-15T15:15:10.000Z</published>
    <updated>2018-12-07T07:54:35.881Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;进程之间是相互独立的，进程没有GIL锁，而且不存在锁的概念，进程之间的数据式不能共享的，而线程是可以的。<br><a id="more"></a></p><h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><h2 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h2><p>&emsp;&emsp;用muliprocessing这个包中的Process来定义多进程，跟定义多线程类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process   # 导入进程模块</span><br><span class="line">import time</span><br><span class="line"> </span><br><span class="line">def run(name):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;hello&quot;, name)</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    p_obj_list = list()    # 存放进程对象</span><br><span class="line">    for i in range(10):    # 启动10个进程</span><br><span class="line">        p = Process(target=run, args=(&quot;QQ&#123;0&#125;&quot;.format(i),))  # 产生一个进程实例</span><br><span class="line">        p.start()   # 启动进程</span><br><span class="line">        p_obj_list.append(p)</span><br><span class="line">  </span><br><span class="line">    for p in p_obj_list:</span><br><span class="line">        p.join()   # 等待进程结果</span><br></pre></td></tr></table></figure><br><img src="/python-多进程/20181026112021180.png" alt=""></p><h2 id="进程中加入线程"><a href="#进程中加入线程" class="headerlink" title="进程中加入线程"></a>进程中加入线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import time,threading</span><br><span class="line"> </span><br><span class="line">def thread_run(name):   # 定义线程执行的方法</span><br><span class="line">    print(&quot;&#123;0&#125;:&#123;1&#125;&quot;.format(name, threading.get_ident()))  # thread.get_ident ()返回当前线程的标识符，标识符是一个非零整数</span><br><span class="line"> </span><br><span class="line">def run(name):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;hello&quot;, name)</span><br><span class="line">    t = threading.Thread(target=thread_run, args=(name,))   # 嵌入线程</span><br><span class="line">    t.start()   # 执行线程</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    p_obj_list = list()</span><br><span class="line">    for i in range(10):</span><br><span class="line">        p = Process(target=run, args=(&quot;QQ&#123;0&#125;&quot;.format(i),))</span><br><span class="line">        p.start()</span><br><span class="line">        p_obj_list.append(p)</span><br><span class="line"> </span><br><span class="line">    for p in p_obj_list:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure><p><img src="/python-多进程/20181026112235923.png" alt=""></p><h2 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h2><p>每个子进程都是由一个父进程启动的，每个程序也是有一个父进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line"> </span><br><span class="line">def info(title):</span><br><span class="line">    print(title)</span><br><span class="line">    print(&apos;module name:&apos;, __name__)</span><br><span class="line">    print(&apos;parent process:&apos;, os.getppid())  # 获得父进程ID</span><br><span class="line">    print(&apos;process id:&apos;, os.getpid())  # 获得子进程ID</span><br><span class="line">    print(&apos;\n&apos;)</span><br><span class="line"> </span><br><span class="line">def f(name):</span><br><span class="line">    info(&apos;function f&apos;)</span><br><span class="line">    print(&apos;hello&apos;, name)</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    info(&apos;main process line&apos;)</span><br><span class="line">    p = Process(target=f, args=(&apos;QQ&apos;,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><br><img src="/python-多进程/20181026112550916.png" alt=""></p><h1 id="进程间数据交互与共享"><a href="#进程间数据交互与共享" class="headerlink" title="进程间数据交互与共享"></a>进程间数据交互与共享</h1><p>&emsp;&emsp;知道不同进程之间内存是不共享的，要想实现两个进程间的通信需要用到multiprocessing库中的queue（队列）模块，这个multiprocessing库中的queue模块跟单纯的queue库是不一样的。进程导入前者（这里的queue是专门为进程之间的通信设计的）不出错，导入后者（这里的queue主要是线程间数据交互）出错。</p><h3 id="线程访问queue"><a href="#线程访问queue" class="headerlink" title="线程访问queue"></a>线程访问queue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import queue,threading</span><br><span class="line"></span><br><span class="line">def f(q):</span><br><span class="line">    q.put([66, None, &apos;hello word&apos;])</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    q = queue.Queue()   # 把这个q传给了子线程</span><br><span class="line">    p = threading.Thread(target=f, args=(q,))   # 子线程访问父线程的q</span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/python-多进程/20181026112944166.png" alt=""></p><h3 id="进程访问queue"><a href="#进程访问queue" class="headerlink" title="进程访问queue"></a>进程访问queue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import queue</span><br><span class="line"></span><br><span class="line">def f(q):</span><br><span class="line">    q.put([66, None, &apos;hello word&apos;])</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    q = queue.Queue()   # 把这个q传给了子线程</span><br><span class="line">    p = Process(target=f, args=(q,))   # 子线程访问父线程的q</span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/python-多进程/20181026113140101.png" alt=""></p><h3 id="进程访问multiprocessing库中的Queue模块"><a href="#进程访问multiprocessing库中的Queue模块" class="headerlink" title="进程访问multiprocessing库中的Queue模块"></a>进程访问multiprocessing库中的Queue模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process,Queue</span><br><span class="line"> </span><br><span class="line">def f(q):</span><br><span class="line">    q.put([66, None, &apos;hello word&apos;])</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    q = Queue()   # 把这个q传给了子线程</span><br><span class="line">    p = Process(target=f, args=(q,))   # 子线程访问父线程的q</span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/python-多进程/20181026113249257.png" alt=""><br>&emsp;&emsp;父进程相当于克隆一个Q，把自己的Q克隆了一份交给子进程，子进程这个时候往Q里面放了一份数据，然后父进程又能实际的获取到。但是你克隆了一份是不是就和父进程没有关系了，为什么还能联系在一起呢？但是实际上：等于这两个Q里面的数据又把它序列化了，序列化到一个中间的地方，类似于翻译，然后反序列化给这个父进程这边来了，其实这两个Q就是通过pickle来序列化的，不是一个真正的Q。<br><strong>小结：两个线程之间可以修改一个数据，不加锁，可能就会出错。现在进程中的Queue，是实现了数据的传递，不是在修改同一份数据，只是实现一个进程的数据传给了另外一个进程。</strong></p><h2 id="Pipe-实现进程间的数据交互，manger实现数据共享"><a href="#Pipe-实现进程间的数据交互，manger实现数据共享" class="headerlink" title="Pipe()实现进程间的数据交互，manger实现数据共享"></a>Pipe()实现进程间的数据交互，manger实现数据共享</h2><p>&emsp;&emsp;上面的例子是通过进程中的Queue，来进行数据共享的，其实还有一种方式实现数据共享，那就是管道，pipe，以及数据共享manger。</p><h3 id="Pipe-函数"><a href="#Pipe-函数" class="headerlink" title="Pipe()函数"></a>Pipe()函数</h3><p>&emsp;&emsp;管道函数会返回由管道双方连接的一组连接对象，该管道默认是双向的(双向的)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, Pipe</span><br><span class="line"> </span><br><span class="line">def f(conn):</span><br><span class="line">    conn.send([66, None, &apos;hello,word&apos;])  # 发送消息给父进程</span><br><span class="line">    conn.send([66, None, &apos;hello,word2&apos;])  # 发送消息给父进程</span><br><span class="line">    conn.close()</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    parent_conn, child_conn = Pipe()  # 管道生成返回两个实例，是双向的，这边把第1个作为父连接，第2个作为子连接。也可以，两者角色调换一下</span><br><span class="line">    p = Process(target=f, args=(child_conn,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(parent_conn.recv())   # 接收子进程的消息</span><br><span class="line">    print(parent_conn.recv())   # 接收子进程的消息</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-多进程/20181027010733552.png" alt=""><br><strong>如果父进程在接收,但是子进程没有发,那么父进程就会一直等待下去</strong></p><h3 id="manger"><a href="#manger" class="headerlink" title="manger()"></a>manger()</h3><p>&emsp;&emsp;manger可以完成数据间的共享。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, Manager</span><br><span class="line">import os</span><br><span class="line"> </span><br><span class="line">def f(d, l):</span><br><span class="line">    d[os.getpid()] = os.getpid()</span><br><span class="line">    l.append(os.getpid())</span><br><span class="line">    print(l)</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    with Manager() as manager:</span><br><span class="line">        d = manager.dict()   # 声明一个字典，这个字典是用manger声明的，不是用dict()声明的</span><br><span class="line">        # manger.dict()是用专门的语法生产一个可在多进程之间进行传递和共享的一个字典</span><br><span class="line">        l = manager.list(range(5))  # 同样声明一个列表</span><br><span class="line">        p_list = []</span><br><span class="line">        for i in range(10):</span><br><span class="line">            p = Process(target=f, args=(d, l))</span><br><span class="line">            p.start()</span><br><span class="line">            p_list.append(p)</span><br><span class="line">        for res in p_list:</span><br><span class="line">            res.join()</span><br><span class="line">        print(d)</span><br><span class="line">        print(l)</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-多进程/20181027012451920.png" alt=""><br><strong>线程修改同一份数据的时候需要加锁，进程修改数据呢：不用加锁，因为这个manger已经帮你加锁了，它就默认不允许两个进程同时修改一份数据。两个进程没有办法同时修改一份数据，进程之间是独立的，它自己也要加锁，因为它把自己的东西同时copy好几份，跟刚刚的那个Queue一样，copy10个字典最终合成一个字典</strong></p><h1 id="进程锁和进程池"><a href="#进程锁和进程池" class="headerlink" title="进程锁和进程池"></a>进程锁和进程池</h1><h2 id="进程锁"><a href="#进程锁" class="headerlink" title="进程锁"></a>进程锁</h2><p>&emsp;&emsp;通过multiprocessing中的Lock模块来实现进程锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process,Lock   # 导入进程锁</span><br><span class="line"> </span><br><span class="line">def f(l, i):</span><br><span class="line">    l.acquire()    # 加锁</span><br><span class="line">    print(&quot;hello word&quot;, i)</span><br><span class="line">    l.release()   # 释放锁</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    lock = Lock()     # 定义锁</span><br><span class="line">    for num in range(10):</span><br><span class="line">        Process(target=f, args=(lock, num,)).start()  # 把锁传入进程中</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-多进程/20181027014001015.png" alt=""><br><strong>进程中不是相互独立的吗？为什么还要加锁：虽然每个进程都是独立运行的，但是问题来了，它们共享一块屏幕。这个锁存在的意义就是屏幕共享。如果进程1想着打印数据，而进程2想也想打印数据的情况，就有可能乱套了，然后通过这个锁来控制，去打印的时候，这个屏幕只有我独占，导致屏幕不会乱。</strong></p><h2 id="进程池apply和apply-saync"><a href="#进程池apply和apply-saync" class="headerlink" title="进程池apply和apply_saync"></a>进程池apply和apply_saync</h2><h3 id="appley"><a href="#appley" class="headerlink" title="appley"></a>appley</h3><p>&emsp;&emsp;同步执行，也就是<strong>串行执行</strong>的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool  # 导入进程池模块pool</span><br><span class="line">import time,os</span><br><span class="line"> </span><br><span class="line">def foo(i):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;in process&quot;, os.getpid())  # 打印进程号</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    pool = Pool(processes=5)   # 设置进程池个数为5，也可以写成pool = Pool(5)，允许进程池同时放入5个进程，并且这5个进程交给cpu去运行</span><br><span class="line">    for i in range(10):</span><br><span class="line">        pool.apply(func=foo, args=(i,))   # 同步执行挂起进程</span><br><span class="line">    print(&apos;end&apos;)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  # 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</span><br></pre></td></tr></table></figure><br><strong>一个一个打印</strong><br><img src="http://qiniu.rearib.top/python-多进程/20181027015536404.png" alt=""></p><h3 id="apply-saync"><a href="#apply-saync" class="headerlink" title="apply_saync"></a>apply_saync</h3><p>&emsp;&emsp;异步执行，也就是<strong>并行执行</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool  # 导入进程池模块pool</span><br><span class="line">import time,os</span><br><span class="line"> </span><br><span class="line">def foo(i):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;in process&quot;, os.getpid())  # 打印进程号</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    pool = Pool(processes=5)   # 设置进程池个数为5，也可以写成pool = Pool(5)，允许进程池同时放入5个进程，并且这5个进程交给cpu去运行</span><br><span class="line">    for i in range(10):</span><br><span class="line">        pool.apply_async(func=foo, args=(i,))   # 采用异步方式执行foo函数</span><br><span class="line">    print(&apos;end&apos;)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  # 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-多进程/20181027015657931.png" alt=""></p><h3 id="异步下回调函数"><a href="#异步下回调函数" class="headerlink" title="异步下回调函数"></a>异步下回调函数</h3><p>&emsp;&emsp;程序执行完毕之后，再回调过来执行这个Bar函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process,Pool</span><br><span class="line">import time,os</span><br><span class="line"> </span><br><span class="line">def foo(i):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;in process&quot;, os.getpid())  # 打印子进程的进程号</span><br><span class="line">    return i</span><br><span class="line"> </span><br><span class="line">def bar(arg):</span><br><span class="line">    print(&apos;--&gt;exec done:&apos;, arg, os.getpid())   # 打印进程号</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    pool = Pool(processes=2)</span><br><span class="line">    print(&quot;主进程&quot;, os.getpid())   # 主进程的进程号</span><br><span class="line">    for i in range(3):</span><br><span class="line">        pool.apply_async(func=foo, args=(i,), callback=bar)   # 执行回调函数callback=Bar,在主进程中执行</span><br><span class="line">    print(&apos;end&apos;)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  # 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</span><br></pre></td></tr></table></figure><br><strong>五个五个打印</strong><br><img src="http://qiniu.rearib.top/python-多进程/20181027015941615.png" alt=""><br><strong>回调函数在主进程执行,传入的参数来自子进程</strong></p><ul><li>回调函数说明fun=Foo干不完就不执行bar函数，等Foo执行完就去执行Bar</li><li>这个回调函数是主进程去调用的，而不是每个子进程去调用的。</li><li>回调函数的用处：<blockquote><p>比如说你从各个机器上备份完毕，在回调函数中自动写一个脚本，说备份完毕</p></blockquote></li><li>回调函数是主进程调用的原因？<blockquote><p>如果是子进程去调用这个回调函数，有多少个子进程就有多少个连接，如果是主进程的话，只需要一次长连接就可以了，这个效率就高了</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;进程之间是相互独立的，进程没有GIL锁，而且不存在锁的概念，进程之间的数据式不能共享的，而线程是可以的。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python-线程与进程</title>
    <link href="http://yoursite.com/2018/09/12/Python-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/09/12/Python-线程与进程/</id>
    <published>2018-09-12T11:37:08.000Z</published>
    <updated>2018-12-07T07:54:50.448Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;计算机所有的指令的操作都是有CPU来负责的，cpu是来负责运算的。<strong>OS(操作系统) 调度cpu的最小单位就是线程。</strong><br>&emsp;&emsp;进程：是以一个整体的形式暴露给操作系统管理，里面包含对各种资源的调用，内存的管理，网络接口的调用等等，是各种资源管理的集合<br>&emsp;&emsp;线程：是操作系统的最小的调度单位，是一串指令的集合。<br><a id="more"></a><br><img src="http://qiniu.rearib.top/1/20181026100045261.png" alt=""></p><h2 id="进程-Process）"><a href="#进程-Process）" class="headerlink" title="进程(Process）"></a>进程(Process）</h2><p>&emsp;&emsp;程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：<strong>程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。</strong><br>&emsp;&emsp;在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。这是这样的设计，大大提高了CPU的利用率。进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。</p><h2 id="线程-Thead"><a href="#线程-Thead" class="headerlink" title="线程(Thead)"></a>线程(Thead)</h2><p>&emsp;&emsp;线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，<strong>一个进程中可以并发多个线程，每条线程并行执行不同的任务。</strong></p><h2 id="有了进程为什么还要线程"><a href="#有了进程为什么还要线程" class="headerlink" title="有了进程为什么还要线程?"></a>有了进程为什么还要线程?</h2><p>&emsp;&emsp;进程有很多优点，它提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率。很多人就不理解了，既然进程这么优秀，为什么还要线程呢？其实，仔细观察就会发现进程还是有很多缺陷的，主要体现在两点上：</p><ul><li>进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。</li><li>进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。</li></ul><p>&emsp;&emsp;例如，我们在使用qq聊天， qq做为一个独立进程如果同一时间只能干一件事，那他如何实现在同一时刻：即能监听键盘输入、又能监听其它人给你发的消息、同时还能把别人发的消息显示在屏幕上呢？你会说，操作系统不是有分时么？但是分时是指在不同进程间的分时， 即操作系统处理一会你的qq任务，又切换到word文档任务上了，每个cpu时间片分给你的qq程序时，事实上，你的qq还是同一时间只能干一件事情。<br>&emsp;&emsp;再直白一点， 一个操作系统就像是一个工厂，工厂里面有很多个生产车间，不同的车间生产不同的产品，每个车间就相当于一个进程，且你的工厂又穷，供电不足，同一时间只能给一个车间供电，为了能让所有车间都能同时生产，你的工厂的电工只能给不同的车间分时供电，但是轮到你的qq车间时，发现只有一个干活的工人，结果生产效率极低，为了解决这个问题，就需要多加几个工人，让几个人工人并行工作，这每个工人，就是线程！</p><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li>线程是共享内存空间的；进程的内存是独立的。</li><li>线程可以直接访问此进程中的数据部分；进程有他们独立拷贝自己父进程的数据部分，每个进程是独立的</li><li>同一进程的线程之间直接交流(直接交流涉及到数据共享，信息传递)；两个进程想通信，必须通过一个中间代理来实现。</li><li>创建一个新的线程很容易；创建新的进程需要对其父进程进行一次克隆。</li><li>一个线程可以控制和操作同一进程里的其他线程；但是进程只能操作子进程。</li><li>对主线程的修改，可能会影响到进程中其他线程的修改；对于一个父进程的修改不会影响其他子进程(只要不删除父进程即可)<h2 id="概念小结"><a href="#概念小结" class="headerlink" title="概念小结"></a>概念小结</h2></li><li>线程是操作系统最小的调度单位，是一串指令的集合。</li><li>进程要操作CPU，必须先创建一个线程。</li><li>进程本身是不可以执行的，操作cpu是通过线程实现的，因为它是一堆执行，而进程是不具备执行概念的。就像一个屋子，屋子就是进程，但是屋子里面的每一个人就是线程，屋子就是内存空间。</li><li>单核CPU只能同时干一件事，但是为什么给我们的感觉是在干了很多件事？因为CPU太快了，可以有N多次切换。</li><li>进程是通过PID来区分的，并不是通过进程名来区分的。进程里面的第一个线程就是主线程，父线程和子线程是相互独立的，只是父线程创建了子线程，父线程down了，子线程不会受到影响的。</li><li>主线程修改会影响其他线程，因为它们是共享数据的。</li><li>线程启动比进程块，但是运行速度没有可比性</li></ul><h1 id="threading-Thread模块"><a href="#threading-Thread模块" class="headerlink" title="threading.Thread模块"></a>threading.Thread模块</h1><h2 id="函数式多线程"><a href="#函数式多线程" class="headerlink" title="函数式多线程"></a>函数式多线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">def run(n):</span><br><span class="line">    print(&quot;run&quot;, n)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(n,&apos;end time:&apos;,time.time())</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">第一个参数是线程函数变量，第二个参数args是一个元组变量参数，如果只传递一个值，就只需要i,</span><br><span class="line">如果需要传递多个参数，那么还可以继续传递下去其他的参数，其中的逗号不能少，少了逗号位置参数指引就会出错。</span><br><span class="line">&quot;&quot;&quot; </span><br><span class="line">t1 = threading.Thread(target=run, args=(&quot;t1&quot;,))  # 生成线程对象</span><br><span class="line">t2 = threading.Thread(target=run, args=(&quot;t2&quot;,))</span><br><span class="line"></span><br><span class="line">print(&apos;start:&apos;,time.time())</span><br><span class="line">t1.start()  # start()函数启动一个线程</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/线程与进程/20181026101728106.png" alt=""></p><h2 id="继承式多线程"><a href="#继承式多线程" class="headerlink" title="继承式多线程"></a>继承式多线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">class MyThread(threading.Thread):   # 继承threading.Thread</span><br><span class="line">    &quot;&quot;&quot;继承式多线程&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        super(MyThread,self).__init__()  # 也可以写成这样threading.Thread.__init__(self)</span><br><span class="line">        self.n = n</span><br><span class="line"> </span><br><span class="line">    def run(self):     # 重写run方法</span><br><span class="line">        &quot;&quot;&quot;这个方法不能叫别的名字，只能叫run方法&quot;&quot;&quot;</span><br><span class="line">        print(&quot;run&quot;, self.n)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(self.n,&apos;end time:&apos;,time.time())</span><br><span class="line">        </span><br><span class="line">t1 = MyThread(&quot;t1&quot;)   # 实例化</span><br><span class="line">t2 = MyThread(&quot;t2&quot;)</span><br><span class="line"></span><br><span class="line">print(&apos;start:&apos;,time.time()) </span><br><span class="line">t1.start()   # 启动一个多线程</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/线程与进程/20181026102059476.png" alt=""></p><p>&amp;emsp；&amp;emsp；在上面两个示例代码中，都包含一个主线程和两个子线程，主线程在启动子线程后，子线程就是独立的，所以主线程不会等待子线程的sleep就直接运行下去。如果实现等待线程执行结果可以使用join。</p><h2 id="join函数"><a href="#join函数" class="headerlink" title="join函数"></a>join函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">class MyThread(threading.Thread):   # 继承threading.Thread</span><br><span class="line">    &quot;&quot;&quot;继承式多线程&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        super(MyThread,self).__init__()  # 也可以写成这样threading.Thread.__init__(self)</span><br><span class="line">        self.n = n</span><br><span class="line"> </span><br><span class="line">    def run(self):     # 重写run方法</span><br><span class="line">        &quot;&quot;&quot;这个方法不能叫别的名字，只能叫run方法&quot;&quot;&quot;</span><br><span class="line">        print(&quot;run&quot;, self.n)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(self.n,&apos;end time:&apos;,time.time())</span><br><span class="line">        </span><br><span class="line">t1 = MyThread(&quot;t1&quot;)   # 实例化</span><br><span class="line">t2 = MyThread(&quot;t2&quot;)</span><br><span class="line"></span><br><span class="line">print(&apos;start:&apos;,time.time()) </span><br><span class="line">t1.start()   # 启动一个多线程</span><br><span class="line">t1.join()</span><br><span class="line">t2.start()</span><br><span class="line">print(&apos;main end time:&apos;,time.time())</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/线程与进程/20181026103100213.png" alt=""></p><ul><li>加了join之后，主线程依赖子线程执行完毕才往下走。</li></ul><p><strong>如果想要的是线程依然是并行效果，就需要更换join()的位置</strong><br><img src="http://qiniu.rearib.top/线程与进程/20181026102935930.png" alt=""></p><h2 id="计算多线程执行时间"><a href="#计算多线程执行时间" class="headerlink" title="计算多线程执行时间"></a>计算多线程执行时间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">def run(n):  # 这边的run方法的名字是自行定义的，跟继承式多线程不一样，那个是强制的</span><br><span class="line">    print(&quot;task:&quot;, n)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;task done&quot;, n)</span><br><span class="line"> </span><br><span class="line">start_time = time.time()  # 开始时间</span><br><span class="line">t_obj = []  # 存放子线程实例</span><br><span class="line">for i in range(10):  # 一次性启动10个线程</span><br><span class="line">    t = threading.Thread(target=run, args=(&quot;t-&#123;0&#125;&quot;.format(i),))</span><br><span class="line">    t.start()</span><br><span class="line">    t_obj.append(t)   # 为了不阻塞后面线程的启动，不在这里join，先放到一个列表中</span><br><span class="line"> </span><br><span class="line">for t in t_obj:  # 循环线程实例列表，等待所有线程执行完毕</span><br><span class="line">    t.join() </span><br><span class="line"> </span><br><span class="line">print(&quot;--------all thread has finished&quot;)</span><br><span class="line">print(&quot;cost:&quot;, time.time() - start_time)  # 计算总耗时</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/线程与进程/20181026103423804.png" alt=""></p><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>&emsp;&emsp;只要主线程执行完毕，它不管子线程有没有执行完毕，就退出。现在就可以把所有的子线程变成守护线程。<strong>子线程变成守护线程之后，主程序就不会等子线程结束再退出了</strong>。说白了，设置一个主人，在设置几个仆人，这几个仆人都是为主人服务的。可以帮主人做很多事情，一个主人（主线程）可以有多个仆人（守护线程），服务的前提是，主线程必须存在，如果主线程不存在，则守护进程也没了。那守护进程是干嘛的呢？可以管理一些资源，打开一些文件，监听一些端口，监听一些资源，把一些垃圾资源回收，可以干很多事情，可以随便定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"></span><br><span class="line">def run(n):</span><br><span class="line">    print(&quot;task:&quot;, n)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;task done&quot;, n)</span><br><span class="line"> </span><br><span class="line">start_time = time.time()</span><br><span class="line">for i in range(5):</span><br><span class="line">    t = threading.Thread(target=run,args=(&quot;t-&#123;0&#125;&quot;.format(i),))</span><br><span class="line">    t.setDaemon(True)  # Daemon意思是守护进程，这边是把当前线程设置为守护线程</span><br><span class="line">    t.start()</span><br><span class="line"> </span><br><span class="line">print(&quot;--------all thread has finished&quot;)</span><br><span class="line">print(&quot;cost:&quot;, time.time() - start_time)</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/线程与进程/20181026103850709.png" alt=""><br><strong>守护进程一定要在start之前设置，start之后就不能设置了，之后设置会报错</strong></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>&emsp;&emsp;比如写一个socket_server，每一个链接过来，socket_server就会给这个链接分配一个新的线程。如果我手动的把socket_server停掉。那这种情况你必须手动停掉服务，那它就要down了，这种情况下还要等线程结束吗？就不用等线程结束了，它自己就直接结束了。这样，是不是就可以把每个socket线程设置一个守护线程，主线程一旦down掉，就全部退出。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>theading.current_thead()查看当前线程；</li><li>用theading.active_count()来统计当前活动的线程数</li><li>线程个数=子线程数+主线程数</li></ul><h1 id="GIL锁-全局解释器锁"><a href="#GIL锁-全局解释器锁" class="headerlink" title="GIL锁(全局解释器锁)"></a>GIL锁(全局解释器锁)</h1><p>&emsp;&emsp;计算机有4核，代表着同一时间，可以干4个任务。如果单核cpu的话，我启动10个线程，我看上去也是并发的，因为是执行了上下文的切换，让看上去是并发的。但是单核永远肯定时串行的，它肯定是串行的，cpu真正执行的时候，因为一会执行1，一会执行2.。。。。正常的线程就是这个样子的。但是，在python中，无论有多少核，永远都是假象。无论是4核，8核，还是16核…….不好意思，同一时间执行的线程只有一个(线程)，它就是这个样子的。这个是python的一个开发时候，设计的一个缺陷，所以说python中的线程是假线程。</p><h2 id="GIL存在的意义"><a href="#GIL存在的意义" class="headerlink" title="GIL存在的意义"></a><a href="https://www.cnblogs.com/gengcx/p/7500401.html" target="_blank" rel="noopener">GIL存在的意义</a></h2><p>&emsp;&emsp;在新处理器上运行的程序要想充分利用其性能，必须按照并发方式进行重写。大部分开发者听到“并发”通常会立刻想到多线程的程序。目前来说，多线程执行还是利用多核系统最常用的方式。尽管多线程编程大大好于“顺序”编程，不过即便是仔细的程序员也没法在代码中将并发性做到最好。编程语言在这方面应该做的更好，大部分应用广泛的现代编程语言都会支持多线程编程。<br>&emsp;&emsp;要想利用多核系统，Python必须支持多线程运行。作为解释型语言，Python的解释器必须做到既安全又高效。我们都知道多线程编程会遇到的问题。解释器要留意的是避免在不同的线程操作内部共享的数据。同时它还要保证在管理用户线程时保证总是有最大化的计算资源。<br>&emsp;&emsp;那么，不同线程同时访问时，数据的保护机制是怎样的呢？答案是解释器全局锁。从名字上看能告诉我们很多东西，很显然，这是一个加在解释器上的全局（从解释器的角度看）锁（从互斥或者类似角度看）。这种方式当然很安全，但是它有一层隐含的意思（Python初学者需要了解这个）：对于任何Python程序，不管有多少的处理器，任何时候都总是只有一个线程在执行。</p><h2 id="GIL锁关系图"><a href="#GIL锁关系图" class="headerlink" title="GIL锁关系图"></a>GIL锁关系图</h2><p>&emsp;&emsp;GIL(全局解释器锁)是加在python解释器里面的，效果如图：<br><img src="http://qiniu.rearib.top/线程与进程/20181026110513560.png" alt=""><br><strong>总结:</strong><br>&emsp;&emsp;需要明确的一点是<strong>GIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念</strong>。就好比C++是一套语言（语法）标准，但是可以用不同的编译器来编译成可执行代码。有名的编译器例如GCC，INTEL C++，Visual C++等。Python也一样，同样一段代码可以通过CPython，PyPy，Psyco等不同的Python执行环境来执行。像其中的JPython就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境。<strong>所以在很多人的概念里CPython就是Python，也就想当然的把GIL归结为Python语言的缺陷。所以这里要先明确一点：GIL并不是Python的特性，Python完全可以不依赖于GIL。</strong></p><ul><li>CPython：是用C语言实现Pyhon，是目前应用最广泛的解释器。</li></ul><h1 id="线程锁（互斥锁）"><a href="#线程锁（互斥锁）" class="headerlink" title="线程锁（互斥锁）"></a>线程锁（互斥锁）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">def run(n):</span><br><span class="line">    global num   # 把num变成全局变量</span><br><span class="line">    time.sleep(1)  # 注意了sleep的时候是不占有cpu的，这个时候cpu直接把这个线程挂起了，此时cpu去干别的事情去了</span><br><span class="line">    num += 1   # 所有的线程都做+1操作</span><br><span class="line"> </span><br><span class="line">num = 0   # 初始化num为0</span><br><span class="line">t_obj = list()</span><br><span class="line">for i in range(100):</span><br><span class="line">    t = threading.Thread(target=run, args=(&quot;t-&#123;0&#125;&quot;.format(i),))</span><br><span class="line">    t.start()</span><br><span class="line">    t_obj.append(t)</span><br><span class="line"> </span><br><span class="line">for t in t_obj:</span><br><span class="line">    t.join()</span><br><span class="line"> </span><br><span class="line">print(&quot;--------all thread has finished&quot;)</span><br><span class="line">print(&quot;num:&quot;, num)   # 输出最后的num值</span><br><span class="line"></span><br><span class="line">#执行结果</span><br><span class="line">--------all thead has finished</span><br><span class="line">(&apos;num:&apos;, 97)  #输出的结果</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其实这种情况只能在python2.x 中才会出现的，python3.x里面没有这种现象，下面我们就用一张图来解释一下这个原因。如图：<br><img src="http://qiniu.rearib.top/线程与进程/20181026114846189.png" alt=""><br>解释：</p><ul><li>到第5步的时候，可能这个时候python正好切换了一次GIL(据说python2.7中，每100条指令会切换一次GIL),执行的时间到了，被要求释放GIL,这个时候thead 1的count=0并没有得到执行，而是挂起状态，count=0这个上下文关系被存到寄存器中.</li><li>然后到第6步，这个时候thead 2开始执行，然后就变成了count = 1,返回给count，这个时候count=1.</li><li>然后再回到thead 1，这个时候由于上下文关系，thead 1拿到的寄存器中的count = 0，经过计算，得到count = 1，经过第13步的操作就覆盖了原来的count = 1的值，所以这个时候count依然是count = 1，所以这个数据并没有保护起来。</li></ul><h2 id="添加线程锁"><a href="#添加线程锁" class="headerlink" title="添加线程锁"></a>添加线程锁</h2><p>&emsp;&emsp;通过上面的图我们知道，结果依然是不准确的。所以我还要加一把锁，这个是用户级别的锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"></span><br><span class="line">def run(n):</span><br><span class="line">    lock.acquire()  # 添加线程锁</span><br><span class="line">    global num      # 把num变成全局变量</span><br><span class="line">    time.sleep(0.1) # 注意了sleep的时候是不占有cpu的，这个时候cpu直接把这个线程挂起了，此时cpu去干别的事情去了</span><br><span class="line">    num += 1        # 所有的线程都做+1操作</span><br><span class="line">    lock.release()  # 释放线程锁</span><br><span class="line"> </span><br><span class="line">num = 0   # 初始化num为0</span><br><span class="line">lock = threading.Lock()  # 生成线程锁实例</span><br><span class="line">t_obj = list()</span><br><span class="line">for i in range(10):</span><br><span class="line">    t = threading.Thread(target=run, args=(&quot;t-&#123;0&#125;&quot;.format(i),))</span><br><span class="line">    t.start()</span><br><span class="line">    t_obj.append(t)</span><br><span class="line"> </span><br><span class="line">for t in t_obj:</span><br><span class="line">    t.join()   # 为join是等子线程执行的结果，如果不加，主线程执行完，下面就获取不到子线程num的值了，共享数据num值就错误了</span><br><span class="line"></span><br><span class="line">print(&quot;--------all thread has finished&quot;)</span><br><span class="line">print(&quot;num:&quot;, num)   # 输出最后的num值</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/线程与进程/20181026115312595.png" alt=""><br><strong>小结：</strong></p><ul><li>用theading.Lock()创建一个lock的实例。</li><li>在线程启动之前通过lock.acquire()加加锁，在线程结束之后通过lock.release()释放锁。</li><li>这层锁是用户开的锁，就是我们用户程序的锁。跟我们这个GIL没有关系，但是它把这个数据相当于copy了两份，所以在这里加锁，以确保同一时间只有一个线程，真真正正的修改这个数据，所以这里的锁跟GIL没有关系，你理解就是自己的锁。</li><li>加锁，说明此时我来去修改这个数据，其他人都不能动。然后修改完了，要把这把锁释放。这样的话就把程序编程串行了。</li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>&emsp;&emsp;在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁，因为系统判断这部分资源都正在使用，所有这两个线程在无外力作用下将一直等待下去.（大锁内加小锁）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import threading,time </span><br><span class="line"></span><br><span class="line">mutexA=threading.Lock()</span><br><span class="line">mutexB=threading.Lock()</span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        self.func1()</span><br><span class="line">        self.func2()</span><br><span class="line"></span><br><span class="line">    def func1(self):</span><br><span class="line">        print(&apos;%s func1 start&apos;%self.name)</span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(&apos;%s func1 拿到A锁 &apos;%self.name)</span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(&apos;%s func1 拿到B锁 &apos;%self.name)</span><br><span class="line">        mutexB.release()</span><br><span class="line">        mutexA.release()</span><br><span class="line">        print(&apos;%s func1 end&apos;%self.name)</span><br><span class="line"></span><br><span class="line">    def func2(self):</span><br><span class="line">        print(&apos;%s func2 start&apos;%self.name)</span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(&apos;%s func2 拿到B锁 &apos;%self.name)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(&apos;%s func2 拿到A锁 &apos;%self.name)</span><br><span class="line">        mutexA.release()</span><br><span class="line">        mutexB.release()</span><br><span class="line">        print(&apos;%s func2 end&apos;%self.name)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    for i in range(5):</span><br><span class="line">        t=MyThread()</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/线程与进程/20181026044139986.png" alt=""><br>线程1拿到B锁，线程3拿到A锁，造成同时等待，而且线程2、4、5也会因为拿不到锁等待。</p><h2 id="递归锁（RLock）"><a href="#递归锁（RLock）" class="headerlink" title="递归锁（RLock）"></a>递归锁（RLock）</h2><p>&emsp;&emsp;这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import threading,time </span><br><span class="line"></span><br><span class="line">mutexA=mutexB=threading.RLock()</span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        self.func1()</span><br><span class="line">        self.func2()</span><br><span class="line"></span><br><span class="line">    def func1(self):</span><br><span class="line">        print(&apos;%s func1 start&apos;%self.name)</span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(&apos;%s func1 拿到A锁 &apos;%self.name)</span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(&apos;%s func1 拿到B锁 &apos;%self.name)</span><br><span class="line">        mutexB.release()</span><br><span class="line">        mutexA.release()</span><br><span class="line">        print(&apos;%s func1 end&apos;%self.name)</span><br><span class="line"></span><br><span class="line">    def func2(self):</span><br><span class="line">        print(&apos;%s func2 start&apos;%self.name)</span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(&apos;%s func2 拿到B锁 &apos;%self.name)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(&apos;%s func2 拿到A锁 &apos;%self.name)</span><br><span class="line">        mutexA.release()</span><br><span class="line">        mutexB.release()</span><br><span class="line">        print(&apos;%s func2 end&apos;%self.name)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    for i in range(5):</span><br><span class="line">        t=MyThread()</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/线程与进程/20181026045033501.png" alt=""><br><img src="http://qiniu.rearib.top/线程与进程/20181026045227839.png" alt=""><br>&emsp;&emsp;由于锁A，B是同一个递归锁，thread1拿到A,B锁，counter记录了acquire的次数2次，然后在func1执行完毕，就释放递归锁，在thread1释放完递归锁，执行完func1代码，接下来会有2种可能：1、thread1在次抢到递归锁，执行func2代码 2、其他的线程抢到递归锁，去执行func1的任务代码<br><strong>递归锁用于多重锁的情况，如果只是一层锁，就用不上递归锁</strong><br>递归锁原理其实很简单：就是每开一把门，在字典里面存一份数据，退出的时候去到door1或者door2里面找到这个钥匙退出，如图：<br><img src="http://qiniu.rearib.top/线程与进程/20181026050112225.png" alt=""></p><h2 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h2><p>&emsp;&emsp;之前讲的线程锁（互斥锁）同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去。</p><ul><li>信号量是一个变量，控制着对公共资源或者临界区的访问。信号量维护着一个计数器，指定可同时访问资源或者进入临界区的线程数。 </li><li>每次有一个线程获得信号量时，计数器-1。若计数器为0，其他线程就停止访问信号量，直到另一个线程释放信号量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">def run(n):</span><br><span class="line">    semaphore.acquire()   # 加信号量锁</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    print(&quot;run the thread: %s\n&quot; % n)</span><br><span class="line">    semaphore.release()   # 释放信号量锁</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    semaphore = threading.BoundedSemaphore(5)  # 最多允许5个线程同时运行(Bounded:绑定，Semaphore：信号量)</span><br><span class="line">    for i in range(20):</span><br><span class="line">        t = threading.Thread(target=run, args=(i,))</span><br><span class="line">        t.start()</span><br><span class="line">while threading.active_count() != 1:</span><br><span class="line">    pass</span><br><span class="line">else:</span><br><span class="line">    print(&apos;----all threads done---&apos;)</span><br></pre></td></tr></table></figure><p>上面程序的执行，会让人感觉是：分了4组，前5个同时完成，然后又5个同时进去。但是实际的效果是：这5个里面如果有3个完成，就会立刻再放3个进去。不会等5个都完成，每出来1个就放进去1个，出来几个放进去几个<br><strong>使用场景和总结</strong></p><ul><li>连接池，线程池，MySQL的有连接池，同一时间有多少个并发，就能连多少个连接。</li><li>我们为了保证我的socket_server，因为python不会默认现在你启动多少个线程，但是你启动的线程越多，就会把系统拉的越慢，就会把程序拉的越慢。这里就可以搞一个我同一时间放100线程个进来，就是用semaphore</li></ul><h2 id="event"><a href="#event" class="headerlink" title="event"></a>event</h2><p>&emsp;&emsp;事件处理的机制：全局定义了一个“Flag”，如果“Flag”值为 False，那么当程序执行 event.wait 方法时就会阻塞，如果“Flag”值为True，那么event.wait 方法时便不再阻塞。<br><strong>threading.Event 实现线程间通信,使用threading.Event可以使一个线程等待其他线程的通知</strong></p><blockquote><ul><li>event = threading.Event()   # 设置一个事件的全局变量</li><li>event.is_set()       # 判断是否已经设置标志位。</li><li>event.wait()         # 没有设置标志位的时候会阻塞，一遇到标志位就不会阻塞 #判断是否已经设置标志位。</li><li>event.set()          # 设置标志位 ，标志位设置了，代表着绿灯，直接通行。</li><li>event.clear()        # 清除标志位，标志位被清空，代表红灯，wait等待变绿灯。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">event = threading.Event()  # 生成线程事件实例</span><br><span class="line"> </span><br><span class="line">def lighter():</span><br><span class="line">    count = 0</span><br><span class="line">    event.set()   # 先设置标志位,代表绿灯</span><br><span class="line">    while True:</span><br><span class="line">        if count &gt; 5 and count &lt; 10:   # 改成红灯</span><br><span class="line">            event.clear()    # 清除标志位，变成红灯</span><br><span class="line">            print(&quot;red light is on ....&quot;)</span><br><span class="line">        elif count &gt; 10:</span><br><span class="line">            event.set()   # 创建标志位，变成绿灯</span><br><span class="line">            count = 0</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;green light is on ....&quot;)</span><br><span class="line"> </span><br><span class="line">        time.sleep(1)</span><br><span class="line">        count += 1</span><br><span class="line"> </span><br><span class="line">def car(name):</span><br><span class="line">    while True:</span><br><span class="line">        if event.is_set():   # 有标志位，代表是绿灯</span><br><span class="line">            print(&quot;&#123;0&#125; running ....&quot;.format(name))</span><br><span class="line">            time.sleep(1)</span><br><span class="line">        else:   # 如果不是绿灯就代表红灯</span><br><span class="line">            print(&quot;&#123;0&#125; sees red light ,waiting ....&quot;.format(name))</span><br><span class="line">            event.wait()   # 阻塞</span><br><span class="line">            print(&quot;green light is on , start going ...&quot;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">light = threading.Thread(target=lighter,)  # 启动代表红绿灯的线程</span><br><span class="line">light.start()</span><br><span class="line">car1 = threading.Thread(target=car, args=(&quot;car1&quot;,))  # 启动代表车的线程</span><br><span class="line">car1.start()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;计算机所有的指令的操作都是有CPU来负责的，cpu是来负责运算的。&lt;strong&gt;OS(操作系统) 调度cpu的最小单位就是线程。&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;进程：是以一个整体的形式暴露给操作系统管理，里面包含对各种资源的调用，内存的管理，网络接口的调用等等，是各种资源管理的集合&lt;br&gt;&amp;emsp;&amp;emsp;线程：是操作系统的最小的调度单位，是一串指令的集合。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-常用模块</title>
    <link href="http://yoursite.com/2018/09/12/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/09/12/Python-异常处理/</id>
    <published>2018-09-12T04:25:30.000Z</published>
    <updated>2019-03-27T06:55:33.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python异常处理"><a href="#python异常处理" class="headerlink" title="python异常处理"></a>python异常处理</h2><h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><table><thead><tr><th>异常</th><th>原因</th></tr></thead><tbody><tr><td>AttributeError</td><td>试图访问一个对象没有的树形，比如foo.x，但是foo没有属性x</td></tr><tr><td>FileNotFoundError</td><td>输入/输出异常；基本上是无法打开文件</td></tr><tr><td>ImportError</td><td>无法引入模块或包；基本上是路径问题或名称错误</td></tr><tr><td>IndexError</td><td>下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]</td></tr><tr><td>NameError</td><td>使用一个还未被赋予对象的变量</td></tr><tr><td>KeyError</td><td>试图访问字典里不存在的键</td></tr><tr><td>KeyboardInterrupt</td><td>键盘中断</td></tr><tr><td>SyntaxError</td><td>Python代码非法，代码不能编译</td></tr><tr><td>IndentationError</td><td>语法错误（的子类）:代码没有正确对齐</td></tr><tr><td>TypeError</td><td>传入对象类型与要求的不符合</td></tr></tbody></table><ul><li>忘记在if,elif,else,for,while,class,def声明末尾添加：</li><li>=和==混淆使用</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    open(&quot;tes.txt&quot;)</span><br><span class="line"></span><br><span class="line">except (KeyError,IndexError) as e :</span><br><span class="line">    print(&quot;没有这个key&quot;,e)</span><br><span class="line"></span><br><span class="line">except IndexError as e :</span><br><span class="line">    print(&quot;列表操作错误&quot;,e)</span><br><span class="line"></span><br><span class="line">except Exception as e:</span><br><span class="line">    print(&quot;未知错误&quot;,e)</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line">    print(&quot;一切正常&quot;)</span><br><span class="line"></span><br><span class="line">finally:</span><br><span class="line">    print(&quot;不管有没有错，都执行&quot;)</span><br></pre></td></tr></table></figure><h3 id="自动触发异常"><a href="#自动触发异常" class="headerlink" title="自动触发异常"></a>自动触发异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    raise Exception(&apos;错误&apos;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;python异常处理&quot;&gt;&lt;a href=&quot;#python异常处理&quot; class=&quot;headerlink&quot; title=&quot;python异常处理&quot;&gt;&lt;/a&gt;python异常处理&lt;/h2&gt;&lt;h3 id=&quot;常见异常&quot;&gt;&lt;a href=&quot;#常见异常&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-常用模块</title>
    <link href="http://yoursite.com/2018/09/11/Python-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/09/11/Python-常用模块/</id>
    <published>2018-09-11T05:25:30.000Z</published>
    <updated>2019-03-27T06:55:37.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h2><h3 id="Time模块"><a href="#Time模块" class="headerlink" title="Time模块"></a>Time模块</h3><ul><li>时间戳: 从1970年1月1日00:00:00开始按秒计算的偏移量</li><li>元组(struct_time): </li></ul><table><thead><tr><th>属性</th><th>值</th><th>备注</th></tr></thead><tbody><tr><td>tm_year</td><td>2019</td><td></td></tr><tr><td>tm_mon</td><td>3</td><td></td></tr><tr><td>tm_mday</td><td>18</td><td></td></tr><tr><td>tm_hour</td><td>10</td><td></td></tr><tr><td>tm_min</td><td>12</td><td></td></tr><tr><td>tm_sec</td><td>23</td><td></td></tr><tr><td>tm_wday</td><td>0</td><td>0-6,0表示周日</td></tr><tr><td>tm_yday</td><td>77</td><td>一年中第几天</td></tr><tr><td>tm_isdst</td><td>0</td><td>是否是夏令时</td></tr></tbody></table><ul><li>格式化(format_time):<blockquote><p>%Y-%m-%d %H:%M:%S</p></blockquote></li></ul><table><thead><tr><th>格式</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>%Y</td><td>年</td><td></td></tr><tr><td>%m</td><td>月</td><td></td></tr><tr><td>%d</td><td>日</td><td></td></tr><tr><td>%H</td><td>时</td><td></td></tr><tr><td>%M</td><td>分</td><td></td></tr><tr><td>%S</td><td>秒</td><td></td></tr><tr><td>%w</td><td>周几</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 时间戳</span><br><span class="line">print(time.time())</span><br><span class="line"># 元组</span><br><span class="line">print(time.gmtime())</span><br><span class="line">print(time.localtime())</span><br><span class="line"></span><br><span class="line"># 格式化format</span><br><span class="line">x = time.localtime()</span><br><span class="line">print(time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;,x))</span><br><span class="line"></span><br><span class="line"># 去格式化,转换为元组</span><br><span class="line">print(time.strptime(&apos;2019-03-18 12:03:54&apos;, &apos;%Y-%m-%d %H:%M:%S&apos;))</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/20191918/1202-t.png" alt=""></p><ul><li>结构化时间转换成字符串时间</li></ul><p>对于time.localtime()的类型是<code>&lt;class &#39;time.struct_time&#39;&gt;</code>, 如果转换为字符串类型使用asctime()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = time.localtime()</span><br><span class="line">print(time.asctime(x))</span><br><span class="line">print(type(time.asctime(x)))</span><br><span class="line"></span><br><span class="line">Sat Mar 23 12:54:56 2019</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure></p><ul><li><p>时间戳转换为字符串时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(time.ctime())</span><br><span class="line">print(type(time.ctime()))</span><br><span class="line"></span><br><span class="line">Sat Mar 23 12:56:57 2019</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure></li><li><p>sleep()</p></li></ul><p>延迟给定的秒数</p><ul><li>clock()</li></ul><p>用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="http://www.runoob.com/python/python-date-time.html" target="_blank" rel="noopener">Time模块</a></li></ul><h3 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a>datetime模块</h3><p>datatime模块重新封装了time模块，提供更多接口，datetime.py中主要有如下几个类:<br>|类名|功能|<br>|-|-|<br>|date|日期对象,常用的属性有year, month, day|<br>|time|时间对象,常用的属性有hour, minute, second, microsecond|<br>|datetime|日期时间对象|<br>|timedelta|时间间隔，即两个时间点之间的长度|<br>|tzinfo|时区信息对象|</p><h4 id="date类"><a href="#date类" class="headerlink" title="date类"></a>date类</h4><ul><li><p>date对象由year年份、month月份及day日期三部分构成：<code>date（year，month，day)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">a = datetime.date.today()</span><br><span class="line">print(a.year)</span><br><span class="line">print(getattr(a, &apos;year&apos;))</span><br><span class="line">print(a.__getattribute__(&apos;year&apos;))</span><br></pre></td></tr></table></figure></li><li><p>date对象中包含的方法与属性<br>日期比较|格式转换|字符串输出</p></li></ul><h4 id="time类"><a href="#time类" class="headerlink" title="time类"></a>time类</h4><ul><li>time类由hour小时、minute分钟、second秒、microsecond毫秒和tzinfo五部分组成</li><li>方法与date类似</li></ul><h4 id="datetime类"><a href="#datetime类" class="headerlink" title="datetime类"></a>datetime类</h4><ul><li>datetime类其实是可以看做是date类和time类的合体，其大部分的方法和属性都继承于这二个类</li><li>专属于datetime的方法和属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">a = datetime.datetime.now()</span><br><span class="line"># a是一个datetime.datetime对象</span><br><span class="line">print(a)</span><br><span class="line"># 返回一个datetime对象的日期部分</span><br><span class="line">print(a.date())</span><br><span class="line"></span><br><span class="line">2019-03-23 13:58:33.661258</span><br><span class="line">2019-03-23</span><br></pre></td></tr></table></figure></li></ul><h4 id="timedelta类"><a href="#timedelta类" class="headerlink" title="timedelta类"></a>timedelta类</h4><p>timedelta类是用来计算二个datetime对象的差值的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d1 = datetime.datetime.now()</span><br><span class="line">d2 = d1 + datetime.timedelta(hours = 8)</span><br></pre></td></tr></table></figure></p><h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.cnblogs.com/awakenedy/articles/9182036.html" target="_blank" rel="noopener">Python datetime模块详解</a></li></ul><h3 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">random.randrange(1,7)  # 随机整数,不包括7</span><br><span class="line">random.randint(1,7)  # 实现也是调用randrange,不过b+1,所以包括7</span><br><span class="line">random.choice(&apos;hello&apos;)  # 获取随机的一个元素</span><br></pre></td></tr></table></figure><ul><li>获取随机长度字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def random_str(random_length=8):</span><br><span class="line">    str = &apos;&apos;</span><br><span class="line">    Chars = &apos;AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz01234567890&apos;</span><br><span class="line">    lens = len(Chars) - 1</span><br><span class="line">    for i in range(random_length):</span><br><span class="line">        str += Chars[random.randint(0,lens)]</span><br><span class="line">    return str</span><br></pre></td></tr></table></figure></li></ul><h3 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">os.environ  #获取系统环境变量</span><br><span class="line"></span><br><span class="line"># 路径拼接</span><br><span class="line">print(os.path.join(r&quot;C:\article_spider\utils&quot;, &quot;study_python.py&quot;))</span><br><span class="line">&gt;&gt;&gt; C:\article_spider\utils\study_python.py</span><br><span class="line"></span><br><span class="line"># 如果path存在，返回True；如果path不存在，返回False</span><br><span class="line">print(os.path.exists(r&apos;C:\Users\HDU-rib\Documents\Python\ArticleSpider\article_spider\article_spider\utils&apos;))</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">print(os.path.abspath(__file__))  #返回path规范化的绝对路径</span><br><span class="line">print(os.path.split(__file__))  #按照路径将路径和文件名分割开</span><br><span class="line">print(os.path.dirname(__file__))  #返回path的目录。其实就是os.path.split(path)的第一个元素</span><br><span class="line">print(os.path.basename(__file__)) #返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</span><br><span class="line"></span><br><span class="line"># 获取当前工作目录，即当前python脚本工作的目录路径</span><br><span class="line">print(os.getcwd())</span><br><span class="line">print(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line"></span><br><span class="line">C:\Users\HDU-rib\Documents\Python\ArticleSpider\article_spider\article_spider\utils\study_python.py</span><br><span class="line">(&apos;C:/Users/HDU-rib/Documents/Python/ArticleSpider/article_spider/article_spider/utils&apos;, &apos;study_python.py&apos;)</span><br><span class="line">C:/Users/HDU-rib/Documents/Python/ArticleSpider/article_spider/article_spider/utils</span><br><span class="line">study_python.py</span><br><span class="line">C:\Users\HDU-rib\Documents\Python\ArticleSpider\article_spider\article_spider\utils</span><br><span class="line">C:\Users\HDU-rib\Documents\Python\ArticleSpider\article_spider\article_spider\utils</span><br></pre></td></tr></table></figure><h4 id="正斜杠与反斜杠"><a href="#正斜杠与反斜杠" class="headerlink" title="正斜杠与反斜杠"></a>正斜杠与反斜杠</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">path = r&quot;C:\Windows\temp\readme.txt&quot;</span><br><span class="line">path1 = r&quot;c:\windows\temp\readme.txt&quot;</span><br><span class="line">path2 = &quot;c:\\windows\\temp\\readme.txt&quot;</span><br><span class="line">path3 = &quot;c:/windows/temp/readme.txt&quot;</span><br><span class="line">打开文件函数open()中的参数可以是path也可以是path1、path2、path3。</span><br><span class="line"></span><br><span class="line">path：&quot;\&quot;为字符串中的特殊字符，加上r后变为原始字符串，则不会对字符串中的&quot;\t&quot;、&quot;\r&quot; 进行字符串转义；</span><br><span class="line">path1：大小写不影响windows定位到文件；</span><br><span class="line">path2：用一个&quot;\&quot;取消第二个&quot;\&quot;的特殊转义作用，即为&quot;\\&quot;；</span><br><span class="line">path3：用正斜杠做目录分隔符也可以转到对应目录，并且在python中path3的方式也省去了反斜杠\转义的烦恼。</span><br></pre></td></tr></table></figure><h3 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 退出程序,正常退出时exit(0)</span><br><span class="line">print(sys.exit(0))</span><br><span class="line"># 获取Python解释程序的版本信息</span><br><span class="line">print(sys.version)</span><br><span class="line"># 返回模块的搜索路径,初始化时使用PYTHONPATH环境变量的值</span><br><span class="line">print(sys.path)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 从程序外部获取参数</span><br><span class="line">import os, sys</span><br><span class="line">print(sys.argv) # 命令行参数List，第一个元素是程序本身路径</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; python study_python.py 1 2 3</span><br><span class="line">[&apos;study_python.py&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;]</span><br></pre></td></tr></table></figure><h3 id="Json和pickle模块"><a href="#Json和pickle模块" class="headerlink" title="Json和pickle模块"></a>Json和pickle模块</h3><ul><li>为什么要序列化</li></ul><p>在编程语言中，’状态’会以各种各样有结构的数据类型(也可简单的理解为变量)的形式被保存在内存中。内存是无法永久保存数据的，当程序运行了一段时间，我们断电或者重启程序，内存中关于这个程序的之前一段时间的数据（有结构）都被清空了。在断电或重启程序之前将程序当前内存中所有的数据都保存下来（保存到文件中），以便于下次程序执行能够从文件中载入之前的数据，然后继续执行，这就是序列化。</p><ul><li>跨平台数据交互</li></ul><p>序列化之后，不仅可以把序列化后的内容写入磁盘，还可以通过网络传输到别的机器上，如果收发的双方约定好实用一种序列化的格式，那么便打破了平台/语言差异化带来的限制，实现了跨平台数据交互。反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化。</p><ul><li>JSON和Python内置的数据类型对应如下</li></ul><p><img src="http://qiniu.rearib.top/FjPwIpnFJVujqDcqkOMX1gbSX9Ht" alt=""></p><ul><li><a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00138683221577998e407bb309542d9b6a68d9276bc3dbe000" target="_blank" rel="noopener">廖雪峰讲序列化</a></li><li><a href="https://www.cnblogs.com/fengxiongZz/p/6683376.html" target="_blank" rel="noopener">JSON的数据类型</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name, age, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">s = Student(&apos;Bob&apos;, 20, 88)</span><br><span class="line">print(json.dumps(s, default=lambda obj: obj.__dict__))</span><br></pre></td></tr></table></figure><p>在dumps的时候先回判断一下s是否是字符串,如果是直接序列化,如果不是通过函数<code>chunks = self.iterencode(o, _one_shot=True)</code>进行处理,而default函数就是在这里面调用,转换为dict.</p><h4 id="序列化和编解码的区别"><a href="#序列化和编解码的区别" class="headerlink" title="序列化和编解码的区别"></a>序列化和编解码的区别</h4><ol><li>编码这些应该是针对字符而言的，整形及数值这些是默认二进制编码的。因此，无论是硬盘中还是内存中，虽然存的都是二进制码，但是字符的编码方式可以是utf8,unicode等等。</li><li>序列化只是一种将对象写入字节流的方法而已。可以自己去定义对象的拆分和组装，对象中的字符，写入字节流时，可以选择编码方式，其他的数值型的话，可以直接按照默认的二进制码进行序列化。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">d = &quot;adc中&quot;</span><br><span class="line"></span><br><span class="line">a = d.encode(&apos;utf-8&apos;)</span><br><span class="line">b = json.dumps(d)</span><br><span class="line"></span><br><span class="line">print(d) #编码格式unicode</span><br><span class="line">print(a) #编码格式utf-8</span><br><span class="line">print(b) #编码格式unicode</span><br><span class="line">print(b.encode(&apos;utf-8&apos;))</span><br><span class="line">print(type(d))</span><br><span class="line">print(type(a))</span><br><span class="line">print(type(b))</span><br><span class="line"></span><br><span class="line">adc中</span><br><span class="line">b&apos;adc\xe4\xb8\xad&apos;</span><br><span class="line">&quot;adc\u4e2d&quot;</span><br><span class="line">b&apos;&quot;adc\\u4e2d&quot;&apos;</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br><span class="line">&lt;class &apos;bytes&apos;&gt;</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="configparser模块"><a href="#configparser模块" class="headerlink" title="configparser模块"></a>configparser模块</h3><p>configparser模块在python中用来读取配置文件，配置文件的格式跟windows下的ini配置文件相似，可以包含一个或多个节(section), 每个节可以有多个参数（键=值）。使用的配置文件的好处就是不用在程序员写死，可以使程序更灵活。 </p><h4 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config[&apos;default&apos;] = &#123;&apos;ServerAliveInterval&apos;:&apos;45&apos;,</span><br><span class="line">                     &apos;Compression&apos;:&apos;yes&apos;,</span><br><span class="line">                     &apos;CompressionLevel&apos;:&apos;9&apos;&#125;</span><br><span class="line"></span><br><span class="line">config[&apos;bitbucket.org&apos;] = &#123;&#125;</span><br><span class="line">config[&apos;bitbucket.org&apos;][&apos;User&apos;] = &apos;hg&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">config[&apos;topsecret.server.com&apos;] = &#123;&apos;port&apos;:&apos;50022&apos;,</span><br><span class="line">                                &apos;Forwardx11&apos;:&apos;no&apos;&#125;</span><br><span class="line"></span><br><span class="line">with open(&apos;example.ini&apos;,&apos;w&apos;) as configfile:</span><br><span class="line">    config.write(configfile)</span><br></pre></td></tr></table></figure><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="http://qiniu.rearib.top/FroM0xV5guoCMHDMdyNjMx0MXUgi" alt=""></p><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">读取配置文件</span><br><span class="line">sections() 得到所有的section，并以列表的形式返回</span><br><span class="line">options(section) 得到该section的所有option</span><br><span class="line">items(section) 得到该section的所有键值对</span><br><span class="line">get(section,option) 得到section中option的值，返回为string类型</span><br><span class="line">getint(section,option) 得到section中option的值，返回为int类型</span><br><span class="line">getfloat(section,option)得到section中option的值，返回为float类型</span><br><span class="line">getboolean(section, option)得到section中option的值，返回为boolean类型</span><br><span class="line">写入配置文件</span><br><span class="line"></span><br><span class="line">add_section(section) 添加一个新的section</span><br><span class="line">has_section(section) 判断是否有section</span><br><span class="line">set(section, option, value) 对section中的option进行设置</span><br><span class="line">remove_setion(section)删除一个section</span><br><span class="line">remove_option(section, option)删除section中的option</span><br><span class="line">write(fileobject)将内容写入配置文件。</span><br></pre></td></tr></table></figure><h3 id="hashlib模块"><a href="#hashlib模块" class="headerlink" title="hashlib模块"></a>hashlib模块</h3><h4 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h4><p>Python里面的hashlib模块提供了很多加密的算法, 比如md5(),sha1(),sha224(),sha256(),sha384(),sha512()等等</p><ul><li>用hashlib的md5算法加密数据:</li></ul><p>python3中str在内存中是unicode形式, 被加密的内容需要时bytes类型的, 所以需要使用encode编码.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line"># 先生成md5对象，md5不能反解，但是加密是固定的，就是关系是一一对应，所以有缺陷，可以被对撞出来</span><br><span class="line">hash = hashlib.md5() </span><br><span class="line"># 要对哪个字符串进行加密，就放这里 </span><br><span class="line">hash.update(bytes(&apos;admin&apos;, encoding=&apos;utf-8&apos;)) </span><br><span class="line"># 返回二进制的加密结果</span><br><span class="line">print(hash.digest())</span><br><span class="line"># 十六进制的加密结果</span><br><span class="line">print(hash.hexdigest()) </span><br><span class="line"></span><br><span class="line"># 如果使用其他方式加密, 只需要将md5修改为对应加密算法</span><br><span class="line">hash = hashlib.sha384()</span><br><span class="line"></span><br><span class="line"># 如果没有参数，所有md5遵守一个规则，生成同一个对应关系，如果加了参数，就是在原先加密的基础上再加密一层，这样的话参数只有自己知道，防止被撞库，因为别人永远拿不到这个参数</span><br><span class="line">hash = hashlib.md5(bytes(&apos;key&apos;,encoding=&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure></p><h4 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h4><p>Base64只是一种编码算法，而非加密算法。任何人都可以将Base64的编码结果解码成唯一的原文。</p><ul><li><a href="https://www.cnblogs.com/diligenceday/p/6002382.html" target="_blank" rel="noopener">Base64原理解析</a></li><li><a href="https://blog.csdn.net/wufaliang003/article/details/79573512" target="_blank" rel="noopener">什么是Base64算法</a></li></ul><h3 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h3><h4 id="处理函数"><a href="#处理函数" class="headerlink" title="处理函数"></a>处理函数</h4><ul><li>re.match函数</li></ul><p>re.match尝试从字符串的起始位置匹配，如果起始位置匹配不成功，match()就返回none。可以使用group(num)或groups()匹配对象函数来获取匹配表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">re_obj = re.match(&apos;www&apos;, &apos;www.runoob.com&apos;) # 在起始位置匹配</span><br><span class="line">if re_obj:</span><br><span class="line">    print(re_obj.group(0)) # www</span><br><span class="line">re_obj = re.match(&apos;com&apos;, &apos;www.runoob.com&apos;) # 不在起始位置匹配</span><br><span class="line">if re_obj:</span><br><span class="line">    print(re_obj.group(0)) # None</span><br></pre></td></tr></table></figure></p><ul><li>re.search函数</li></ul><p>re.search 扫描整个字符串并返回第一个成功的匹配。如果匹配失败返回None, 可以使用group(num)或groups()匹配对象函数来获取匹配表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">re_obj = re.search(&apos;www&apos;, &apos;www.runoob.com&apos;) # 在起始位置匹配</span><br><span class="line">if re_obj:</span><br><span class="line">    print(re_obj.group(0)) # www</span><br><span class="line">re_obj = re.search(&apos;com&apos;, &apos;www.runoob.com&apos;) # 不在起始位置匹配</span><br><span class="line">if re_obj:</span><br><span class="line">    print(re_obj.group(0)) # com</span><br></pre></td></tr></table></figure></p><ul><li>re.findall函数</li></ul><p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(re.findall(r&apos;\d+&apos;,&apos;run88oob123google456&apos;))  # [&apos;88&apos;, &apos;123&apos;, &apos;456&apos;]</span><br></pre></td></tr></table></figure><h4 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h4><ol><li><p>^和$在<code>MULTILINE模式</code>下也匹配换行后的首个字符或者最后一个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(re.findall(r&apos;.*foo$&apos;,&apos;1foo\n2foo\n&apos;))</span><br><span class="line">print(re.findall(r&apos;.*foo$&apos;,&apos;1foo\n2foo\n&apos;,re.M))</span><br><span class="line">print(re.findall(r&apos;^foo.*&apos;,&apos;foo1\nfoo2\n&apos;))</span><br><span class="line">print(re.findall(r&apos;^foo.*&apos;,&apos;foo1\nfoo2\n&apos;,re.M))</span><br><span class="line"></span><br><span class="line">[&apos;2foo&apos;]</span><br><span class="line">[&apos;1foo&apos;, &apos;2foo&apos;]</span><br><span class="line">[&apos;foo1&apos;]</span><br><span class="line">[&apos;foo1&apos;, &apos;foo2&apos;]</span><br></pre></td></tr></table></figure></li><li><p>‘*’,’+’,’?’修饰符都是贪婪的, 它们在字符串进行尽可能多的匹配。</p></li><li><p>‘*?’,’+?’,’??’是非贪婪模式匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(re.findall(r&apos;&lt;.*&gt;&apos;,&apos;&lt;a&gt;b&lt;c&gt;&apos;))</span><br><span class="line">print(re.findall(r&apos;&lt;.*?&gt;&apos;,&apos;&lt;a&gt;b&lt;c&gt;&apos;))</span><br><span class="line"></span><br><span class="line">[&apos;&lt;a&gt;b&lt;c&gt;&apos;]</span><br><span class="line">[&apos;&lt;a&gt;&apos;, &apos;&lt;c&gt;&apos;]</span><br></pre></td></tr></table></figure></li><li><p>同理{2,4}是贪婪模式匹配, {2,4}?是非贪婪模式匹配</p></li><li><p>正则对象保存, 重复调用更高效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prog = re.compile(pattern)</span><br><span class="line">result = prog.match(string)</span><br><span class="line">等价于</span><br><span class="line">result = re.match(pattern, string)</span><br></pre></td></tr></table></figure></li><li><p>注意即便是MULTILINE多行模式，re.match()也只匹配字符串的开始位置，而不匹配每行开始。</p></li><li>[] 范围, () 提取 , {} 长度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(0-9) 匹配&apos;0-9&apos;本身</span><br><span class="line">[0-9]* 匹配数字,可为空</span><br><span class="line">[0-9]+ 匹配数字,不可为空</span><br><span class="line">&#123;0-9&#125; 表达式错误</span><br><span class="line">[0-9]&#123;0,9&#125; 长度为0-9的数字</span><br></pre></td></tr></table></figure></li></ol><h4 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h4><p><img src="http://qiniu.rearib.top/Fsq0Av2ZAUmcZSwgL0WSRiQ5ViO7" alt=""></p><ul><li><a href="https://docs.python.org/zh-cn/3.7/library/re.html#re.ASCII" target="_blank" rel="noopener">官方文档</a></li></ul><h4 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h4><ul><li>在源码开头详细介绍了匹配规则</li><li><a href="https://docs.python.org/zh-cn/3.7/library/re.html" target="_blank" rel="noopener">官方文档</a></li></ul><h4 id="“回车”与“换行”的区别"><a href="#“回车”与“换行”的区别" class="headerlink" title="“回车”与“换行”的区别"></a>“回车”与“换行”的区别</h4><ul><li>‘\r’回到行首, ‘\n’换到下一行(0x0d 0x0a)</li><li><a href="https://www.cnblogs.com/dawn-l/p/5180373.html" target="_blank" rel="noopener">关于“回车”的有趣历史及“回车”与“换行”的区别</a></li></ul><h3 id="logging模块"><a href="#logging模块" class="headerlink" title="logging模块"></a>logging模块</h3><h4 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h4><ul><li>日志等级是从上到下依次升高的，即：DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL，而日志的信息量是依次减少的</li></ul><p><img src="http://qiniu.rearib.top/Fgq9GfhbwMz6ZvauLg0NXDFxPGcZ" alt=""></p><h4 id="logging模块提供了两种记录日志的方式："><a href="#logging模块提供了两种记录日志的方式：" class="headerlink" title="logging模块提供了两种记录日志的方式："></a>logging模块提供了两种记录日志的方式：</h4><ul><li>第一种方式是使用logging提供的模块级别的函数</li></ul><p><img src="http://qiniu.rearib.top/FinYuDarZopIlvEzKG7uJyhIBe-2" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"> </span><br><span class="line"># 配置文件名, 文件读写模式, 日志级别, 输出格式等</span><br><span class="line">logging.basicConfig(level=logging.WARNING,</span><br><span class="line">                format=&apos;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&apos;,</span><br><span class="line">                datefmt=&apos;%a, %d %b %Y %H:%M:%S&apos;,</span><br><span class="line">                filename=&apos;myapp.log&apos;,</span><br><span class="line">                filemode=&apos;w&apos;)</span><br><span class="line">    </span><br><span class="line">logging.debug(&apos;This is debug message&apos;)</span><br><span class="line">logging.info(&apos;This is info message&apos;)</span><br><span class="line">logging.warning(&apos;This is warning message&apos;)</span><br><span class="line"></span><br><span class="line">logging.basicConfig函数各参数:</span><br><span class="line">filename: 指定日志文件名</span><br><span class="line">filemode: 和file函数意义相同，指定日志文件的打开模式，&apos;w&apos;或&apos;a&apos;</span><br><span class="line">format: 指定输出的格式和内容，format可以输出很多有用信息，如上例所示:</span><br><span class="line"> %(levelno)s: 打印日志级别的数值</span><br><span class="line"> %(levelname)s: 打印日志级别名称</span><br><span class="line"> %(pathname)s: 打印当前执行程序的路径，其实就是sys.argv[0]</span><br><span class="line"> %(filename)s: 打印当前执行程序名</span><br><span class="line"> %(funcName)s: 打印日志的当前函数</span><br><span class="line"> %(lineno)d: 打印日志的当前行号</span><br><span class="line"> %(asctime)s: 打印日志的时间</span><br><span class="line"> %(thread)d: 打印线程ID</span><br><span class="line"> %(threadName)s: 打印线程名称</span><br><span class="line"> %(process)d: 打印进程ID</span><br><span class="line"> %(message)s: 打印日志信息</span><br><span class="line">datefmt: 指定时间格式，同time.strftime()</span><br><span class="line">level: 设置日志级别，默认为logging.WARNING</span><br></pre></td></tr></table></figure></p><ol><li>设置的日志级别是WARNING，因此只有WARNING级别的日志记录以及大于它的ERROR和CRITICAL级别的日志记录被输出了，而小于它的DEBUG和INFO级别的日志记录被丢弃了。</li><li>logging.basicConfig()函数是一个一次性的简单配置工具，也就是说只有在第一次调用该函数时会起作用，后续再次调用该函数时完全不会产生任何操作的，多次调用的设置并不是累加操作。</li></ol><ul><li>第二种方式是使用Logging日志系统的四大组件</li></ul><p><img src="http://qiniu.rearib.top/Fp-gmev2Q-Q_JjbmoJw58Nqmb2Pp" alt=""></p><p><img src="http://qiniu.rearib.top/FkZfKqKEE0a3xCzoxh6NJ_JdQ9nt" alt=""></p><p><img src="http://qiniu.rearib.top/Fkj0DHle0hui2Q3PLbD2z5xgcrlE" alt=""></p><ul><li><a href="https://www.cnblogs.com/yyds/p/6901864.html" target="_blank" rel="noopener">Python之日志处理（logging模块）</a></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li>使用logging四大组件记录日志</li></ul><p><img src="http://qiniu.rearib.top/FhO5owR9Sr5poVjz-3zpKt3aS4Pu" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">import logging.handlers</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"># 得到一个Logger对象</span><br><span class="line">logger = logging.getLogger(&apos;mylogger&apos;)</span><br><span class="line"># 设置日志器将会处理的日志消息的最低严重级别</span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"># 将日志消息发送到磁盘文件，并支持日志文件按时间切割</span><br><span class="line">rf_handler = logging.handlers.TimedRotatingFileHandler(&apos;all.log&apos;, when=&apos;midnight&apos;, interval=1, backupCount=7, atTime=datetime.time(0, 0, 0, 0))</span><br><span class="line"># 为handler设置一个格式器对象</span><br><span class="line">rf_handler.setFormatter(logging.Formatter(&quot;%(asctime)s - %(levelname)s - %(message)s&quot;))</span><br><span class="line"></span><br><span class="line"># 将日志消息发送到磁盘文件，默认情况下文件大小会无限增长</span><br><span class="line">f_handler = logging.FileHandler(&apos;error.log&apos;)</span><br><span class="line"># 设置handler将会处理的日志消息的最低严重级别</span><br><span class="line">f_handler.setLevel(logging.ERROR)</span><br><span class="line"># 为handler设置一个格式器对象</span><br><span class="line">f_handler.setFormatter(logging.Formatter(&quot;%(asctime)s - %(levelname)s - %(filename)s[:%(lineno)d] - %(message)s&quot;))</span><br><span class="line"></span><br><span class="line"># 将日志消息发送给一个指定的email地址(mailhost, fromaddr, toaddrs, subject, credentials=None)</span><br><span class="line">sh = logging.handlers.SMTPHandler((&quot;smtp.163.com&quot;, 25), &apos;****@163.com&apos;,</span><br><span class="line">                                  [&apos;****@qq.com&apos;,],</span><br><span class="line">                                  &quot;邮件标题&quot;,</span><br><span class="line">                                  credentials=(&apos;username&apos;, &apos;password&apos;),</span><br><span class="line">                                  )</span><br><span class="line"></span><br><span class="line"># 为该logger对象添加handler对象</span><br><span class="line">logger.addHandler(rf_handler)</span><br><span class="line">logger.addHandler(f_handler)</span><br><span class="line">logger.addHandler(sh) #将收到5条邮件(=_=)</span><br><span class="line"></span><br><span class="line">logger.debug(&apos;debug message&apos;)</span><br><span class="line">logger.info(&apos;info message&apos;)</span><br><span class="line">logger.warning(&apos;warning message&apos;)</span><br><span class="line">logger.error(&apos;error message&apos;)</span><br><span class="line">logger.critical(&apos;critical message&apos;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用模块&quot;&gt;&lt;a href=&quot;#常用模块&quot; class=&quot;headerlink&quot; title=&quot;常用模块&quot;&gt;&lt;/a&gt;常用模块&lt;/h2&gt;&lt;h3 id=&quot;Time模块&quot;&gt;&lt;a href=&quot;#Time模块&quot; class=&quot;headerlink&quot; title=&quot;Time模
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Django-编辑器Markdown的使用</title>
    <link href="http://yoursite.com/2018/09/01/Django-%E7%BC%96%E8%BE%91%E5%99%A8Markdown%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/09/01/Django-编辑器Markdown的使用/</id>
    <published>2018-09-01T14:46:43.000Z</published>
    <updated>2019-03-27T07:22:46.095Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;之前的一篇博客写到了如何在django中使用Ueditor,今天我们看看如何在django中使用Markdown进行文本的编辑.它是基于<a href="https://pandao.github.io/editor.md/" target="_blank" rel="noopener">editor.md</a>插件</p><h1 id="Markdown的安装"><a href="#Markdown的安装" class="headerlink" title="Markdown的安装"></a>Markdown的安装</h1><p>Markdown使用的是源码安装的方式:</p><ol><li>首先到<a href="https://github.com/feiyin0719/django-markdown-editor.git" target="_blank" rel="noopener">github</a>下载源码</li><li>把里面的markdown文件夹放到extra_apps中</li><li>然后在INSTALLED_APPS中添加markdown.并在url.py中添加:<blockquote><p>url(r’^markdown/‘, include(‘markdown.urls’)),</p></blockquote></li><li>在setting.py中设置图片上传的文件夹<blockquote><p>MARKDOWN_IMAGE_FLODER = ‘ markdown ‘  #图片会上传到media/markdown文件夹下</p></blockquote></li><li>配置上传图片格式<blockquote><p>MARKDOWN_IMAGE_FORMATS = [“jpg”，”jpeg”，”gif”，”png”，”bmp”，”webp”]</p></blockquote></li></ol><h1 id="在admin中使用"><a href="#在admin中使用" class="headerlink" title="在admin中使用"></a>在admin中使用</h1><p>&emsp;&emsp;所有的TextField都使用markdown编辑器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">from markdown.widgets import AdminMarkdownWidget</span><br><span class="line"></span><br><span class="line">class TestAdmin(admin.ModelAdmin):</span><br><span class="line">    formfield_overrides = &#123;</span><br><span class="line">        models.TextField: &#123;&apos;widget&apos;: AdminMarkdownWidget()&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">admin.site.register(Test,TestAdmin)</span><br></pre></td></tr></table></figure></p><h1 id="在xadmin中使用"><a href="#在xadmin中使用" class="headerlink" title="在xadmin中使用"></a>在xadmin中使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">from markdown.widgets import XAdminMarkdownWidget</span><br><span class="line"></span><br><span class="line">class TestAdmin(admin.ModelAdmin):</span><br><span class="line">    formfield_overrides = &#123;</span><br><span class="line">        models.TextField: &#123;&apos;widget&apos;: XAdminMarkdownWidget()&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">xadmin.site.register(Test,TestAdmin)</span><br></pre></td></tr></table></figure><h1 id="在form中使用"><a href="#在form中使用" class="headerlink" title="在form中使用"></a>在form中使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django import forms</span><br><span class="line">from markdown.forms import MarkdownField</span><br><span class="line"></span><br><span class="line">class BlogForm(forms.Form):</span><br><span class="line">    name = forms.CharField()</span><br><span class="line">    context = MarkdownField()</span><br></pre></td></tr></table></figure><p>这里注意在前端需要添加去添加css和js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Hello Django!&lt;/title&gt;</span><br><span class="line">    &#123;&#123;form.media&#125;&#125;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&#123;&#123;form&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><h1 id="支持参数"><a href="#支持参数" class="headerlink" title="支持参数"></a>支持参数</h1><blockquote><p>width<br>height<br>theme<br>previewTheme<br>editorTheme<br>syncScrolling<br>saveHTMLToTextarea<br>emoji<br>taskList<br>tocm<br>tex<br>flowChart<br>sequenceDiagram<br>codeFold</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">formfield_overrides = &#123;</span><br><span class="line">        models.TextField: &#123;&apos;widget&apos;: AdminMarkdownWidget(emoji=False)&#125;,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="最终后端效果"><a href="#最终后端效果" class="headerlink" title="最终后端效果"></a>最终后端效果</h1><p><img src="http://qiniu.rearib.top/django-编辑器Markdown的使用/20180902125815711.png" alt=""></p><h1 id="前端显示"><a href="#前端显示" class="headerlink" title="前端显示"></a>前端显示</h1><p><img src="http://qiniu.rearib.top/django-编辑器Markdown的使用/20180902013144792.png" alt=""><br>&emsp;&emsp;你会发现前端显示是有问题的,这个时候需要把markdown语法转换为html,我们需要安装django-markdown-deux.</p><ol><li>首先运行<blockquote><p>pip install django-markdown-deux</p></blockquote></li><li>在INSTALLED_APPS中添加markdown_deux</li><li>在需要显示markdown的页面:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load markdown_deux_tags %&#125;</span><br><span class="line">&#123;&#123; course.detail | markdown &#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><p>最后效果:<br><img src="http://qiniu.rearib.top/django-编辑器Markdown的使用/1.png" alt=""></p><p><strong>&emsp;&emsp;这里还有一个问题就是无法修改图片的大小,目前没有比较有效的解决办法,如果对图片大小要求比较高,可以使用七牛等支持参数的图床,如果有其他想法,欢迎交流~</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;之前的一篇博客写到了如何在django中使用Ueditor,今天我们看看如何在django中使用Markdown进行文本的编辑.它是基于&lt;a href=&quot;https://pandao.github.io/editor.md/&quot; target=&quot;_bl
      
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
      <category term="文本编辑" scheme="http://yoursite.com/tags/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>Django-编辑器Ueditor的使用</title>
    <link href="http://yoursite.com/2018/09/01/Django-%E7%BC%96%E8%BE%91%E5%99%A8Ueditor%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/09/01/Django-编辑器Ueditor的使用/</id>
    <published>2018-09-01T14:46:26.000Z</published>
    <updated>2019-03-27T07:22:50.076Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Ueditor是比较流行的富文本编辑器,主要用于内容的编辑、排版和图片上传等。本文主要介绍Ueditor的安装并搭配xadmin的使用。</p><h1 id="富文本编辑器Ueditor"><a href="#富文本编辑器Ueditor" class="headerlink" title="富文本编辑器Ueditor"></a>富文本编辑器Ueditor</h1><p>&emsp;&emsp;UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码。</p><h1 id="Ueditor的源码安装"><a href="#Ueditor的源码安装" class="headerlink" title="Ueditor的源码安装"></a>Ueditor的源码安装</h1><p>&emsp;&emsp;前往<a href="https://github.com/twz915/DjangoUeditor3/" target="_blank" rel="noopener">github</a>下载源码然后解压，把DjangoUeditor文件夹拷贝到项目目录(extra_apps)下面。</p><h1 id="setting和url中的配置"><a href="#setting和url中的配置" class="headerlink" title="setting和url中的配置"></a>setting和url中的配置</h1><ul><li><p>settings中添加app</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &apos;DjangoUeditor&apos;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>MxOnline/urls.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path(&apos;ueditor/&apos;,include(&apos;DjangoUeditor.urls&apos; )),</span><br></pre></td></tr></table></figure></li></ul><h1 id="model和adminx中的配置"><a href="#model和adminx中的配置" class="headerlink" title="model和adminx中的配置"></a>model和adminx中的配置</h1><ul><li><p>course/models.py中Course修改detail字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Course(models.Model):</span><br><span class="line">    # detail = models.TextField(&quot;课程详情&quot;)</span><br><span class="line">    detail = UEditorField(verbose_name=u&apos;课程详情&apos;, width=600, height=300, imagePath=&quot;courses/ueditor/&quot;,</span><br><span class="line">                          filePath=&quot;courses/ueditor/&quot;, default=&apos;&apos;)</span><br></pre></td></tr></table></figure></li><li><p>xadmin/plugs目录下新建ueditor.py文件,代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import xadmin</span><br><span class="line">from xadmin.views import BaseAdminPlugin, CreateAdminView, ModelFormAdminView, UpdateAdminView</span><br><span class="line">from DjangoUeditor.models import UEditorField</span><br><span class="line">from DjangoUeditor.widgets import UEditorWidget</span><br><span class="line">from django.conf import settings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class XadminUEditorWidget(UEditorWidget):</span><br><span class="line">    def __init__(self, **kwargs):</span><br><span class="line">        self.ueditor_options = kwargs</span><br><span class="line">        self.Media.js = None</span><br><span class="line">        super(XadminUEditorWidget,self).__init__(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UeditorPlugin(BaseAdminPlugin):</span><br><span class="line">    def get_field_style(self, attrs, db_field, style, **kwargs):</span><br><span class="line">        if style == &apos;ueditor&apos;:</span><br><span class="line">            if isinstance(db_field, UEditorField):</span><br><span class="line">                widget = db_field.formfield().widget</span><br><span class="line">                param = &#123;&#125;</span><br><span class="line">                param.update(widget.ueditor_settings)</span><br><span class="line">                param.update(widget.attrs)</span><br><span class="line">                return &#123;&apos;widget&apos;:XadminUEditorWidget(**param)&#125;</span><br><span class="line">        return attrs</span><br><span class="line"></span><br><span class="line">    def block_extrahead(self, context, nodes):</span><br><span class="line">        js  = &apos;&lt;script type=&quot;text/javascript&quot; src=&quot;%s&quot;&gt;&lt;/script&gt;&apos; %(settings.STATIC_URL + &quot;ueditor/ueditor.config.js&quot;)</span><br><span class="line">        js += &apos;&lt;script type=&quot;text/javascript&quot; src=&quot;%s&quot;&gt;&lt;/script&gt;&apos; %(settings.STATIC_URL + &quot;ueditor/ueditor.all.min.js&quot;)</span><br><span class="line">        nodes.append(js)</span><br><span class="line"></span><br><span class="line">xadmin.site.register_plugin(UeditorPlugin, UpdateAdminView)</span><br><span class="line">xadmin.site.register_plugin(UeditorPlugin, CreateAdminView)</span><br></pre></td></tr></table></figure></li><li><p>xadmin/plugs/<strong>init</strong>.py里面添加ueditor插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PLUGINS = (</span><br><span class="line">   &apos;ueditor&apos;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>course/adminx.py中使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class CourseAdmin(object):</span><br><span class="line">    #detail就是要显示为富文本的字段名</span><br><span class="line">    style_fields = &#123;&quot;detail&quot;: &quot;ueditor&quot;&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="xadmin后台效果"><a href="#xadmin后台效果" class="headerlink" title="xadmin后台效果"></a>xadmin后台效果</h1><p><img src="http://qiniu.rearib.top/20181812/1407-b.png" alt=""><br>&emsp;&emsp;但是前段显示还是会有问题:<br><img src="http://qiniu.rearib.top/20181812/1407-g.png" alt=""><br>&emsp;&emsp;这是因为需要在模板中必须关闭Django的自动转义才能正常显示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% autoescape off %&#125;</span><br><span class="line">&#123;&#123; course.detail &#125;&#125;</span><br><span class="line">&#123;% endautoescape %&#125;</span><br></pre></td></tr></table></figure></p><h1 id="最终显示效果"><a href="#最终显示效果" class="headerlink" title="最终显示效果"></a>最终显示效果</h1><p><img src="http://qiniu.rearib.top/20181812/1407-R.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;Ueditor是比较流行的富文本编辑器,主要用于内容的编辑、排版和图片上传等。本文主要介绍Ueditor的安装并搭配xadmin的使用。&lt;/p&gt;
&lt;h1 id=&quot;富文本编辑器Ueditor&quot;&gt;&lt;a href=&quot;#富文本编辑器Ueditor&quot; clas
      
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
      <category term="文本编辑" scheme="http://yoursite.com/tags/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>Python-迭代器与生成器</title>
    <link href="http://yoursite.com/2018/09/01/Python-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://yoursite.com/2018/09/01/Python-迭代器与生成器/</id>
    <published>2018-09-01T04:25:30.000Z</published>
    <updated>2019-03-27T06:55:08.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h2><h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><ul><li>如果一个对象拥有<strong>iter</strong>方法，其是可迭代对象；如果一个对象拥有next方法，其是迭代器。</li><li>定义可迭代对象，必须实现<strong>iter</strong>方法；定义迭代器，必须实现<strong>iter</strong>和next方法。所以可迭代对象包含迭代器</li><li>可以使用isinstance()判断一个对象是否是Iterable对象</li><li>可以直接作用于for循环的对象为可迭代对象。 </li></ul><p><img src="http://qiniu.rearib.top/20191918/1032-E.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance([], Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(100, Iterable)</span><br><span class="line">False</span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>任何实现了<strong>iter</strong>和<strong>next</strong>方法的对象都是迭代器, 它是一个带状态的对象</p><ul><li><strong>iter</strong>返回迭代器自身</li><li><strong>next</strong>返回容器中的下一个值</li><li>next()返回容器的下一个值</li><li>从头到尾访问, 不能回退</li><li>迭代到某个对象才开始计算, 节省内存</li><li>如果容器中没有更多元素了，则抛出StopIteration异常</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [1,2,3,4] # list</span><br><span class="line"># 返回可迭代对象的迭代器实例</span><br><span class="line">&gt;&gt;&gt; b = iter(a) </span><br><span class="line">&lt;list_iterator object at 0x0000026CCE6BFEB8&gt;</span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>如果列表元素可以按照某种算法推算出来，我们可以在循环的过程中不断推算出后续的元素呢, 这样就不必创建完整的list，从而节省大量的空间，<strong>在Python中，这种一边循环一边计算的机制，称为生成器：generator</strong></p><ul><li>生成器是一种特殊的迭代器</li><li>生成器在迭代的过程中可以改变当前迭代值，而修改普通迭代器的当前迭代值往往会发生异常</li></ul><h4 id="生成器的创建"><a href="#生成器的创建" class="headerlink" title="生成器的创建"></a>生成器的创建</h4><ul><li><p>方法一 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">L是一个list</span><br><span class="line">&gt;&gt;&gt; L = [x * x for x in range(10)]</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line"></span><br><span class="line">g是一个生成器, 里面保存算法</span><br><span class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; g.__next__()</span><br><span class="line">1</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"></span><br><span class="line"># 通过for循环来迭代它，不需要关心StopIteration错误。</span><br><span class="line">for n in g:</span><br><span class="line">   print(n)</span><br></pre></td></tr></table></figure></li><li><p>方法二</p></li></ul><p>generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator, 在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = fib(10) # 生成器</span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line">print(data.__next__())</span><br><span class="line">print(data.__next__())</span><br></pre></td></tr></table></figure></p><h4 id="send实现协程操作"><a href="#send实现协程操作" class="headerlink" title="send实现协程操作"></a>send实现协程操作</h4><ul><li>send可以传值, 但是是传给yeild, 需要再将yeild再赋值</li><li>send可以在传值完成后接着上次结果继续执行, 相当于next()</li><li><strong>不能传递一个非空值给一个未启动的生成器</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    while True:</span><br><span class="line">        x = yield</span><br><span class="line">        print(&quot;value:&quot;,x)</span><br><span class="line"></span><br><span class="line">g = foo() # g是一个生成器</span><br><span class="line">next(g) # 程序运行到yield就停住了,等待下一个next</span><br><span class="line">g.send(1)  # 我们给yield发送值1,然后这个值被赋值给了x，并且打印出来,然后继续下一次循环停在yield处</span><br><span class="line">g.send(2)  # 同上</span><br><span class="line">next(g)  # 没有给x赋值，执行print语句，打印出None,继续循环停在yield处</span><br></pre></td></tr></table></figure></li></ul><p>解决第一次需要传递空值的办法就是<strong>装饰器</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def deco(func):  # 装饰器:用来开启协程</span><br><span class="line">    def wrapper():</span><br><span class="line">        res = func()</span><br><span class="line">        next(res)</span><br><span class="line">        return res  # 返回一个已经执行了next()方法的函数对象</span><br><span class="line">    return wrapper</span><br><span class="line">@deco</span><br><span class="line">def foo():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p><p>示例代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def deco(func):</span><br><span class="line">    def wrapper():</span><br><span class="line">        res = func()</span><br><span class="line">        next(res)</span><br><span class="line">        return res</span><br><span class="line">    return wrapper</span><br><span class="line">@deco</span><br><span class="line">def foo():</span><br><span class="line">    food_list = []</span><br><span class="line">    while True:</span><br><span class="line">        food = yield food_list  #返回添加food的列表</span><br><span class="line">        food_list.append(food)</span><br><span class="line">        print(&quot;elements in foodlist are:&quot;,food)</span><br><span class="line">g = foo()</span><br><span class="line">print(g.send(&apos;苹果&apos;))</span><br><span class="line">print(g.send(&apos;香蕉&apos;))</span><br><span class="line">print(g.send(&apos;菠萝&apos;))</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>凡是可作用于for循环的对象都是Iterable类型</li><li>凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；</li><li>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;迭代器与生成器&quot;&gt;&lt;a href=&quot;#迭代器与生成器&quot; class=&quot;headerlink&quot; title=&quot;迭代器与生成器&quot;&gt;&lt;/a&gt;迭代器与生成器&lt;/h2&gt;&lt;h3 id=&quot;可迭代对象&quot;&gt;&lt;a href=&quot;#可迭代对象&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>常用Markdown语法说明</title>
    <link href="http://yoursite.com/2018/08/30/Markdown-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/2018/08/30/Markdown-常用语法说明/</id>
    <published>2018-08-30T13:10:19.000Z</published>
    <updated>2018-12-07T07:46:51.749Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，它允许人们“使用易读易写的纯文本格式”编写文档，本文主要针对Hexo中Markdown常用的语法进行总结，更详细的内容请参考Hexo官方书写格式<a href="https://hexo.io/zh-cn/docs/tag-plugins#Image" target="_blank" rel="noopener">链接</a>和Markdown书写格式<a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">链接</a></p><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>Markdown支持两种标题的语法，Setext和atx形式：Setext形式是用底线的形式，利用 = (最高阶标题)和 - (第二阶标题)。Atx形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。<br><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180830101415216.png" alt=""></p><h1 id="最高阶标题"><a href="#最高阶标题" class="headerlink" title="最高阶标题"></a>最高阶标题</h1><h2 id="第二阶标题"><a href="#第二阶标题" class="headerlink" title="第二阶标题"></a>第二阶标题</h2><h1 id="H1标题"><a href="#H1标题" class="headerlink" title="H1标题"></a>H1标题</h1><h2 id="H2标题"><a href="#H2标题" class="headerlink" title="H2标题"></a>H2标题</h2><h3 id="H3标题"><a href="#H3标题" class="headerlink" title="H3标题"></a>H3标题</h3><h4 id="H4标题"><a href="#H4标题" class="headerlink" title="H4标题"></a>H4标题</h4><h5 id="H5标题"><a href="#H5标题" class="headerlink" title="H5标题"></a>H5标题</h5><h6 id="H6标题"><a href="#H6标题" class="headerlink" title="H6标题"></a>H6标题</h6><h1 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h1><p>区块引用则使用 email 形式的 ‘&gt;’ 角括号。<br><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180830101428434.png" alt=""></p><blockquote><p>区块引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote><h1 id="修辞和强调"><a href="#修辞和强调" class="headerlink" title="修辞和强调"></a>修辞和强调</h1><p>强调内容两侧分别加上星号或者底线。<br><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180831094029082.png" alt=""><br><em>斜体</em><br><strong>粗体</strong><br><del>删除</del></p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><ul><li>至少一个-</li><li>使用:来设置对其方式</li></ul><p><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180831094343570.png" alt=""></p><table><thead><tr><th style="text-align:left">第一列</th><th style="text-align:right">第二列</th><th style="text-align:center">第三列</th></tr></thead><tbody><tr><td style="text-align:left">内容</td><td style="text-align:right">内容</td><td style="text-align:center">内容</td></tr></tbody></table><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>无序列表使用星号、加号或减号来做为列表。<br><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180830101500576.png" alt=""></p><ul><li>一号</li><li>二号</li></ul><ul><li>三号</li><li>四号</li></ul><ul><li>五号</li><li>六号</li></ul><h1 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h1><p><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180830101514715.png" alt=""></p><ol><li>一号</li><li>二号</li></ol><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180831094437848.png" alt=""><br>这是我的<a href="http://blog.rearib.top" target="_blank" rel="noopener">博客</a>地址</p><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180831101823686.png" alt=""></p><hr><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>图片的语法和链接很像，只需在链接的基础上前方加一个！<br>注意图片大小的设置方式,关于其他设置可以参考<a href="https://developer.qiniu.com/dora/manual/3683/img-directions-for-use" target="_blank" rel="noopener">七牛云</a><br><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180831101811191.png" alt=""><br><img src="http://qiniu.rearib.top/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180706201017_eviCsbl.jpg?imageView2/1/w/200/h/200/" alt="我的头像"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180831101753642.png" alt=""><br><figure class="highlight objc"><figcaption><span>main.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; i = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">      printf(<span class="string">"hello markdown!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h1><p><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180831103438948.png" alt=""></p><ul><li style="list-style: none"><input type="checkbox" checked> 选项一</li><li style="list-style: none"><input type="checkbox"> 选项二  </li><li style="list-style: none"><input type="checkbox"> 选项三</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Markdown 是一种轻量级标记语言，它允许人们“使用易读易写的纯文本格式”编写文档，本文主要针对Hexo中Markdown常用的语法进行总结，更详细的内容请参考Hexo官方书写格式&lt;a href=&quot;https://hexo.io/zh-cn/docs/tag-plugi
      
    
    </summary>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Python-面向对象编程</title>
    <link href="http://yoursite.com/2018/08/27/Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/27/Python-面向对象编程/</id>
    <published>2018-08-27T12:25:30.000Z</published>
    <updated>2019-03-27T06:55:00.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="变量和方法"><a href="#变量和方法" class="headerlink" title="变量和方法"></a>变量和方法</h3><ul><li>类的变量存在类的内存中, 实例变量存在实例内存中</li><li>对于变量,先找实例本身是否有,如果找不到就去类中找</li><li>静态属性就是变量, 动态属性就是方法</li><li>实例变量作用域是实例本身</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>类的实例化是以类为模板在内存中开辟空间存数据, 赋予变量名</p><p><img src="http://qiniu.rearib.top/FuQ3v-ubBtP6maXxQegXDPx71ziE" alt=""></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是一种创建新类的方式，在python中，新建的类可以继承一个或多个父类，父类又可称为基类或超类，新建的类称为派生类或子类</p><ul><li><p>多继承的查找方式</p></li><li><p><img src="http://qiniu.rearib.top/FifhvwxpCCdwGjNJI0You12g8rvN" alt=""></p></li></ul><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul><li>类的继承: 子类中重新定义某个方法会覆盖父类的同名方法, 如果要同时实现父类的功能, 就要使用super</li><li>super是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用等种种问题。</li><li><a href="https://zhuanlan.zhihu.com/p/23625909" target="_blank" rel="noopener">Python: 你不知道的 super</a></li><li><a href="https://blog.csdn.net/qq_14898613/article/details/53792270" target="_blank" rel="noopener">Python’s super() considered super!</a></li></ul><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p><img src="http://qiniu.rearib.top/FnQ_DDNvyepThkcuPsgUezZ8C0gM" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 类中所有双下划线开头的名称如__x都会在类定义时自动变形成：_类名__x的形式</span><br><span class="line">class A():</span><br><span class="line">    __N = 0</span><br><span class="line">    _M = 1   # 可以在外部调用, 只是给程序员提示</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__N = 10  # _A__N</span><br><span class="line"></span><br><span class="line">    def read(self):</span><br><span class="line">        print(self.__N)</span><br><span class="line"></span><br><span class="line">    def __write(self): # _A__write</span><br><span class="line">        self.__N = 20</span><br><span class="line">        print(self.__N)</span><br><span class="line"></span><br><span class="line">    def write(self):</span><br><span class="line">        self.__write() # 可以在内部调用</span><br><span class="line"></span><br><span class="line">print(dir(A))</span><br><span class="line">a = A()</span><br><span class="line">print(a._M)</span><br><span class="line">a.read()</span><br><span class="line"># a.__write() # 无法调用</span><br><span class="line">a.write()</span><br><span class="line">print(a._A__N) # 可以调用</span><br><span class="line">a._A__write() # 可以调用</span><br><span class="line"></span><br><span class="line">[&apos;_A__N&apos;, &apos;_A__write&apos;, &apos;_M&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;read&apos;, &apos;write&apos;]</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">20</span><br><span class="line">20</span><br><span class="line">20</span><br></pre></td></tr></table></figure><ul><li><a href="https://zhuanlan.zhihu.com/p/36173202" target="_blank" rel="noopener">Python中下划线的5种含义</a></li></ul><h3 id="抽象类与接口类"><a href="#抽象类与接口类" class="headerlink" title="抽象类与接口类"></a>抽象类与接口类</h3><ul><li>抽象类: 只能被继承, 不能实例化, 只能有抽象方法, 没有实现功能, 子类必须实现抽象方法(规范化)</li><li><p>接口继承实现归一化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">python3:</span><br><span class="line">from abc import ABCMeta, abstractmethod</span><br><span class="line">class Pay(metaclass=ABCMeta):</span><br><span class="line">    # 规范一个方法上面加一句@abstractmethod</span><br><span class="line">    @abstractmethod       </span><br><span class="line">    def pay(self):</span><br><span class="line">        pass  </span><br><span class="line"></span><br><span class="line">python2:</span><br><span class="line">class Pay(object):</span><br><span class="line">    __metaclass__ = ABCMeta</span><br><span class="line">    # 规范一个方法上面加一句@abstractmethod</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def pay(self):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure></li><li><p><a href="https://www.cnblogs.com/0627zhou/p/9374698.html" target="_blank" rel="noopener">Python_015(面向对象(接口类,抽象类,多态,封装)</a></p></li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Animal(object):</span><br><span class="line">    def __init__(self, name):  # Constructor of the class</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def talk(self):</span><br><span class="line">        raise NotImplementedError(&quot;Subclass must implement abstract method&quot;)</span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line">    def talk(self):</span><br><span class="line">        print(&apos;%s: 喵喵喵!&apos; % self.name)</span><br><span class="line"></span><br><span class="line">class Dog(Animal):</span><br><span class="line">    def talk(self):</span><br><span class="line">        print(&apos;%s: 汪！汪！汪！&apos; % self.name)</span><br><span class="line"></span><br><span class="line">def func(obj):  # 一个接口，多种形态</span><br><span class="line">    obj.talk()</span><br><span class="line"></span><br><span class="line">c1 = Cat(&apos;小晴&apos;)</span><br><span class="line">d1 = Dog(&apos;李磊&apos;)</span><br><span class="line"></span><br><span class="line">func(c1)</span><br><span class="line">func(d1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 多态性带来的好处，比如Python的序列类型有多种形态：字符串，列表，元组，多态性体现</span><br><span class="line"># str,list,tuple都是序列类型</span><br><span class="line">s=str(&apos;hello&apos;)</span><br><span class="line">l=list([1,2,3])</span><br><span class="line">t=tuple((4,5,6))</span><br><span class="line"></span><br><span class="line"># 我们可以在不考虑三者类型的前提下使用s,l,t</span><br><span class="line">s.__len__()</span><br><span class="line">l.__len__()</span><br><span class="line">t.__len__()</span><br></pre></td></tr></table></figure></p><h3 id="三种方法"><a href="#三种方法" class="headerlink" title="三种方法"></a>三种方法</h3><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><ul><li>可以访问实例变量和类变量</li><li>只能实例对象调用</li></ul><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><ul><li>@staticmethod</li><li>静态方法是不可以访问实例变量或类变量</li><li>可通过实例对象或类对象调用</li><li>不会主动传入self, 调用时可以传入实例本身或者去掉self</li></ul><h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><ul><li>@classmethod</li><li>类方法只能访问类变量，不能访问实例变量</li><li>可通过实例对象或类对象调用</li><li>需要传入cls参数, cls参数指向的是一开始定义的类对象（不是实例对象）</li><li>Django中classonlymethod继承了classmethod，但是classonlymethod只能通过类对象调用，而不能通过实例对象调用as_view()方法，即‘阉割’了实例调用的方式。</li></ul><h4 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h4><ul><li>@property</li><li>调用不需要添加()</li><li>传参<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@property</span><br><span class="line">def password(self):</span><br><span class="line">    return self._password</span><br><span class="line"></span><br><span class="line">@password.setter</span><br><span class="line">def password(self, raw):</span><br><span class="line">    self._password = generate_password_hash(raw)</span><br><span class="line"></span><br><span class="line">self.password = &apos;123456&apos;</span><br></pre></td></tr></table></figure></li></ul><h4 id="对比和适用场景"><a href="#对比和适用场景" class="headerlink" title="对比和适用场景"></a>对比和适用场景</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class MyClass(object):</span><br><span class="line">    # 实例方法</span><br><span class="line">    def instance_method(self):</span><br><span class="line">        print(&apos;instance method called&apos;, self)</span><br><span class="line"></span><br><span class="line">    # 类方法</span><br><span class="line">    @classmethod</span><br><span class="line">    def class_method(cls):</span><br><span class="line">        print(&apos;class method called&apos;, cls)</span><br><span class="line"></span><br><span class="line">    # 静态方法</span><br><span class="line">    @staticmethod</span><br><span class="line">    def static_method():</span><br><span class="line">        print(&apos;static method called&apos;)</span><br><span class="line"></span><br><span class="line"># 通过实例对象调用</span><br><span class="line">my_class = MyClass()        # 实例化</span><br><span class="line">my_class.static_method()    # 静态方法</span><br><span class="line">my_class.class_method()     # 类方法</span><br><span class="line">my_class.instance_method()  # 实例方法</span><br><span class="line"></span><br><span class="line"># 通过类对象调用</span><br><span class="line">MyClass.static_method()     # 静态方法</span><br><span class="line">MyClass.class_method()      # 类方法</span><br><span class="line">MyClass.instance_method()   # 实例方法</span><br><span class="line"></span><br><span class="line">static method called</span><br><span class="line">class method called &lt;class &apos;__main__.MyClass&apos;&gt;</span><br><span class="line">instance method called &lt;__main__.MyClass object at 0x0000021CE87A1160&gt;</span><br><span class="line"></span><br><span class="line">static method called</span><br><span class="line">class method called &lt;class &apos;__main__.MyClass&apos;&gt;</span><br><span class="line"># 报错 instance_method() missing 1 required positional argument: &apos;self&apos;</span><br></pre></td></tr></table></figure><ol><li>类方法无须创建实例对象调用，所以类方法的调用较实例方法更为灵活</li><li>静态方法有点像附属于类对象的“工具”, 将对象的相关处理逻辑“束缚”在对象体内，这样封装得会更好些。</li><li>实例方法只能通过实例对象调用；类方法和静态方法可以通过类对象或者实例对象调用，如果是使用实例对象调用的类方法或静态方法，最终都会转而通过类对象调用。</li><li>实例方法使用最多，可以直接处理实例对象的逻辑；类方法不需要创建实例对象，直接处理类对象的逻辑；静态方法将与类对象相关的某些逻辑抽离出来，不仅可以用于测试，还能便于代码后期维护。</li><li>实例方法和类方法，能够改变实例对象或类对象的状态，而静态方法不能。</li></ol><h3 id="类的特殊方法"><a href="#类的特殊方法" class="headerlink" title="类的特殊方法"></a>类的特殊方法</h3><ul><li>__doc__ 类的描述信息(注释)</li><li>__str__ 打印对象时，默认输出该方法的返回值。</li><li>__init__ 创建对象后，python解释器默认调用该方法</li><li>__del__ 当删除一个对象时，python解释器也会默认调用该方法</li><li>__call__ 对象后加()时执行, 对象 = 类名()</li><li>__module__ 表示当前操作的对象在哪个模块</li><li>__class__ 表示当前操作的对象的类是哪个</li><li>__dict__ 查看类或对象中的所有成员 　　</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MyClass(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;init&apos;)</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(&apos;call&apos;)</span><br><span class="line"></span><br><span class="line"># init</span><br><span class="line">myclass = MyClass()</span><br><span class="line"># call</span><br><span class="line">myclass()</span><br></pre></td></tr></table></figure><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>执行某个方法, 调用某个变量,要确定该方法或者属性是否存在</p><ul><li>hasattr：否有存在对应属性或者方法</li><li>getattr: 获取属性或者方法</li><li>setattr: 添加属性或者方法</li><li>delattr：删除属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &apos;rearib&apos;</span><br><span class="line">    def func(self):</span><br><span class="line">        print(&apos;func&apos;)</span><br><span class="line">obj = Foo()</span><br><span class="line"> </span><br><span class="line"># 检查是否含有成员</span><br><span class="line">hasattr(obj, &apos;name&apos;) # Ture</span><br><span class="line">hasattr(obj, &apos;func&apos;) # Ture</span><br><span class="line"> </span><br><span class="line"># 获取成员</span><br><span class="line">getattr(obj, &apos;name&apos;) # rearib</span><br><span class="line">getattr(obj, &apos;func&apos;) # &lt;bound method Foo.func of &lt;__main__.Foo object at 0x00000268D131EA58&gt;&gt;</span><br><span class="line"> </span><br><span class="line"># 设置成员</span><br><span class="line">setattr(obj, &apos;age&apos;, 18)</span><br><span class="line">setattr(obj, &apos;show&apos;, lambda num: num + 1)</span><br><span class="line"> </span><br><span class="line"># #### 删除成员 ####</span><br><span class="line">delattr(obj, &apos;name&apos;)</span><br><span class="line">delattr(obj, &apos;name&apos;) # 如果属性不存在, 报错</span><br><span class="line">delattr(obj, &apos;func&apos;) # 不能删除对象方法, 报错</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象编程&quot;&gt;&lt;a href=&quot;#面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;面向对象编程&quot;&gt;&lt;/a&gt;面向对象编程&lt;/h2&gt;&lt;h3 id=&quot;变量和方法&quot;&gt;&lt;a href=&quot;#变量和方法&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-数据类型</title>
    <link href="http://yoursite.com/2018/08/26/Python-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/08/26/Python-数据类型/</id>
    <published>2018-08-26T11:25:30.000Z</published>
    <updated>2019-03-27T06:55:27.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><a href="https://www.cnblogs.com/derek1184405959/p/8041926.html" target="_blank" rel="noopener">字符串内置函数</a></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="列表排序reverse、sort、sorted"><a href="#列表排序reverse、sort、sorted" class="headerlink" title="列表排序reverse、sort、sorted"></a>列表排序reverse、sort、sorted</h4><ul><li>reverse() 反转, 不会排序</li><li>sort() 排序, 排序后的新列表会覆盖原列表(默认正向排序)</li><li>sorted() 排序, 可以保留原列表, 又能得到已经排序好的列表(默认正向排序)</li><li>a[::-1] 反转, 不会排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = [1,5,2,3,4]</span><br><span class="line">&gt;&gt;&gt; x.reverse()</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[4, 3, 2, 5, 1]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; a = [5,7,6,3,4,1,2]</span><br><span class="line">&gt;&gt;&gt; a.sort()</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; a = [5,7,6,3,4,1,2]</span><br><span class="line">&gt;&gt;&gt; b = sorted(a)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[5, 7, 6, 3, 4, 1, 2]</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7]</span><br></pre></td></tr></table></figure><h4 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h4><p>同时需要用到index和value值的时候可以用到enumerate，参数为可遍历的变量，如字符串，列表等，返回enumerate类。</p><p><code>(0, seq[0]), (1, seq[1]), (2, seq[2]), ...</code></p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><ul><li>index, count</li></ul><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul><li>items(), keys(), values()</li><li>dict会把所有的key变成hash表，然后将这个表进行排序，这样，你通过data[key]去查data字典中一个key的时候，python会先把这个key hash成一个数字，然后拿这个数字到hash表中看没有这个数字，如果有，拿到这个key在hash表中的索引，拿到这个索引去与此key对应的value的内存地址那取值就可以了。</li></ul><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul><li>set()</li><li>add() 添加一个</li><li>update() 添加多个</li><li>remove() 移除</li><li>交集, 并集, 差集</li></ul><p>可以使用大括号{}或者set()函数创建集合, 注意: 创建一个空集合必须用set()而不是{}, 因为{}是用来创建一个空字典。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parame = &#123;value01,value02,...&#125; # 重复的元素被自动去掉</span><br><span class="line">or</span><br><span class="line">set(value)</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>数字</li><li>字符串</li><li>列表 []</li><li>元组 ()</li><li>字典 {}</li><li>集合 set()</li></ul><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><h3 id="变量-引用-对象"><a href="#变量-引用-对象" class="headerlink" title="变量-引用-对象"></a>变量-引用-对象</h3><p>在Python中一切都是对象, Python中变量是指对象的引用，Python是动态类型，程序运行时候，会根据对象的类型来确认变量到底是什么类型。</p><p>运行a=3后，变量a变成了对象3的一个引用。在内部，变量事实上是到对象内存空间的一个指针</p><p><img src="http://qiniu.rearib.top/20191913/1434-a.png" alt=""></p><p>Python的变量不过是对象的引用，或指向对象的指针，因此在程序中可以经常改变变量引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 42      #变量绑定到整型对象</span><br><span class="line">&gt;&gt;&gt; x = &apos;Hello&apos; #现在又成了字符串</span><br><span class="line">&gt;&gt;&gt; x = [1,2,3] #现在又成了列表</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/20191913/1436-U.png" alt=""></p><h3 id="可变与不可变对象"><a href="#可变与不可变对象" class="headerlink" title="可变与不可变对象"></a>可变与不可变对象</h3><ul><li>在Python中不可变对象指：一旦创建就不可修改的对象，包括字符串，元祖，数字(a=b, a的值发生改变，b不会跟着改变)</li><li>在Python中可变对象是指：可以修改的对象，包括：列表、字典(a=b, a的值发生改变，b也跟着改变)</li></ul><h3 id="深拷贝与浅拷贝-针对可变对象"><a href="#深拷贝与浅拷贝-针对可变对象" class="headerlink" title="深拷贝与浅拷贝(针对可变对象)"></a>深拷贝与浅拷贝(针对可变对象)</h3><ul><li>浅拷贝：只拷贝顶级的对象，或者说：父级对象</li><li>深拷贝：拷贝所有对象，顶级对象及其嵌套对象。或者说：父级对象及其子对象</li><li>深浅拷贝都是对源对象的复制，占用不同的内存空间</li><li>如果源对象只有一级目录的话，源做任何改动，不影响深浅拷贝对象</li><li>如果源对象不止一级目录的话，源做任何改动，都要影响浅拷贝，但不影响深拷贝</li><li>序列对象的切片其实是浅拷贝，即只拷贝顶级的对象</li><li><strong>要想完全无关, 需要使用深拷贝</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;h3 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-话说编码</title>
    <link href="http://yoursite.com/2018/08/16/Python-%E8%AF%9D%E8%AF%B4%E7%BC%96%E7%A0%81/"/>
    <id>http://yoursite.com/2018/08/16/Python-话说编码/</id>
    <published>2018-08-16T11:25:10.000Z</published>
    <updated>2019-03-27T06:55:14.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><ol><li>使用编辑器编写py文件保存只是将内存中unicode编码的内容使用系统或者编辑器的编码方式保存到硬盘中.</li><li>python解释器执行py文件首先是作为一个编辑器将py文件从硬盘中读取到内存, 然后再进行解释.</li><li>python2默认ascii, python3默认utf-8, 在python2文件中有#coding:utf-8, 那么文件会以utf-8方式解码成unicode放到内存中.最终到内存中都是unicode. 但是程序还没有开始解释.</li><li>读取已经加载到内存的代码（unicode编码的二进制），然后执行，<strong>但是程序在执行过程中，会申请内存（与程序代码所存在的内存是俩个空间）</strong>，可以存放任意编码格式的数据，比如x=”egon”,会被python解释器识别为字符串，会申请内存空间来存放”egon”，然后让x指向该内存地址，此时新申请的该内存地址保存也是unicode编码的egon,如果代码换成x=”egon”.encode(‘utf-8’),那么新申请的内存空间里存放的就是utf-8编码的字符串egon了</li></ol><p><img src="http://qiniu.rearib.top/20191913/1303-Q.png" alt=""></p><h3 id="python3中两种字符串类型str和bytes"><a href="#python3中两种字符串类型str和bytes" class="headerlink" title="python3中两种字符串类型str和bytes"></a>python3中两种字符串类型str和bytes</h3><p>str是unicode</p><p>bytes是bytes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">s=&apos;林&apos; #当程序执行时，无需加u，&apos;林&apos;也会被以unicode形式保存新的内存空间中,</span><br><span class="line"></span><br><span class="line">#s可以直接encode成任意编码格式</span><br><span class="line">s1=s.encode(&apos;utf-8&apos;)</span><br><span class="line">s2=s.encode(&apos;gbk&apos;)</span><br><span class="line"></span><br><span class="line">print(s) #林</span><br><span class="line">print(s1) #b&apos;\xe6\x9e\x97&apos; 在python3中，是什么就打印什么</span><br><span class="line">print(s2) #b&apos;\xc1\xd6&apos; 同上</span><br><span class="line"></span><br><span class="line">print(type(s)) #&lt;class &apos;str&apos;&gt;</span><br><span class="line">print(type(s1)) #&lt;class &apos;bytes&apos;&gt;</span><br><span class="line">print(type(s2)) #&lt;class &apos;bytes&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="python2中两种字符串类型str和unicode"><a href="#python2中两种字符串类型str和unicode" class="headerlink" title="python2中两种字符串类型str和unicode"></a>python2中两种字符串类型str和unicode</h3><p>在python2中，<strong>str就是编码后的结果bytes，str=bytes,所以在python2中，unicode字符编码的结果是str/bytes</strong></p><p>当python解释器执行到产生字符串的代码时（例如s=’林’），会申请新的内存地址，然后将’林’encode成文件开头指定的编码格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">s=&apos;林&apos; #在执行时,&apos;林&apos;会被以conding:utf-8的形式保存到新的内存空间中</span><br><span class="line"></span><br><span class="line">print repr(s) #&apos;\xe6\x9e\x97&apos; 三个Bytes,证明确实是utf-8</span><br><span class="line">print type(s) #&lt;type &apos;str&apos;&gt;</span><br><span class="line"></span><br><span class="line">s.decode(&apos;utf-8&apos;)</span><br><span class="line"># s.encode(&apos;utf-8&apos;) #报错，s为编码后的结果bytes，所以只能decode</span><br></pre></td></tr></table></figure><p>当python解释器执行到产生字符串的代码时（例如s=u’林’），会申请新的内存地址，然后将’林’以unicode的格式存放到新的内存空间中，所以s只能encode，不能decode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s=u&apos;林&apos; </span><br><span class="line">print repr(s) #u&apos;\u6797&apos;</span><br><span class="line">print type(s) #&lt;type &apos;unicode&apos;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># s.decode(&apos;utf-8&apos;) #报错，s为unicode，所以只能encode</span><br><span class="line">s.encode(&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure><h3 id="打印到终端"><a href="#打印到终端" class="headerlink" title="打印到终端"></a>打印到终端</h3><p>print(x) #这一步是将x指向的那块新的内存空间（非代码所在的内存空间）中的内存，打印到终端，而终端仍然是运行于内存中的，所以这打印可以理解为从内存打印到内存，即内存-&gt;内存，unicode-&gt;unicode</p><ul><li><p>对于unicode格式的数据来说，即python3中的字符串与python2中的u’字符串’，都是unicode，所以无论如何打印都不会乱码</p></li><li><p>在python2中存在另外一种非unicode的字符串，此时，print x，会按照终端的编码执行x.decode(‘终端编码’)，变成unicode后，再打印，此时终端编码若与文件开头指定的编码不一致，乱码就产生了(在windows终端, 终端编码为gbk, x指向的内容是utf-8编码的, 就会出现乱码)</p></li></ul><h3 id="b和bytes"><a href="#b和bytes" class="headerlink" title="b和bytes"></a>b和bytes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Hello&quot;)</span><br><span class="line">print(type(&quot;Hello&quot;))</span><br><span class="line"></span><br><span class="line">print(bytes(&apos;Hello&apos;,encoding=&apos;utf-8&apos;))</span><br><span class="line"></span><br><span class="line">print(b&quot;Hello&quot;)</span><br><span class="line">print(type(b&quot;Hello&quot;))</span><br><span class="line"></span><br><span class="line">Hello</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br><span class="line">b&apos;Hello&apos;</span><br><span class="line">b&apos;Hello&apos;</span><br><span class="line">&lt;class &apos;bytes&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="常见编码错误的原因："><a href="#常见编码错误的原因：" class="headerlink" title="常见编码错误的原因："></a>常见编码错误的原因：</h3><ul><li>Python解释器的默认编码</li><li>Python源文件文件编码</li><li>Terminal使用的编码</li><li>操作系统的语言设置</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.cnblogs.com/vipchenwei/p/6993788.html" target="_blank" rel="noopener">python编码问题大终结</a></li><li><a href="https://www.cnblogs.com/zihe/p/6993891.html" target="_blank" rel="noopener">Python（字符编码）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编码&quot;&gt;&lt;a href=&quot;#编码&quot; class=&quot;headerlink&quot; title=&quot;编码&quot;&gt;&lt;/a&gt;编码&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;使用编辑器编写py文件保存只是将内存中unicode编码的内容使用系统或者编辑器的编码方式保存到硬盘中.&lt;/li&gt;
&lt;li&gt;py
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
</feed>
