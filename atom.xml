<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rearib的个人博客</title>
  
  <subtitle>面朝大海,春暖花开</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-29T08:51:07.848Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Rearib</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工具-ShareX+七牛云实现私有图床</title>
    <link href="http://yoursite.com/2018/10/29/%E5%B7%A5%E5%85%B7-ShareX+%E4%B8%83%E7%89%9B%E4%BA%91%E5%AE%9E%E7%8E%B0%E7%A7%81%E6%9C%89%E5%9B%BE%E5%BA%8A/"/>
    <id>http://yoursite.com/2018/10/29/工具-ShareX+七牛云实现私有图床/</id>
    <published>2018-10-29T01:33:42.000Z</published>
    <updated>2018-10-29T08:51:07.848Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;所谓图床，就是专门用来存放图片，同时允许你把图片对外连接的网上空间，通过访问链接就能直接查看或者分享图片，特别是个人博客的图片存储需要一个方便高效的私有图床，今天介绍一个通过ShareX+七牛云实现私有图床的方法。<br><a id="more"></a></p><h2 id="什么是七牛云"><a href="#什么是七牛云" class="headerlink" title="什么是七牛云"></a>什么是七牛云</h2><p>&emsp;&emsp;七牛云是国内一家领先的云存储公司，可以利用七牛云存储对象存储图片并生成外链。官网<a href="http://www.qiniu.com/" target="_blank" rel="noopener">地址</a>，注册后会赠送10G的免费空间.</p><h2 id="什么是ShareX"><a href="#什么是ShareX" class="headerlink" title="什么是ShareX"></a>什么是ShareX</h2><p>&emsp;&emsp;截图，这种再寻常不过的事情。有着很多的软件供我们选择，从常用的QQ到使用Snipaste。不光截图的方式多种多样，从处理截图，到上传截图到网络，都有软件能为你服务。但是，从截图，到处理截图，再到上传截图，至少需要用到两个软件。但是一个ShareX就能全部搞定。</p><h2 id="用ShareX-qiniu一键截图上传配置"><a href="#用ShareX-qiniu一键截图上传配置" class="headerlink" title="用ShareX+qiniu一键截图上传配置"></a>用ShareX+qiniu一键截图上传配置</h2><h3 id="1-sharex下载"><a href="#1-sharex下载" class="headerlink" title="1. sharex下载"></a>1. <a href="https://getsharex.com/" target="_blank" rel="noopener">sharex</a>下载</h3><p>&emsp;&emsp;安装后打开如图<br><img src="http://qiniu.rearib.top/20181829/1616-F.png" alt=""></p><h3 id="2-设置图片上传"><a href="#2-设置图片上传" class="headerlink" title="2. 设置图片上传"></a>2. 设置图片上传</h3><p>&emsp;&emsp;打开 shareX -&gt; 目的地 -&gt; 目的地设置 -&gt; 自定义上传（最底下）</p><p><img src="http://qiniu.rearib.top/20181829/1619-B.png" alt=""></p><ul><li>上传者：填入 qiniu，点击添加</li><li>请求 URL：进入自己的「对象存储」-&gt; 空间设置 -&gt; 存储区域，查看自己所在地区。根据 <a href="https://developer.qiniu.com/kodo/manual/1671/region-endpoint" target="_blank" rel="noopener">存储区域 - 七牛开发者中心</a> 选择自己的地址，我是华东，填入 up.qiniup.com</li><li>URL（右侧靠下）:自己的外链默认域名 + $json:key$ -&gt; xxxxx.bkt.clouddn.com/$json:key$</li><li><strong>上图中我的默认域名修改成了自己的默认域名qiniu.rearib.top</strong></li></ul><h3 id="3-重点：生成-token"><a href="#3-重点：生成-token" class="headerlink" title="3. 重点：生成 token"></a><font color="red">3. 重点：生成 token</font></h3><p>下载生成<a href="http://moi.oss-cn-hangzhou.aliyuncs.com/qiniutoken-windows.7z" target="_blank" rel="noopener">工具</a><br>下载生成工具后执行：</p><blockquote><p>qiniutoken.exe -ak=[AccessKey] -sk=[SecretKey] -bk=[bucket]</p></blockquote><p>AccessKey和SecretKey登录七牛云-个人面板-秘钥管理-AK|SK</p><p>bucket是存储空间名字</p><p><strong>参数</strong></p><p>&emsp;&emsp;在「参数」下有两个输入空框</p><table><thead><tr><th>左框</th><th>右框</th></tr></thead><tbody><tr><td>token</td><td>上部生成的 token</td></tr><tr><td>key</td><td>%yy%d%h%mi%s.png</td></tr><tr><td>file</td><td>$input$</td></tr></tbody></table><ul><li>key 为上传时用的文件名，%yy%d%h%mi%s.png 是指年月日小时分钟秒，如 20180213165812.png</li></ul><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><p>&emsp;&emsp;都配置完后，点击左侧「图片上传」-「测试」，若测试结果返回一个正常的连接地址那就是配置成功了。<br><img src="http://qiniu.rearib.top/20181829/1644-W.png" alt=""><br>&emsp;&emsp;设置上传地址：sharex -&gt; 目的地 -&gt; 图片上传 -&gt; 自定义图像上传</p><p>&emsp;&emsp;截图后的动作 -&gt; 上传图片</p><p>按下快捷键截图后会自动上传并把七牛云返回的外链放到剪切板，成功后会有提示音并显示状态.<br><img src="http://qiniu.rearib.top/20181829/1648-M.png" alt=""><br>打开浏览器粘贴<br><img src="http://qiniu.rearib.top/20181829/1650-k.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>1、<a href="http://du.zoomquiet.io/2018-02/sharex-qiniu/" target="_blank" rel="noopener"><br>用 ShareX qiniu 一键截图上传</a></p><p>2、<a href="https://ystyle.top/2017/07/05/share-the-use-of-qiniu-file-upload/" target="_blank" rel="noopener">ShareX使用七牛文件上传</a></p><p>3、<a href="http://www.majianwei.com/archives/6660" target="_blank" rel="noopener">ShaseX</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;所谓图床，就是专门用来存放图片，同时允许你把图片对外连接的网上空间，通过访问链接就能直接查看或者分享图片，特别是个人博客的图片存储需要一个方便高效的私有图床，今天介绍一个通过ShareX+七牛云实现私有图床的方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>python-协程</title>
    <link href="http://yoursite.com/2018/10/29/python-%E5%8D%8F%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/10/29/python-协程/</id>
    <published>2018-10-29T01:33:42.000Z</published>
    <updated>2018-10-29T06:55:22.731Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;协程，又称微线程。英文名Coroutine。一句话说明什么是协程：协程是一种用户态的轻量级线程。<br>&emsp;&emsp;协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：<br>&emsp;&emsp;协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。<br><a id="more"></a></p><h2 id="协程的好处："><a href="#协程的好处：" class="headerlink" title="协程的好处："></a>协程的好处：</h2><ul><li>无需线程上下文切换的开销</li><li>无需原子操作锁定及同步的开销(协程是单线程,串行)</li><li>“原子操作(atomic operation)是不需要synchronized”，所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序是不可以被打乱，或者切割掉只执行部分。视作整体是原子性的核心。</li><li>方便切换控制流，简化编程模型</li><li>高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</li></ul><h2 id="协程的缺点："><a href="#协程的缺点：" class="headerlink" title="协程的缺点："></a>协程的缺点：</h2><ul><li>无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。</li><li><p>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序。</p><h2 id="yield实现协程"><a href="#yield实现协程" class="headerlink" title="yield实现协程"></a>yield实现协程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def consumer(name):</span><br><span class="line">    print(&quot;---&gt;starting eating baozi...&quot;)</span><br><span class="line">    while True:</span><br><span class="line">        new_baozi = yield   # yield设置生成器</span><br><span class="line">        print(&quot;[&#123;0&#125;] is eating baozi &#123;1&#125;&quot;.format(name, new_baozi))</span><br><span class="line"> </span><br><span class="line">def producer():</span><br><span class="line">    r = con.__next__()  # 调用生成器开始执行</span><br><span class="line">    r = con2.__next__()</span><br><span class="line">    n = 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        print(&quot;producer is making baozi &#123;0&#125;&quot;.format(n))</span><br><span class="line">        con.send(n)  # 唤醒生成器，并且向生成器传值</span><br><span class="line">        con2.send(n)</span><br><span class="line">        n += 1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    con = consumer(&quot;c1&quot;)    # 创建一个生成器c1,但是不会开始执行</span><br><span class="line">    con2 = consumer(&quot;c2&quot;)   # 创建一个生产器C2,但是不会开始执行</span><br><span class="line">    p = producer()</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/python-协程/20181029094850452.png" alt=""></p></li><li><p><strong>send有两个作用？</strong><br>1.唤醒生产器<br>2.给yield传一个值，就是yield接收到的这个值。这个说明yield在被唤醒的时候可以接收数据。</p></li><li><strong>怎么实现我们的单线程实现并发的效果呢？</strong><br>&emsp;&emsp;<font color="red">遇到IO操作就切换</font>，IO比较耗时，协程之所以能处理大并发，就是IO操作会挤掉大量的时间。<font color="red">没有IO操作的话，整个程序只有cpu在运算了</font>，因为cpu很快，所以你感觉是在并发执行的。</li><li><strong>IO操作完成了，程序什么时候切回去</strong>？<br>&emsp;&emsp;IO操作一旦完成，我们就自动切回去。</li><li><strong>IO是什么?</strong><br>&emsp;&emsp;Python中的io模块是用来处理各种类型的I/O操作流。主要有三种类型的I/O类型：文本I/O(Text I/O)，二进制I/O(Binary I/O)和原始I/O(Raw I/O)。它们都是通用类别，每一种都有不同的后备存储。属于这些类别中的任何一个的具体对象称为文件对象，其他常用的术语为流或者类文件对象。<br>&emsp;&emsp;除了它的类别，每一种具体的流对象也具有各种功能：它仅仅允许读，或者仅仅允许写，或者既能读又能写。它也允许任意随机访问（向前或者向后寻找任何位置），或者仅仅顺序访问（例如在套接字或管道中）。<br>&emsp;&emsp;所有的流对于提供给它们的数据的数据类型都很严格。例如，如果用一个二进制流的write（）方法写一个字符类型的数据，那么将会触发一个TypeError错误。用文本流的write()方法来写字节对象数据也是一样的，会触发该错误。<h2 id="手动实现切换IO"><a href="#手动实现切换IO" class="headerlink" title="手动实现切换IO"></a>手动实现切换IO</h2>&emsp;&emsp;Greenlet是python的一个C扩展，来源于Stackless python，旨在提供可自行调度的‘微线程’， 即协程。它可以使你在任意函数之间随意切换，而不需把这个函数先声明为generator<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from greenlet import greenlet</span><br><span class="line"> </span><br><span class="line">def test1():</span><br><span class="line">    print(12)</span><br><span class="line">    gr2.switch()  # 切换到test2</span><br><span class="line">    print(34)</span><br><span class="line">    gr2.switch()   # 切换到test2</span><br><span class="line"> </span><br><span class="line">def test2():</span><br><span class="line">    print(56)</span><br><span class="line">    gr1.switch()   # 切换到test1</span><br><span class="line">    print(78)</span><br><span class="line"> </span><br><span class="line">gr1 = greenlet(test1)  # 启动一个协程</span><br><span class="line">gr2 = greenlet(test2)</span><br><span class="line">gr1.switch()   # 切换到test1，这个switch不写的话，会无法输出打印</span><br></pre></td></tr></table></figure><img src="http://qiniu.rearib.top/python-协程/20181029101816499.png" alt=""><br><strong>小结：</strong></li><li>cpu只认识线程，而不认识协程，协程是用户自己控制的，cpu根本都不知道它们的存在。</li><li>线程的上下文切换保存在cpu的寄存器中，但是协程拥有自己的寄存上下文和栈。</li><li>协程是串行的，无需锁。</li><li>虽然greenlet确实用着比generator（生成器）还简单了，但好像还没有解决一个问题，就是遇到IO操作，自动切换，对不对？<h2 id="协程遇IO操作自动切换"><a href="#协程遇IO操作自动切换" class="headerlink" title="协程遇IO操作自动切换"></a>协程遇IO操作自动切换</h2>&emsp;&emsp;接下来就说说如何遇到IO就自动切换切换，Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import gevent</span><br><span class="line"> </span><br><span class="line">def foo():</span><br><span class="line">    print(&quot;Running in foo&quot;)</span><br><span class="line">    gevent.sleep(3)  # 模仿io操作，一遇到io操作就切换</span><br><span class="line">    print(&quot;Explicit context switch to foo again&quot;)</span><br><span class="line"> </span><br><span class="line">def bar():</span><br><span class="line">    print(&quot;Explicit context to bar&quot;)</span><br><span class="line">    gevent.sleep(1)</span><br><span class="line">    print(&quot;Implicit context switch back to bar&quot;)</span><br><span class="line"> </span><br><span class="line">def fun3():</span><br><span class="line">    print(&quot;running fun3&quot;)</span><br><span class="line">    gevent.sleep(0)   # 虽然是0秒，但是会触发一次切换</span><br><span class="line">    print(&quot;running fun3 again&quot;)</span><br><span class="line"> </span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(foo),  # 生成协程</span><br><span class="line">    gevent.spawn(bar),</span><br><span class="line">    gevent.spawn(fun3)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><img src="http://qiniu.rearib.top/python-协程/20181029103346052.png" alt=""><br>&emsp;&emsp;当foo遇到sleep(3)的时候，切自动切换到bar函数，执行遇到sleep(1)的时候自动切换到fun3函数，遇到sleep(0)又自动切换到foo。这个时候sleep(3)还没有执行完毕，又切换到bar的sleep(1)这边，发现又没有执行完毕，就有执行fun3这边，发现sleep(0)执行完毕，则继续执行，然后又切换到foo,发现sleep(3)又没有执行完毕，就切换到bar的sleep(1)这边，发现执行完了，有切回到foo这边，执行完毕。<br>&emsp;&emsp;<strong>比如说你现在有50处IO，然后总共加起来串行的的话，要花100秒，但是50处IO最长的那个IO只花了5秒钟，那代表中你的这个程序就是协程最多5秒就执行完毕了。</strong></li></ul><p><strong>符合下面四个条件才能称之为协程：</strong></p><ul><li>必须在只有一个单线程里实现并发</li><li>修改共享数据不需加锁</li><li>用户程序里自己保存多个控制流的上下文栈</li><li>一个协程遇到IO操作自动切换到其它协程</li></ul><h2 id="协程（gevent）并发爬网页"><a href="#协程（gevent）并发爬网页" class="headerlink" title="协程（gevent）并发爬网页"></a>协程（gevent）并发爬网页</h2><p>&emsp;&emsp;上面例子gevent遇到io自动切换，现在就来实际演示协程爬虫的例子<br><strong>正常（串行）爬网页</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line">import time</span><br><span class="line"> </span><br><span class="line">def run(url):</span><br><span class="line">    print(&quot;GET:&#123;0&#125;&quot;.format(url))</span><br><span class="line">    resp = request.urlopen(url)    # request.urlopen()函数 用来打开网页</span><br><span class="line">    data = resp.read()    # 读取爬到的数据</span><br><span class="line">    with open(&quot;url.html&quot;, &quot;wb&quot;) as f:</span><br><span class="line">        f.write(data)</span><br><span class="line">    print(&apos;&#123;0&#125; bytes received from &#123;1&#125;&apos;.format(len(data), url))</span><br><span class="line"> </span><br><span class="line">urls = [</span><br><span class="line">    &apos;http://www.163.com/&apos;,</span><br><span class="line">    &apos;https://www.yahoo.com/&apos;,</span><br><span class="line">    &apos;https://github.com/&apos;</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">time_start = time.time()    # 开始时间</span><br><span class="line">for url in urls:</span><br><span class="line">    run(url)</span><br><span class="line">print(&quot;同步cost&quot;, time.time() - time_start)  # 程序执行消耗的时间</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-协程/20181029020845792.png" alt=""></p><p><strong>协程(gevent)爬虫(gevent并发执行)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line">import time,gevent</span><br><span class="line"> </span><br><span class="line">def run(url):</span><br><span class="line">    print(&quot;GET:&#123;0&#125;&quot;.format(url))</span><br><span class="line">    resp = request.urlopen(url)    # request.urlopen()函数 用来打开网页</span><br><span class="line">    data = resp.read()    # 读取爬到的数据</span><br><span class="line">    with open(&quot;url.html&quot;, &quot;wb&quot;) as f:</span><br><span class="line">        f.write(data)</span><br><span class="line">    print(&apos;&#123;0&#125; bytes received from &#123;1&#125;&apos;.format(len(data), url))</span><br><span class="line"> </span><br><span class="line">urls = [</span><br><span class="line">    &apos;http://www.163.com/&apos;,</span><br><span class="line">    &apos;https://www.yahoo.com/&apos;,</span><br><span class="line">    &apos;https://github.com/&apos;</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">time_start = time.time()    # 开始时间</span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(run,&apos;http://www.163.com/&apos;),  # 生成协程</span><br><span class="line">    gevent.spawn(run,&apos;https://www.yahoo.com/&apos;),</span><br><span class="line">    gevent.spawn(run,&apos;https://github.com/&apos;)</span><br><span class="line">])</span><br><span class="line">print(&quot;异步cost&quot;, time.time() - time_start)  # 程序执行消耗的时间</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-协程/20181029023531205.png" alt=""><br><strong>对比1、2爬网页的例子，发现执行耗费时间上并没有得到明显提升，并没有并发爬网页的神奇快感，其实主要是因为gevent现在检测不到urllib的IO操作。它都不知道urllib进行了IO操作，感受不到阻塞，它都不会进行切换，所以它就串行了。</strong></p><p><strong>打个补丁，告诉gevent,urllib正在进行IO操作</strong><br>通过导入monkey模块，来打这个补丁，原代码不变，就添加一行monkey.patch_all()即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line">import gevent,time</span><br><span class="line">from gevent import monkey  # 导入monkey模块</span><br><span class="line"> </span><br><span class="line">monkey.patch_all()  # 把当前程序的所有的IO操作给作上标记</span><br><span class="line"> </span><br><span class="line">def run(url):</span><br><span class="line">    print(&quot;GET:&#123;0&#125;&quot;.format(url))</span><br><span class="line">    resp = request.urlopen(url)    # request.urlopen()函数 用来打开网页</span><br><span class="line">    data = resp.read()    # 读取爬到的数据</span><br><span class="line">    with open(&quot;url.html&quot;, &quot;wb&quot;) as f:</span><br><span class="line">        f.write(data)</span><br><span class="line">    print(&apos;&#123;0&#125; bytes received from &#123;1&#125;&apos;.format(len(data), url))</span><br><span class="line"> </span><br><span class="line">urls = [</span><br><span class="line">    &apos;http://www.163.com/&apos;,</span><br><span class="line">    &apos;https://www.yahoo.com/&apos;,</span><br><span class="line">    &apos;https://github.com/&apos;</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">time_start = time.time()    # 开始时间</span><br><span class="line">gevent.joinall([                     # 用gevent启动协程</span><br><span class="line">    gevent.spawn(run, &apos;http://www.163.com/&apos;),  # 第二个值是传入参数，之前我们没有讲，因为前面没有传参</span><br><span class="line">    gevent.spawn(run, &apos;https://www.yahoo.com/&apos;),</span><br><span class="line">    gevent.spawn(run, &apos;https://github.com/&apos;),</span><br><span class="line">])</span><br><span class="line">print(&quot;异步cost&quot;, time.time() - time_start)  # 程序执行消耗的时间</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-协程/20181029023811804.png" alt=""><br><strong><font color="red">时间会受到网络状态的影响</font></strong><br>&emsp;&emsp;通过打补丁来检测urllib，它就把urllib里面所有涉及到的有可能进行IO操作的地方直接花在前面加一个标记，这个标记就相当于gevent.sleep()，所以把urllib变成一个一有阻塞，它就切换了</p><h2 id="gevent实现单线程下的多socket并发"><a href="#gevent实现单线程下的多socket并发" class="headerlink" title="gevent实现单线程下的多socket并发"></a>gevent实现单线程下的多socket并发</h2><h3 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import sys,gevent,socket,time</span><br><span class="line">from gevent import socket,monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line">   </span><br><span class="line">def server(port):</span><br><span class="line">    s = socket.socket()</span><br><span class="line">    s.bind((&apos;0.0.0.0&apos;, port))</span><br><span class="line">    s.listen(500)</span><br><span class="line">    while True:</span><br><span class="line">        cli, addr = s.accept()</span><br><span class="line">        gevent.spawn(handle_request, cli)   #协程</span><br><span class="line">  </span><br><span class="line">def handle_request(conn):</span><br><span class="line">    try:</span><br><span class="line">        while True:</span><br><span class="line">            data = conn.recv(1024)</span><br><span class="line">            print(&quot;recv:&quot;, data)</span><br><span class="line">            conn.send(data)</span><br><span class="line">            if not data:</span><br><span class="line">                conn.shutdown(socket.SHUT_WR)</span><br><span class="line">    except Exception as  ex:</span><br><span class="line">        print(ex)</span><br><span class="line">    finally:</span><br><span class="line">        conn.close()</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    server(8888)</span><br></pre></td></tr></table></figure><h3 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">   </span><br><span class="line">HOST = &apos;localhost&apos;    # The remote host</span><br><span class="line">PORT = 8888           # The same port as used by the server</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((HOST, PORT))</span><br><span class="line">while True:</span><br><span class="line">    msg = bytes(input(&quot;&gt;&gt;:&quot;),encoding=&quot;utf8&quot;)</span><br><span class="line">    s.sendall(msg)</span><br><span class="line">    data = s.recv(1024)</span><br><span class="line">    print(&apos;Received&apos;, repr(data))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;协程，又称微线程。英文名Coroutine。一句话说明什么是协程：协程是一种用户态的轻量级线程。&lt;br&gt;&amp;emsp;&amp;emsp;协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：&lt;br&gt;&amp;emsp;&amp;emsp;协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python-多进程</title>
    <link href="http://yoursite.com/2018/10/26/python-%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/10/26/python-多进程/</id>
    <published>2018-10-26T15:15:10.000Z</published>
    <updated>2018-10-29T01:30:08.674Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;进程之间是相互独立的，进程没有GIL锁，而且不存在锁的概念，进程之间的数据式不能共享的，而线程是可以的。<br><a id="more"></a></p><h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><h2 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h2><p>&emsp;&emsp;用muliprocessing这个包中的Process来定义多进程，跟定义多线程类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process   # 导入进程模块</span><br><span class="line">import time</span><br><span class="line"> </span><br><span class="line">def run(name):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;hello&quot;, name)</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    p_obj_list = list()    # 存放进程对象</span><br><span class="line">    for i in range(10):    # 启动10个进程</span><br><span class="line">        p = Process(target=run, args=(&quot;QQ&#123;0&#125;&quot;.format(i),))  # 产生一个进程实例</span><br><span class="line">        p.start()   # 启动进程</span><br><span class="line">        p_obj_list.append(p)</span><br><span class="line">  </span><br><span class="line">    for p in p_obj_list:</span><br><span class="line">        p.join()   # 等待进程结果</span><br></pre></td></tr></table></figure><br><img src="/python-多进程/20181026112021180.png" alt=""></p><h2 id="进程中加入线程"><a href="#进程中加入线程" class="headerlink" title="进程中加入线程"></a>进程中加入线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import time,threading</span><br><span class="line"> </span><br><span class="line">def thread_run(name):   # 定义线程执行的方法</span><br><span class="line">    print(&quot;&#123;0&#125;:&#123;1&#125;&quot;.format(name, threading.get_ident()))  # thread.get_ident ()返回当前线程的标识符，标识符是一个非零整数</span><br><span class="line"> </span><br><span class="line">def run(name):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;hello&quot;, name)</span><br><span class="line">    t = threading.Thread(target=thread_run, args=(name,))   # 嵌入线程</span><br><span class="line">    t.start()   # 执行线程</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    p_obj_list = list()</span><br><span class="line">    for i in range(10):</span><br><span class="line">        p = Process(target=run, args=(&quot;QQ&#123;0&#125;&quot;.format(i),))</span><br><span class="line">        p.start()</span><br><span class="line">        p_obj_list.append(p)</span><br><span class="line"> </span><br><span class="line">    for p in p_obj_list:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure><p><img src="/python-多进程/20181026112235923.png" alt=""></p><h2 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h2><p>每个子进程都是由一个父进程启动的，每个程序也是有一个父进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line"> </span><br><span class="line">def info(title):</span><br><span class="line">    print(title)</span><br><span class="line">    print(&apos;module name:&apos;, __name__)</span><br><span class="line">    print(&apos;parent process:&apos;, os.getppid())  # 获得父进程ID</span><br><span class="line">    print(&apos;process id:&apos;, os.getpid())  # 获得子进程ID</span><br><span class="line">    print(&apos;\n&apos;)</span><br><span class="line"> </span><br><span class="line">def f(name):</span><br><span class="line">    info(&apos;function f&apos;)</span><br><span class="line">    print(&apos;hello&apos;, name)</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    info(&apos;main process line&apos;)</span><br><span class="line">    p = Process(target=f, args=(&apos;QQ&apos;,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><br><img src="/python-多进程/20181026112550916.png" alt=""></p><h1 id="进程间数据交互与共享"><a href="#进程间数据交互与共享" class="headerlink" title="进程间数据交互与共享"></a>进程间数据交互与共享</h1><p>&emsp;&emsp;知道不同进程之间内存是不共享的，要想实现两个进程间的通信需要用到multiprocessing库中的queue（队列）模块，这个multiprocessing库中的queue模块跟单纯的queue库是不一样的。进程导入前者（这里的queue是专门为进程之间的通信设计的）不出错，导入后者（这里的queue主要是线程间数据交互）出错。</p><h3 id="线程访问queue"><a href="#线程访问queue" class="headerlink" title="线程访问queue"></a>线程访问queue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import queue,threading</span><br><span class="line"></span><br><span class="line">def f(q):</span><br><span class="line">    q.put([66, None, &apos;hello word&apos;])</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    q = queue.Queue()   # 把这个q传给了子线程</span><br><span class="line">    p = threading.Thread(target=f, args=(q,))   # 子线程访问父线程的q</span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/python-多进程/20181026112944166.png" alt=""></p><h3 id="进程访问queue"><a href="#进程访问queue" class="headerlink" title="进程访问queue"></a>进程访问queue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import queue</span><br><span class="line"></span><br><span class="line">def f(q):</span><br><span class="line">    q.put([66, None, &apos;hello word&apos;])</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    q = queue.Queue()   # 把这个q传给了子线程</span><br><span class="line">    p = Process(target=f, args=(q,))   # 子线程访问父线程的q</span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/python-多进程/20181026113140101.png" alt=""></p><h3 id="进程访问multiprocessing库中的Queue模块"><a href="#进程访问multiprocessing库中的Queue模块" class="headerlink" title="进程访问multiprocessing库中的Queue模块"></a>进程访问multiprocessing库中的Queue模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process,Queue</span><br><span class="line"> </span><br><span class="line">def f(q):</span><br><span class="line">    q.put([66, None, &apos;hello word&apos;])</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    q = Queue()   # 把这个q传给了子线程</span><br><span class="line">    p = Process(target=f, args=(q,))   # 子线程访问父线程的q</span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/python-多进程/20181026113249257.png" alt=""><br>&emsp;&emsp;父进程相当于克隆一个Q，把自己的Q克隆了一份交给子进程，子进程这个时候往Q里面放了一份数据，然后父进程又能实际的获取到。但是你克隆了一份是不是就和父进程没有关系了，为什么还能联系在一起呢？但是实际上：等于这两个Q里面的数据又把它序列化了，序列化到一个中间的地方，类似于翻译，然后反序列化给这个父进程这边来了，其实这两个Q就是通过pickle来序列化的，不是一个真正的Q。<br><strong>小结：两个线程之间可以修改一个数据，不加锁，可能就会出错。现在进程中的Queue，是实现了数据的传递，不是在修改同一份数据，只是实现一个进程的数据传给了另外一个进程。</strong></p><h2 id="Pipe-实现进程间的数据交互，manger实现数据共享"><a href="#Pipe-实现进程间的数据交互，manger实现数据共享" class="headerlink" title="Pipe()实现进程间的数据交互，manger实现数据共享"></a>Pipe()实现进程间的数据交互，manger实现数据共享</h2><p>&emsp;&emsp;上面的例子是通过进程中的Queue，来进行数据共享的，其实还有一种方式实现数据共享，那就是管道，pipe，以及数据共享manger。</p><h3 id="Pipe-函数"><a href="#Pipe-函数" class="headerlink" title="Pipe()函数"></a>Pipe()函数</h3><p>&emsp;&emsp;管道函数会返回由管道双方连接的一组连接对象，该管道默认是双向的(双向的)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, Pipe</span><br><span class="line"> </span><br><span class="line">def f(conn):</span><br><span class="line">    conn.send([66, None, &apos;hello,word&apos;])  # 发送消息给父进程</span><br><span class="line">    conn.send([66, None, &apos;hello,word2&apos;])  # 发送消息给父进程</span><br><span class="line">    conn.close()</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    parent_conn, child_conn = Pipe()  # 管道生成返回两个实例，是双向的，这边把第1个作为父连接，第2个作为子连接。也可以，两者角色调换一下</span><br><span class="line">    p = Process(target=f, args=(child_conn,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(parent_conn.recv())   # 接收子进程的消息</span><br><span class="line">    print(parent_conn.recv())   # 接收子进程的消息</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-多进程/20181027010733552.png" alt=""><br><strong>如果父进程在接收,但是子进程没有发,那么父进程就会一直等待下去</strong></p><h3 id="manger"><a href="#manger" class="headerlink" title="manger()"></a>manger()</h3><p>&emsp;&emsp;manger可以完成数据间的共享。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, Manager</span><br><span class="line">import os</span><br><span class="line"> </span><br><span class="line">def f(d, l):</span><br><span class="line">    d[os.getpid()] = os.getpid()</span><br><span class="line">    l.append(os.getpid())</span><br><span class="line">    print(l)</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    with Manager() as manager:</span><br><span class="line">        d = manager.dict()   # 声明一个字典，这个字典是用manger声明的，不是用dict()声明的</span><br><span class="line">        # manger.dict()是用专门的语法生产一个可在多进程之间进行传递和共享的一个字典</span><br><span class="line">        l = manager.list(range(5))  # 同样声明一个列表</span><br><span class="line">        p_list = []</span><br><span class="line">        for i in range(10):</span><br><span class="line">            p = Process(target=f, args=(d, l))</span><br><span class="line">            p.start()</span><br><span class="line">            p_list.append(p)</span><br><span class="line">        for res in p_list:</span><br><span class="line">            res.join()</span><br><span class="line">        print(d)</span><br><span class="line">        print(l)</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-多进程/20181027012451920.png" alt=""><br><strong>线程修改同一份数据的时候需要加锁，进程修改数据呢：不用加锁，因为这个manger已经帮你加锁了，它就默认不允许两个进程同时修改一份数据。两个进程没有办法同时修改一份数据，进程之间是独立的，它自己也要加锁，因为它把自己的东西同时copy好几份，跟刚刚的那个Queue一样，copy10个字典最终合成一个字典</strong></p><h1 id="进程锁和进程池"><a href="#进程锁和进程池" class="headerlink" title="进程锁和进程池"></a>进程锁和进程池</h1><h2 id="进程锁"><a href="#进程锁" class="headerlink" title="进程锁"></a>进程锁</h2><p>&emsp;&emsp;通过multiprocessing中的Lock模块来实现进程锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process,Lock   # 导入进程锁</span><br><span class="line"> </span><br><span class="line">def f(l, i):</span><br><span class="line">    l.acquire()    # 加锁</span><br><span class="line">    print(&quot;hello word&quot;, i)</span><br><span class="line">    l.release()   # 释放锁</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    lock = Lock()     # 定义锁</span><br><span class="line">    for num in range(10):</span><br><span class="line">        Process(target=f, args=(lock, num,)).start()  # 把锁传入进程中</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-多进程/20181027014001015.png" alt=""><br><strong>进程中不是相互独立的吗？为什么还要加锁：虽然每个进程都是独立运行的，但是问题来了，它们共享一块屏幕。这个锁存在的意义就是屏幕共享。如果进程1想着打印数据，而进程2想也想打印数据的情况，就有可能乱套了，然后通过这个锁来控制，去打印的时候，这个屏幕只有我独占，导致屏幕不会乱。</strong></p><h2 id="进程池apply和apply-saync"><a href="#进程池apply和apply-saync" class="headerlink" title="进程池apply和apply_saync"></a>进程池apply和apply_saync</h2><h3 id="appley"><a href="#appley" class="headerlink" title="appley"></a>appley</h3><p>&emsp;&emsp;同步执行，也就是<strong>串行执行</strong>的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool  # 导入进程池模块pool</span><br><span class="line">import time,os</span><br><span class="line"> </span><br><span class="line">def foo(i):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;in process&quot;, os.getpid())  # 打印进程号</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    pool = Pool(processes=5)   # 设置进程池个数为5，也可以写成pool = Pool(5)，允许进程池同时放入5个进程，并且这5个进程交给cpu去运行</span><br><span class="line">    for i in range(10):</span><br><span class="line">        pool.apply(func=foo, args=(i,))   # 同步执行挂起进程</span><br><span class="line">    print(&apos;end&apos;)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  # 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</span><br></pre></td></tr></table></figure><br><strong>一个一个打印</strong><br><img src="http://qiniu.rearib.top/python-多进程/20181027015536404.png" alt=""></p><h3 id="apply-saync"><a href="#apply-saync" class="headerlink" title="apply_saync"></a>apply_saync</h3><p>&emsp;&emsp;异步执行，也就是<strong>并行执行</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool  # 导入进程池模块pool</span><br><span class="line">import time,os</span><br><span class="line"> </span><br><span class="line">def foo(i):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;in process&quot;, os.getpid())  # 打印进程号</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    pool = Pool(processes=5)   # 设置进程池个数为5，也可以写成pool = Pool(5)，允许进程池同时放入5个进程，并且这5个进程交给cpu去运行</span><br><span class="line">    for i in range(10):</span><br><span class="line">        pool.apply_async(func=foo, args=(i,))   # 采用异步方式执行foo函数</span><br><span class="line">    print(&apos;end&apos;)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  # 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/python-多进程/20181027015657931.png" alt=""></p><h3 id="异步下回调函数"><a href="#异步下回调函数" class="headerlink" title="异步下回调函数"></a>异步下回调函数</h3><p>&emsp;&emsp;程序执行完毕之后，再回调过来执行这个Bar函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process,Pool</span><br><span class="line">import time,os</span><br><span class="line"> </span><br><span class="line">def foo(i):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;in process&quot;, os.getpid())  # 打印子进程的进程号</span><br><span class="line">    return i</span><br><span class="line"> </span><br><span class="line">def bar(arg):</span><br><span class="line">    print(&apos;--&gt;exec done:&apos;, arg, os.getpid())   # 打印进程号</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    pool = Pool(processes=2)</span><br><span class="line">    print(&quot;主进程&quot;, os.getpid())   # 主进程的进程号</span><br><span class="line">    for i in range(3):</span><br><span class="line">        pool.apply_async(func=foo, args=(i,), callback=bar)   # 执行回调函数callback=Bar,在主进程中执行</span><br><span class="line">    print(&apos;end&apos;)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  # 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</span><br></pre></td></tr></table></figure><br><strong>五个五个打印</strong><br><img src="http://qiniu.rearib.top/python-多进程/20181027015941615.png" alt=""><br><strong>回调函数在主进程执行,传入的参数来自子进程</strong></p><ul><li>回调函数说明fun=Foo干不完就不执行bar函数，等Foo执行完就去执行Bar</li><li>这个回调函数是主进程去调用的，而不是每个子进程去调用的。</li><li>回调函数的用处：<blockquote><p>比如说你从各个机器上备份完毕，在回调函数中自动写一个脚本，说备份完毕</p></blockquote></li><li>回调函数是主进程调用的原因？<blockquote><p>如果是子进程去调用这个回调函数，有多少个子进程就有多少个连接，如果是主进程的话，只需要一次长连接就可以了，这个效率就高了</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;进程之间是相互独立的，进程没有GIL锁，而且不存在锁的概念，进程之间的数据式不能共享的，而线程是可以的。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python-线程与进程</title>
    <link href="http://yoursite.com/2018/10/26/python-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/10/26/python-线程与进程/</id>
    <published>2018-10-26T01:47:08.000Z</published>
    <updated>2018-10-26T09:47:05.094Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;计算机所有的指令的操作都是有CPU来负责的，cpu是来负责运算的。<strong>OS(操作系统) 调度cpu的最小单位就是线程。</strong><br>&emsp;&emsp;进程：是以一个整体的形式暴露给操作系统管理，里面包含对各种资源的调用，内存的管理，网络接口的调用等等，是各种资源管理的集合<br>&emsp;&emsp;线程：是操作系统的最小的调度单位，是一串指令的集合。<br><a id="more"></a><br><img src="http://qiniu.rearib.top/1/20181026100045261.png" alt=""></p><h2 id="进程-Process）"><a href="#进程-Process）" class="headerlink" title="进程(Process）"></a>进程(Process）</h2><p>&emsp;&emsp;程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：<strong>程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。</strong><br>&emsp;&emsp;在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。这是这样的设计，大大提高了CPU的利用率。进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。</p><h2 id="线程-Thead"><a href="#线程-Thead" class="headerlink" title="线程(Thead)"></a>线程(Thead)</h2><p>&emsp;&emsp;线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，<strong>一个进程中可以并发多个线程，每条线程并行执行不同的任务。</strong></p><h2 id="有了进程为什么还要线程"><a href="#有了进程为什么还要线程" class="headerlink" title="有了进程为什么还要线程?"></a>有了进程为什么还要线程?</h2><p>&emsp;&emsp;进程有很多优点，它提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率。很多人就不理解了，既然进程这么优秀，为什么还要线程呢？其实，仔细观察就会发现进程还是有很多缺陷的，主要体现在两点上：</p><ul><li>进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。</li><li>进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。</li></ul><p>&emsp;&emsp;例如，我们在使用qq聊天， qq做为一个独立进程如果同一时间只能干一件事，那他如何实现在同一时刻：即能监听键盘输入、又能监听其它人给你发的消息、同时还能把别人发的消息显示在屏幕上呢？你会说，操作系统不是有分时么？但是分时是指在不同进程间的分时， 即操作系统处理一会你的qq任务，又切换到word文档任务上了，每个cpu时间片分给你的qq程序时，事实上，你的qq还是同一时间只能干一件事情。<br>&emsp;&emsp;再直白一点， 一个操作系统就像是一个工厂，工厂里面有很多个生产车间，不同的车间生产不同的产品，每个车间就相当于一个进程，且你的工厂又穷，供电不足，同一时间只能给一个车间供电，为了能让所有车间都能同时生产，你的工厂的电工只能给不同的车间分时供电，但是轮到你的qq车间时，发现只有一个干活的工人，结果生产效率极低，为了解决这个问题，就需要多加几个工人，让几个人工人并行工作，这每个工人，就是线程！</p><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li>线程是共享内存空间的；进程的内存是独立的。</li><li>线程可以直接访问此进程中的数据部分；进程有他们独立拷贝自己父进程的数据部分，每个进程是独立的</li><li>同一进程的线程之间直接交流(直接交流涉及到数据共享，信息传递)；两个进程想通信，必须通过一个中间代理来实现。</li><li>创建一个新的线程很容易；创建新的进程需要对其父进程进行一次克隆。</li><li>一个线程可以控制和操作同一进程里的其他线程；但是进程只能操作子进程。</li><li>对主线程的修改，可能会影响到进程中其他线程的修改；对于一个父进程的修改不会影响其他子进程(只要不删除父进程即可)<h2 id="概念小结"><a href="#概念小结" class="headerlink" title="概念小结"></a>概念小结</h2></li><li>线程是操作系统最小的调度单位，是一串指令的集合。</li><li>进程要操作CPU，必须先创建一个线程。</li><li>进程本身是不可以执行的，操作cpu是通过线程实现的，因为它是一堆执行，而进程是不具备执行概念的。就像一个屋子，屋子就是进程，但是屋子里面的每一个人就是线程，屋子就是内存空间。</li><li>单核CPU只能同时干一件事，但是为什么给我们的感觉是在干了很多件事？因为CPU太快了，可以有N多次切换。</li><li>进程是通过PID来区分的，并不是通过进程名来区分的。进程里面的第一个线程就是主线程，父线程和子线程是相互独立的，只是父线程创建了子线程，父线程down了，子线程不会受到影响的。</li><li>主线程修改会影响其他线程，因为它们是共享数据的。</li><li>线程启动比进程块，但是运行速度没有可比性</li></ul><h1 id="threading-Thread模块"><a href="#threading-Thread模块" class="headerlink" title="threading.Thread模块"></a>threading.Thread模块</h1><h2 id="函数式多线程"><a href="#函数式多线程" class="headerlink" title="函数式多线程"></a>函数式多线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">def run(n):</span><br><span class="line">    print(&quot;run&quot;, n)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(n,&apos;end time:&apos;,time.time())</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">第一个参数是线程函数变量，第二个参数args是一个元组变量参数，如果只传递一个值，就只需要i,</span><br><span class="line">如果需要传递多个参数，那么还可以继续传递下去其他的参数，其中的逗号不能少，少了逗号位置参数指引就会出错。</span><br><span class="line">&quot;&quot;&quot; </span><br><span class="line">t1 = threading.Thread(target=run, args=(&quot;t1&quot;,))  # 生成线程对象</span><br><span class="line">t2 = threading.Thread(target=run, args=(&quot;t2&quot;,))</span><br><span class="line"></span><br><span class="line">print(&apos;start:&apos;,time.time())</span><br><span class="line">t1.start()  # start()函数启动一个线程</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/线程与进程/20181026101728106.png" alt=""></p><h2 id="继承式多线程"><a href="#继承式多线程" class="headerlink" title="继承式多线程"></a>继承式多线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">class MyThread(threading.Thread):   # 继承threading.Thread</span><br><span class="line">    &quot;&quot;&quot;继承式多线程&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        super(MyThread,self).__init__()  # 也可以写成这样threading.Thread.__init__(self)</span><br><span class="line">        self.n = n</span><br><span class="line"> </span><br><span class="line">    def run(self):     # 重写run方法</span><br><span class="line">        &quot;&quot;&quot;这个方法不能叫别的名字，只能叫run方法&quot;&quot;&quot;</span><br><span class="line">        print(&quot;run&quot;, self.n)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(self.n,&apos;end time:&apos;,time.time())</span><br><span class="line">        </span><br><span class="line">t1 = MyThread(&quot;t1&quot;)   # 实例化</span><br><span class="line">t2 = MyThread(&quot;t2&quot;)</span><br><span class="line"></span><br><span class="line">print(&apos;start:&apos;,time.time()) </span><br><span class="line">t1.start()   # 启动一个多线程</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/线程与进程/20181026102059476.png" alt=""></p><p>&amp;emsp；&amp;emsp；在上面两个示例代码中，都包含一个主线程和两个子线程，主线程在启动子线程后，子线程就是独立的，所以主线程不会等待子线程的sleep就直接运行下去。如果实现等待线程执行结果可以使用join。</p><h2 id="join函数"><a href="#join函数" class="headerlink" title="join函数"></a>join函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">class MyThread(threading.Thread):   # 继承threading.Thread</span><br><span class="line">    &quot;&quot;&quot;继承式多线程&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        super(MyThread,self).__init__()  # 也可以写成这样threading.Thread.__init__(self)</span><br><span class="line">        self.n = n</span><br><span class="line"> </span><br><span class="line">    def run(self):     # 重写run方法</span><br><span class="line">        &quot;&quot;&quot;这个方法不能叫别的名字，只能叫run方法&quot;&quot;&quot;</span><br><span class="line">        print(&quot;run&quot;, self.n)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(self.n,&apos;end time:&apos;,time.time())</span><br><span class="line">        </span><br><span class="line">t1 = MyThread(&quot;t1&quot;)   # 实例化</span><br><span class="line">t2 = MyThread(&quot;t2&quot;)</span><br><span class="line"></span><br><span class="line">print(&apos;start:&apos;,time.time()) </span><br><span class="line">t1.start()   # 启动一个多线程</span><br><span class="line">t1.join()</span><br><span class="line">t2.start()</span><br><span class="line">print(&apos;main end time:&apos;,time.time())</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/线程与进程/20181026103100213.png" alt=""></p><ul><li>加了join之后，主线程依赖子线程执行完毕才往下走。</li></ul><p><strong>如果想要的是线程依然是并行效果，就需要更换join()的位置</strong><br><img src="http://qiniu.rearib.top/线程与进程/20181026102935930.png" alt=""></p><h2 id="计算多线程执行时间"><a href="#计算多线程执行时间" class="headerlink" title="计算多线程执行时间"></a>计算多线程执行时间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">def run(n):  # 这边的run方法的名字是自行定义的，跟继承式多线程不一样，那个是强制的</span><br><span class="line">    print(&quot;task:&quot;, n)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;task done&quot;, n)</span><br><span class="line"> </span><br><span class="line">start_time = time.time()  # 开始时间</span><br><span class="line">t_obj = []  # 存放子线程实例</span><br><span class="line">for i in range(10):  # 一次性启动10个线程</span><br><span class="line">    t = threading.Thread(target=run, args=(&quot;t-&#123;0&#125;&quot;.format(i),))</span><br><span class="line">    t.start()</span><br><span class="line">    t_obj.append(t)   # 为了不阻塞后面线程的启动，不在这里join，先放到一个列表中</span><br><span class="line"> </span><br><span class="line">for t in t_obj:  # 循环线程实例列表，等待所有线程执行完毕</span><br><span class="line">    t.join() </span><br><span class="line"> </span><br><span class="line">print(&quot;--------all thread has finished&quot;)</span><br><span class="line">print(&quot;cost:&quot;, time.time() - start_time)  # 计算总耗时</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/线程与进程/20181026103423804.png" alt=""></p><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>&emsp;&emsp;只要主线程执行完毕，它不管子线程有没有执行完毕，就退出。现在就可以把所有的子线程变成守护线程。<strong>子线程变成守护线程之后，主程序就不会等子线程结束再退出了</strong>。说白了，设置一个主人，在设置几个仆人，这几个仆人都是为主人服务的。可以帮主人做很多事情，一个主人（主线程）可以有多个仆人（守护线程），服务的前提是，主线程必须存在，如果主线程不存在，则守护进程也没了。那守护进程是干嘛的呢？可以管理一些资源，打开一些文件，监听一些端口，监听一些资源，把一些垃圾资源回收，可以干很多事情，可以随便定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"></span><br><span class="line">def run(n):</span><br><span class="line">    print(&quot;task:&quot;, n)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;task done&quot;, n)</span><br><span class="line"> </span><br><span class="line">start_time = time.time()</span><br><span class="line">for i in range(5):</span><br><span class="line">    t = threading.Thread(target=run,args=(&quot;t-&#123;0&#125;&quot;.format(i),))</span><br><span class="line">    t.setDaemon(True)  # Daemon意思是守护进程，这边是把当前线程设置为守护线程</span><br><span class="line">    t.start()</span><br><span class="line"> </span><br><span class="line">print(&quot;--------all thread has finished&quot;)</span><br><span class="line">print(&quot;cost:&quot;, time.time() - start_time)</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/线程与进程/20181026103850709.png" alt=""><br><strong>守护进程一定要在start之前设置，start之后就不能设置了，之后设置会报错</strong></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>&emsp;&emsp;比如写一个socket_server，每一个链接过来，socket_server就会给这个链接分配一个新的线程。如果我手动的把socket_server停掉。那这种情况你必须手动停掉服务，那它就要down了，这种情况下还要等线程结束吗？就不用等线程结束了，它自己就直接结束了。这样，是不是就可以把每个socket线程设置一个守护线程，主线程一旦down掉，就全部退出。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>theading.current_thead()查看当前线程；</li><li>用theading.active_count()来统计当前活动的线程数</li><li>线程个数=子线程数+主线程数</li></ul><h1 id="GIL锁-全局解释器锁"><a href="#GIL锁-全局解释器锁" class="headerlink" title="GIL锁(全局解释器锁)"></a>GIL锁(全局解释器锁)</h1><p>&emsp;&emsp;计算机有4核，代表着同一时间，可以干4个任务。如果单核cpu的话，我启动10个线程，我看上去也是并发的，因为是执行了上下文的切换，让看上去是并发的。但是单核永远肯定时串行的，它肯定是串行的，cpu真正执行的时候，因为一会执行1，一会执行2.。。。。正常的线程就是这个样子的。但是，在python中，无论有多少核，永远都是假象。无论是4核，8核，还是16核…….不好意思，同一时间执行的线程只有一个(线程)，它就是这个样子的。这个是python的一个开发时候，设计的一个缺陷，所以说python中的线程是假线程。</p><h2 id="GIL存在的意义"><a href="#GIL存在的意义" class="headerlink" title="GIL存在的意义"></a><a href="https://www.cnblogs.com/gengcx/p/7500401.html" target="_blank" rel="noopener">GIL存在的意义</a></h2><p>&emsp;&emsp;在新处理器上运行的程序要想充分利用其性能，必须按照并发方式进行重写。大部分开发者听到“并发”通常会立刻想到多线程的程序。目前来说，多线程执行还是利用多核系统最常用的方式。尽管多线程编程大大好于“顺序”编程，不过即便是仔细的程序员也没法在代码中将并发性做到最好。编程语言在这方面应该做的更好，大部分应用广泛的现代编程语言都会支持多线程编程。<br>&emsp;&emsp;要想利用多核系统，Python必须支持多线程运行。作为解释型语言，Python的解释器必须做到既安全又高效。我们都知道多线程编程会遇到的问题。解释器要留意的是避免在不同的线程操作内部共享的数据。同时它还要保证在管理用户线程时保证总是有最大化的计算资源。<br>&emsp;&emsp;那么，不同线程同时访问时，数据的保护机制是怎样的呢？答案是解释器全局锁。从名字上看能告诉我们很多东西，很显然，这是一个加在解释器上的全局（从解释器的角度看）锁（从互斥或者类似角度看）。这种方式当然很安全，但是它有一层隐含的意思（Python初学者需要了解这个）：对于任何Python程序，不管有多少的处理器，任何时候都总是只有一个线程在执行。</p><h2 id="GIL锁关系图"><a href="#GIL锁关系图" class="headerlink" title="GIL锁关系图"></a>GIL锁关系图</h2><p>&emsp;&emsp;GIL(全局解释器锁)是加在python解释器里面的，效果如图：<br><img src="http://qiniu.rearib.top/线程与进程/20181026110513560.png" alt=""><br><strong>总结:</strong><br>&emsp;&emsp;需要明确的一点是<strong>GIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念</strong>。就好比C++是一套语言（语法）标准，但是可以用不同的编译器来编译成可执行代码。有名的编译器例如GCC，INTEL C++，Visual C++等。Python也一样，同样一段代码可以通过CPython，PyPy，Psyco等不同的Python执行环境来执行。像其中的JPython就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境。<strong>所以在很多人的概念里CPython就是Python，也就想当然的把GIL归结为Python语言的缺陷。所以这里要先明确一点：GIL并不是Python的特性，Python完全可以不依赖于GIL。</strong></p><ul><li>CPython：是用C语言实现Pyhon，是目前应用最广泛的解释器。</li></ul><h1 id="线程锁（互斥锁）"><a href="#线程锁（互斥锁）" class="headerlink" title="线程锁（互斥锁）"></a>线程锁（互斥锁）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">def run(n):</span><br><span class="line">    global num   # 把num变成全局变量</span><br><span class="line">    time.sleep(1)  # 注意了sleep的时候是不占有cpu的，这个时候cpu直接把这个线程挂起了，此时cpu去干别的事情去了</span><br><span class="line">    num += 1   # 所有的线程都做+1操作</span><br><span class="line"> </span><br><span class="line">num = 0   # 初始化num为0</span><br><span class="line">t_obj = list()</span><br><span class="line">for i in range(100):</span><br><span class="line">    t = threading.Thread(target=run, args=(&quot;t-&#123;0&#125;&quot;.format(i),))</span><br><span class="line">    t.start()</span><br><span class="line">    t_obj.append(t)</span><br><span class="line"> </span><br><span class="line">for t in t_obj:</span><br><span class="line">    t.join()</span><br><span class="line"> </span><br><span class="line">print(&quot;--------all thread has finished&quot;)</span><br><span class="line">print(&quot;num:&quot;, num)   # 输出最后的num值</span><br><span class="line"></span><br><span class="line">#执行结果</span><br><span class="line">--------all thead has finished</span><br><span class="line">(&apos;num:&apos;, 97)  #输出的结果</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其实这种情况只能在python2.x 中才会出现的，python3.x里面没有这种现象，下面我们就用一张图来解释一下这个原因。如图：<br><img src="http://qiniu.rearib.top/线程与进程/20181026114846189.png" alt=""><br>解释：</p><ul><li>到第5步的时候，可能这个时候python正好切换了一次GIL(据说python2.7中，每100条指令会切换一次GIL),执行的时间到了，被要求释放GIL,这个时候thead 1的count=0并没有得到执行，而是挂起状态，count=0这个上下文关系被存到寄存器中.</li><li>然后到第6步，这个时候thead 2开始执行，然后就变成了count = 1,返回给count，这个时候count=1.</li><li>然后再回到thead 1，这个时候由于上下文关系，thead 1拿到的寄存器中的count = 0，经过计算，得到count = 1，经过第13步的操作就覆盖了原来的count = 1的值，所以这个时候count依然是count = 1，所以这个数据并没有保护起来。</li></ul><h2 id="添加线程锁"><a href="#添加线程锁" class="headerlink" title="添加线程锁"></a>添加线程锁</h2><p>&emsp;&emsp;通过上面的图我们知道，结果依然是不准确的。所以我还要加一把锁，这个是用户级别的锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"></span><br><span class="line">def run(n):</span><br><span class="line">    lock.acquire()  # 添加线程锁</span><br><span class="line">    global num      # 把num变成全局变量</span><br><span class="line">    time.sleep(0.1) # 注意了sleep的时候是不占有cpu的，这个时候cpu直接把这个线程挂起了，此时cpu去干别的事情去了</span><br><span class="line">    num += 1        # 所有的线程都做+1操作</span><br><span class="line">    lock.release()  # 释放线程锁</span><br><span class="line"> </span><br><span class="line">num = 0   # 初始化num为0</span><br><span class="line">lock = threading.Lock()  # 生成线程锁实例</span><br><span class="line">t_obj = list()</span><br><span class="line">for i in range(10):</span><br><span class="line">    t = threading.Thread(target=run, args=(&quot;t-&#123;0&#125;&quot;.format(i),))</span><br><span class="line">    t.start()</span><br><span class="line">    t_obj.append(t)</span><br><span class="line"> </span><br><span class="line">for t in t_obj:</span><br><span class="line">    t.join()   # 为join是等子线程执行的结果，如果不加，主线程执行完，下面就获取不到子线程num的值了，共享数据num值就错误了</span><br><span class="line"></span><br><span class="line">print(&quot;--------all thread has finished&quot;)</span><br><span class="line">print(&quot;num:&quot;, num)   # 输出最后的num值</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/线程与进程/20181026115312595.png" alt=""><br><strong>小结：</strong></p><ul><li>用theading.Lock()创建一个lock的实例。</li><li>在线程启动之前通过lock.acquire()加加锁，在线程结束之后通过lock.release()释放锁。</li><li>这层锁是用户开的锁，就是我们用户程序的锁。跟我们这个GIL没有关系，但是它把这个数据相当于copy了两份，所以在这里加锁，以确保同一时间只有一个线程，真真正正的修改这个数据，所以这里的锁跟GIL没有关系，你理解就是自己的锁。</li><li>加锁，说明此时我来去修改这个数据，其他人都不能动。然后修改完了，要把这把锁释放。这样的话就把程序编程串行了。</li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>&emsp;&emsp;在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁，因为系统判断这部分资源都正在使用，所有这两个线程在无外力作用下将一直等待下去.（大锁内加小锁）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import threading,time </span><br><span class="line"></span><br><span class="line">mutexA=threading.Lock()</span><br><span class="line">mutexB=threading.Lock()</span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        self.func1()</span><br><span class="line">        self.func2()</span><br><span class="line"></span><br><span class="line">    def func1(self):</span><br><span class="line">        print(&apos;%s func1 start&apos;%self.name)</span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(&apos;%s func1 拿到A锁 &apos;%self.name)</span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(&apos;%s func1 拿到B锁 &apos;%self.name)</span><br><span class="line">        mutexB.release()</span><br><span class="line">        mutexA.release()</span><br><span class="line">        print(&apos;%s func1 end&apos;%self.name)</span><br><span class="line"></span><br><span class="line">    def func2(self):</span><br><span class="line">        print(&apos;%s func2 start&apos;%self.name)</span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(&apos;%s func2 拿到B锁 &apos;%self.name)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(&apos;%s func2 拿到A锁 &apos;%self.name)</span><br><span class="line">        mutexA.release()</span><br><span class="line">        mutexB.release()</span><br><span class="line">        print(&apos;%s func2 end&apos;%self.name)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    for i in range(5):</span><br><span class="line">        t=MyThread()</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/线程与进程/20181026044139986.png" alt=""><br>线程1拿到B锁，线程3拿到A锁，造成同时等待，而且线程2、4、5也会因为拿不到锁等待。</p><h2 id="递归锁（RLock）"><a href="#递归锁（RLock）" class="headerlink" title="递归锁（RLock）"></a>递归锁（RLock）</h2><p>&emsp;&emsp;这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import threading,time </span><br><span class="line"></span><br><span class="line">mutexA=mutexB=threading.RLock()</span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        self.func1()</span><br><span class="line">        self.func2()</span><br><span class="line"></span><br><span class="line">    def func1(self):</span><br><span class="line">        print(&apos;%s func1 start&apos;%self.name)</span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(&apos;%s func1 拿到A锁 &apos;%self.name)</span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(&apos;%s func1 拿到B锁 &apos;%self.name)</span><br><span class="line">        mutexB.release()</span><br><span class="line">        mutexA.release()</span><br><span class="line">        print(&apos;%s func1 end&apos;%self.name)</span><br><span class="line"></span><br><span class="line">    def func2(self):</span><br><span class="line">        print(&apos;%s func2 start&apos;%self.name)</span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(&apos;%s func2 拿到B锁 &apos;%self.name)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(&apos;%s func2 拿到A锁 &apos;%self.name)</span><br><span class="line">        mutexA.release()</span><br><span class="line">        mutexB.release()</span><br><span class="line">        print(&apos;%s func2 end&apos;%self.name)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    for i in range(5):</span><br><span class="line">        t=MyThread()</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.rearib.top/线程与进程/20181026045033501.png" alt=""><br><img src="http://qiniu.rearib.top/线程与进程/20181026045227839.png" alt=""><br>&emsp;&emsp;由于锁A，B是同一个递归锁，thread1拿到A,B锁，counter记录了acquire的次数2次，然后在func1执行完毕，就释放递归锁，在thread1释放完递归锁，执行完func1代码，接下来会有2种可能：1、thread1在次抢到递归锁，执行func2代码 2、其他的线程抢到递归锁，去执行func1的任务代码<br><strong>递归锁用于多重锁的情况，如果只是一层锁，就用不上递归锁</strong><br>递归锁原理其实很简单：就是每开一把门，在字典里面存一份数据，退出的时候去到door1或者door2里面找到这个钥匙退出，如图：<br><img src="http://qiniu.rearib.top/线程与进程/20181026050112225.png" alt=""></p><h2 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h2><p>&emsp;&emsp;之前讲的线程锁（互斥锁）同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去。</p><ul><li>信号量是一个变量，控制着对公共资源或者临界区的访问。信号量维护着一个计数器，指定可同时访问资源或者进入临界区的线程数。 </li><li>每次有一个线程获得信号量时，计数器-1。若计数器为0，其他线程就停止访问信号量，直到另一个线程释放信号量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">def run(n):</span><br><span class="line">    semaphore.acquire()   # 加信号量锁</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    print(&quot;run the thread: %s\n&quot; % n)</span><br><span class="line">    semaphore.release()   # 释放信号量锁</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    semaphore = threading.BoundedSemaphore(5)  # 最多允许5个线程同时运行(Bounded:绑定，Semaphore：信号量)</span><br><span class="line">    for i in range(20):</span><br><span class="line">        t = threading.Thread(target=run, args=(i,))</span><br><span class="line">        t.start()</span><br><span class="line">while threading.active_count() != 1:</span><br><span class="line">    pass</span><br><span class="line">else:</span><br><span class="line">    print(&apos;----all threads done---&apos;)</span><br></pre></td></tr></table></figure><p>上面程序的执行，会让人感觉是：分了4组，前5个同时完成，然后又5个同时进去。但是实际的效果是：这5个里面如果有3个完成，就会立刻再放3个进去。不会等5个都完成，每出来1个就放进去1个，出来几个放进去几个<br><strong>使用场景和总结</strong></p><ul><li>连接池，线程池，MySQL的有连接池，同一时间有多少个并发，就能连多少个连接。</li><li>我们为了保证我的socket_server，因为python不会默认现在你启动多少个线程，但是你启动的线程越多，就会把系统拉的越慢，就会把程序拉的越慢。这里就可以搞一个我同一时间放100线程个进来，就是用semaphore</li></ul><h2 id="event"><a href="#event" class="headerlink" title="event"></a>event</h2><p>&emsp;&emsp;事件处理的机制：全局定义了一个“Flag”，如果“Flag”值为 False，那么当程序执行 event.wait 方法时就会阻塞，如果“Flag”值为True，那么event.wait 方法时便不再阻塞。<br><strong>threading.Event 实现线程间通信,使用threading.Event可以使一个线程等待其他线程的通知</strong></p><blockquote><ul><li>event = threading.Event()   # 设置一个事件的全局变量</li><li>event.is_set()       # 判断是否已经设置标志位。</li><li>event.wait()         # 没有设置标志位的时候会阻塞，一遇到标志位就不会阻塞 #判断是否已经设置标志位。</li><li>event.set()          # 设置标志位 ，标志位设置了，代表着绿灯，直接通行。</li><li>event.clear()        # 清除标志位，标志位被清空，代表红灯，wait等待变绿灯。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"> </span><br><span class="line">event = threading.Event()  # 生成线程事件实例</span><br><span class="line"> </span><br><span class="line">def lighter():</span><br><span class="line">    count = 0</span><br><span class="line">    event.set()   # 先设置标志位,代表绿灯</span><br><span class="line">    while True:</span><br><span class="line">        if count &gt; 5 and count &lt; 10:   # 改成红灯</span><br><span class="line">            event.clear()    # 清除标志位，变成红灯</span><br><span class="line">            print(&quot;red light is on ....&quot;)</span><br><span class="line">        elif count &gt; 10:</span><br><span class="line">            event.set()   # 创建标志位，变成绿灯</span><br><span class="line">            count = 0</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;green light is on ....&quot;)</span><br><span class="line"> </span><br><span class="line">        time.sleep(1)</span><br><span class="line">        count += 1</span><br><span class="line"> </span><br><span class="line">def car(name):</span><br><span class="line">    while True:</span><br><span class="line">        if event.is_set():   # 有标志位，代表是绿灯</span><br><span class="line">            print(&quot;&#123;0&#125; running ....&quot;.format(name))</span><br><span class="line">            time.sleep(1)</span><br><span class="line">        else:   # 如果不是绿灯就代表红灯</span><br><span class="line">            print(&quot;&#123;0&#125; sees red light ,waiting ....&quot;.format(name))</span><br><span class="line">            event.wait()   # 阻塞</span><br><span class="line">            print(&quot;green light is on , start going ...&quot;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">light = threading.Thread(target=lighter,)  # 启动代表红绿灯的线程</span><br><span class="line">light.start()</span><br><span class="line">car1 = threading.Thread(target=car, args=(&quot;car1&quot;,))  # 启动代表车的线程</span><br><span class="line">car1.start()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;计算机所有的指令的操作都是有CPU来负责的，cpu是来负责运算的。&lt;strong&gt;OS(操作系统) 调度cpu的最小单位就是线程。&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;进程：是以一个整体的形式暴露给操作系统管理，里面包含对各种资源的调用，内存的管理，网络接口的调用等等，是各种资源管理的集合&lt;br&gt;&amp;emsp;&amp;emsp;线程：是操作系统的最小的调度单位，是一串指令的集合。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python-队列与生产者消费者模式</title>
    <link href="http://yoursite.com/2018/10/26/python-%E9%98%9F%E5%88%97%E4%B8%8E%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/10/26/python-队列与生产者消费者模式/</id>
    <published>2018-10-26T01:47:08.000Z</published>
    <updated>2018-10-26T15:05:59.986Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。<br><a id="more"></a><br>1、为什么要使用生产者和消费者模式<br>&emsp;&emsp;在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。<br>2、什么是生产者消费者模式<br>&emsp;&emsp;生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>&emsp;&emsp;队列（Queue）:在多个线程之间安全的交换数据信息，队列在多线程编程中特别有用<br><strong>队列的好处：</strong></p><ul><li>提高双方的效率，你只需要把数据放到队列中，中间去干别的事情。</li><li>完成了程序的解耦性，两者关系依赖性没有不大。</li></ul><h2 id="队列的类型："><a href="#队列的类型：" class="headerlink" title="队列的类型："></a>队列的类型：</h2><ul><li>lass queue.Queue(maxsize=0) <strong>先进先出，后进后出</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue()   # 生成先入先出队列实例</span><br><span class="line">q.put(1)            # 先放进1，再放入2</span><br><span class="line">q.put(2)</span><br><span class="line">print(q.get())  </span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">1</span><br></pre></td></tr></table></figure></li><li>class queue.LifoQueue(maxsize=0) <strong>先进后出，后进先出</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.LifoQueue()   # 生成先入先出队列实例</span><br><span class="line">q.put(1)            # 先放进1，再放入2</span><br><span class="line">q.put(2)</span><br><span class="line">print(q.get())  </span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">2</span><br></pre></td></tr></table></figure></li><li>class queue.PriorityQueue(maxsize=0)<br><strong>优先级来取数据。存放数据的格式 : Queue.put((priority_number,data))，priority_number越小，优先级越高，data代表存入的值</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.PriorityQueue()</span><br><span class="line">q.put((1, &quot;d1&quot;))</span><br><span class="line">q.put((-1, &quot;d2&quot;))</span><br><span class="line">q.put((6, &quot;d3&quot;))</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get()) </span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">(-1, &apos;d2&apos;)</span><br><span class="line">(1, &apos;d1&apos;)</span><br><span class="line">(6, &apos;d3&apos;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>maxsize代表这个队列最大能够put的长度，如果xsize &lt;= 0，则队列大小为无限大。</strong></p><h2 id="队列的内置方法"><a href="#队列的内置方法" class="headerlink" title="队列的内置方法"></a>队列的内置方法</h2><ul><li><p>exception queue.Empty<br><strong>队列中的数据为空时，就会抛出这个异常。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue()</span><br><span class="line">q.get(block=False)   #获取不到的时候</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 161, in get</span><br><span class="line">    raise Empty</span><br><span class="line">queue.Empty</span><br></pre></td></tr></table></figure></li><li><p>exception queue.Full<br><strong>当队列中满了以后，再放数据的话，就会抛出此异常。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue(maxsize=1)  </span><br><span class="line">q.put(1)</span><br><span class="line">q.put(1,block=False)</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 184, in put_nowait</span><br><span class="line">    return self.put(item, block=False)</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 130, in put</span><br><span class="line">    raise Full</span><br><span class="line">queue.Full</span><br></pre></td></tr></table></figure></li><li><p>Queue.qsize()<br><strong>查看队列的大小。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue()  </span><br><span class="line">q.put(20)</span><br><span class="line">q.put(21)</span><br><span class="line">print(q.qsize())   #查看队列的大小</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">2</span><br></pre></td></tr></table></figure></li><li><p>Queue.empty()<br><strong>队列如果为空返回True，不为空返回False。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue()  </span><br><span class="line">q.put(1)</span><br><span class="line">print(q.empty())   #查看队列是否为空</span><br><span class="line">q.get()</span><br><span class="line">print(q.empty())   #查看队列是否为空</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure></li><li><p>Queue.full()<br><strong>队列如果满了，返回True，没有满返回False。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue(maxsize=1)  </span><br><span class="line">q.put(1)</span><br><span class="line">print(q.full())   #查看队列是否满</span><br><span class="line">q.get()</span><br><span class="line">print(q.full())   #查看队列是否满</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li><li><p>Queue.put(item,block=True,timeout=None)<br><strong>把数据插入队列中。block参数默认为true，timeout默认值是None。如果blcok为false的话，那么在put时候超过设定的maxsize的值，就会报full 异常。如果timeout设置值得话，说明put值得个数超过maxsize值，那么会在timeout几秒之后抛出full异常。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue(maxsize=1)  #是定队列的大小为1</span><br><span class="line">q.put(1)</span><br><span class="line">q.put(1,block=False)   #block不会阻塞，会full异常</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 130, in put</span><br><span class="line">    raise Full</span><br><span class="line">queue.Full</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue(maxsize=1)  #是定队列的大小为1</span><br><span class="line">q.put(1)</span><br><span class="line">q.put(1,timeout=1)    #超过1秒，则会报full异常</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 130, in put</span><br><span class="line">    raise Full</span><br><span class="line">queue.Full</span><br></pre></td></tr></table></figure></li><li><p>Queue.put_nowait(item)<br><strong>等同于Queue.put(item,block=False)或者是Queue.put(item,False)。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue(maxsize=1)</span><br><span class="line">q.put(1)</span><br><span class="line">q.put_nowait(1)   #等同于q.put(1,block=False)</span><br><span class="line">#输出</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 184, in put_nowait</span><br><span class="line">    return self.put(item, block=False)</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 130, in put</span><br><span class="line">    raise Full</span><br><span class="line">queue.Full</span><br></pre></td></tr></table></figure></li><li><p>Queue.get(block=True,timeout=None)<br><strong>移除并返回队列中的序列。参数block=true并且timeout=None。如果block=false的话，那么队列为空的情况下，就直接Empty异常。如果timeout有实际的值，这个时候队列为空，执行get的时候，则时隔多长时间则报出Empty的异常。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue()</span><br><span class="line">q.put(1)</span><br><span class="line">q.get()</span><br><span class="line">q.get(block=False)    #获取不到值，直接抛Empty异常</span><br><span class="line">#输出</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 161, in get</span><br><span class="line">    raise Empty</span><br><span class="line">queue.Empty</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue()</span><br><span class="line">q.put(1)</span><br><span class="line">q.get()</span><br><span class="line">q.get(timeout=1)    #设置超时时间，抛出Empty异常</span><br><span class="line">#输出</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 172, in get</span><br><span class="line">    raise Empty</span><br><span class="line">queue.Empty</span><br></pre></td></tr></table></figure></li><li><p>Queue.get_nowait(item)<br><strong>等同于Queue.get(block=False)或者Queue.get(False)。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue()</span><br><span class="line">q.put(1)</span><br><span class="line">q.get()</span><br><span class="line">q.get_nowait()   #等同于q.get(block=False)</span><br><span class="line">#输出</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 192, in get_nowait</span><br><span class="line">    return self.get(block=False)</span><br><span class="line">  File &quot;D:\Python\Python35\lib\queue.py&quot;, line 161, in get</span><br><span class="line">    raise Empty</span><br><span class="line">queue.Empty</span><br></pre></td></tr></table></figure></li><li><p>Queue.task_done()<br><strong>get()用于获取任务，task_done()则是用来告诉队列之前获取的任务已经处理完成</strong></p></li><li><p>Queue.join()<br><strong>block(阻塞)直到queue（队列）被消费完毕,如果生产者生产10个包子，那么要等消费者把这个10个包子全部消费完毕，生产者才能继续往下执行。</strong></p></li></ul><p><strong>task_done和jion的理解</strong></p><h2 id="生成者消费者模型例子"><a href="#生成者消费者模型例子" class="headerlink" title="生成者消费者模型例子"></a>生成者消费者模型例子</h2><h3 id="生产者生产完毕，消费者再消费例子："><a href="#生产者生产完毕，消费者再消费例子：" class="headerlink" title="生产者生产完毕，消费者再消费例子："></a>生产者生产完毕，消费者再消费例子：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import queue</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def producer():</span><br><span class="line">    for i in range(10):</span><br><span class="line">        q.put(&quot;骨头 %s&quot; % i)</span><br><span class="line"> </span><br><span class="line">    print(&quot;开始等待所有的骨头被取走...&quot;)</span><br><span class="line">    q.join()  # 等待这个骨头队列被消费完毕</span><br><span class="line">    print(&quot;所有的骨头被取完了...&quot;)</span><br><span class="line"></span><br><span class="line">def consumer(n):</span><br><span class="line">    while q.qsize() &gt; 0:</span><br><span class="line">        print(&quot;%s 取到&quot; % n, q.get())</span><br><span class="line">        q.task_done()  # 每去到一个骨头，便告知队列这个任务执行完了</span><br><span class="line"> </span><br><span class="line">q = queue.Queue()</span><br><span class="line"> </span><br><span class="line">p = threading.Thread(target=producer,)</span><br><span class="line">p.start()</span><br><span class="line"> </span><br><span class="line">c1 = consumer(&quot;QQ&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/python-队列/20181026091046063.png" alt=""></p><h3 id="边生产边消费的模型例子"><a href="#边生产边消费的模型例子" class="headerlink" title="边生产边消费的模型例子"></a>边生产边消费的模型例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import time,random</span><br><span class="line">import queue,threading</span><br><span class="line">q = queue.Queue()</span><br><span class="line"> </span><br><span class="line">def producer(name):</span><br><span class="line">  count = 0</span><br><span class="line"> </span><br><span class="line">  while count &lt; 10:</span><br><span class="line">    time.sleep(random.randrange(3))</span><br><span class="line">    q.put(count)  # 在队列里放包子</span><br><span class="line">    print&apos;Producer %s has produced %s baozi..&apos; (% (name, count))</span><br><span class="line">    count += 1</span><br><span class="line"> </span><br><span class="line">def consumer(name):</span><br><span class="line">  count = 0</span><br><span class="line">  while count &lt; 10:</span><br><span class="line">    time.sleep(random.randrange(4))</span><br><span class="line">    if not q.empty():  # 如果还有包子</span><br><span class="line">        data = q.get()  # 就继续获取保证</span><br><span class="line">        print(data)</span><br><span class="line">        print(&apos;Consumer %s has eat %s baozi...&apos; % (name, data))</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;-----no baozi anymore----&quot;)</span><br><span class="line">    count += 1</span><br><span class="line"> </span><br><span class="line">p1 = threading.Thread(target=producer, args=(&apos;A&apos;,))</span><br><span class="line">c1 = threading.Thread(target=consumer, args=(&apos;B&apos;,))</span><br><span class="line">p1.start()</span><br><span class="line">c1.start()</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.rearib.top/python-队列/20181026091459130.png" alt=""><br>流程图:<br><img src="http://qiniu.rearib.top/python-队列/20181026091531607.png" alt=""></p><ul><li>生产者生产，消费者消费。</li><li>消费者每消费一次，都要去执行以下task_done()方法，来告诉消费者已经消费成功，相当于吃完饭，消费者应该给钱了。</li><li>消费者每消费一次，则队列中计数器会做减1操作。</li><li>当队列中的计数器为0的时候，则生产者不阻塞，继续执行，不为0的时候，则阻塞，直到消费者消费完毕为止。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用vagrant搭建虚拟开发环境</title>
    <link href="http://yoursite.com/2018/09/10/%E4%BD%BF%E7%94%A8vagrant%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2018/09/10/使用vagrant搭建虚拟开发环境/</id>
    <published>2018-09-10T13:51:45.000Z</published>
    <updated>2018-10-26T01:27:36.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><p>通过镜像文件创建虚拟环境:</p><ul><li>virtualbox</li><li>VMware</li></ul><h1 id="什么是Vagrant"><a href="#什么是Vagrant" class="headerlink" title="什么是Vagrant"></a>什么是Vagrant</h1><p>&emsp;&emsp;Vagrant是构建在虚拟化技术之上的虚拟机运行环境管理工具,它的运行依赖于虚拟机：</p><blockquote><p>建立和删除虚拟机<br>配置虚拟机运行参数<br>管理虚拟机运行状态<br>自动化配置和安装开发环境<br>打包分发虚拟机运行环境</p></blockquote><p><strong>优点</strong><br>&emsp;&emsp;跨平台、可移动、自动化部署无需人工干预<br><img src="http://qiniu.rearib.top/使用vagrant搭建虚拟开发环境/20180910100227928.png" alt=""></p><h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><ul><li>virtualbox</li><li>vagrant(注意vagrant和virtualbox之间的版本关系)</li><li>xshell</li></ul><h1 id="vagrant命令"><a href="#vagrant命令" class="headerlink" title="vagrant命令"></a>vagrant命令</h1><p>虚拟机的本质底层还是一个操作系统，使用虚拟机创建虚拟环境使用.iso文件，vagrant创建虚拟环境使用.box文件。</p><h2 id="vagrant常用命令："><a href="#vagrant常用命令：" class="headerlink" title="vagrant常用命令："></a>vagrant常用命令：</h2><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">vagrant box list</td><td style="text-align:center">查看目前已有的box</td></tr><tr><td style="text-align:center">vagrant box add</td><td style="text-align:center">新增加一个box</td></tr><tr><td style="text-align:center">vagrant box remove</td><td style="text-align:center">删除指定box</td></tr><tr><td style="text-align:center">vagrant init</td><td style="text-align:center">初始化配置vagrantfile</td></tr><tr><td style="text-align:center">vagrant up</td><td style="text-align:center">启动虚拟机</td></tr><tr><td style="text-align:center">vagrant ssh</td><td style="text-align:center">ssh登录虚拟机</td></tr><tr><td style="text-align:center">vagrant suspend</td><td style="text-align:center">挂起虚拟机</td></tr><tr><td style="text-align:center">vagrant reload</td><td style="text-align:center">重启虚拟机</td></tr><tr><td style="text-align:center">vagrant halt</td><td style="text-align:center">关闭虚拟机</td></tr><tr><td style="text-align:center">vagrant status</td><td style="text-align:center">查看虚拟机状态</td></tr><tr><td style="text-align:center">vagrant status</td><td style="text-align:center">删除虚拟机</td></tr></tbody></table><h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><ol><li>虚拟机创建的创建和查看<br>&emsp;&emsp;Vagrant使用基础镜像来快速克隆虚拟机，而不是从头开始构建虚拟机。这些基础镜像在 Vagrant 中被称为“box”，并且指定用于 Vagrant 环境的 box 始终是创建新 Vagrantfile 后的第一步。<br>下载好.box文件后使用<strong>vagrant box add 虚拟环境名称 box文件名</strong>创建虚拟环境<br><img src="http://qiniu.rearib.top/使用vagrant搭建虚拟开发环境/20180910110255933.png" alt=""></li><li>新建imooc文件夹，进入文件夹，初始化配置vagrantfile，此时会生成一个vagrantfile文件<br><img src="http://qiniu.rearib.top/使用vagrant搭建虚拟开发环境/20180910111231943.png" alt=""></li><li>执行vagrant up，会在virtualbox中多一个虚拟环境实例，但是命令行一直会提示<br><img src="http://qiniu.rearib.top/使用vagrant搭建虚拟开发环境/20180910112728939.png" alt=""></li><li>这是由于虚拟机获取不到物理机的公钥,</li></ol><h2 id="创建Vagrantfile文件"><a href="#创建Vagrantfile文件" class="headerlink" title="创建Vagrantfile文件"></a>创建Vagrantfile文件</h2><p>&emsp;&emsp;配置 Vagrant 项目的第一步是创建 Vagrantfile 文件。Vagrantfile 文件的目的有两个：</p><blockquote><p>设置项目的根目录。Vagrant 中的许多配置选项是相对于这个根目录的。<br>描述运行项目的机器类型和资源，以及需要安装的软件和访问方式。</p></blockquote><p>&emsp;&emsp;Vagrant 内置了 vagrant init 命令，用于将目录初始化为 Vagrant 使用。请在你的终端中输入以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir vagrant_getting_started</span><br><span class="line">$ cd vagrant_getting_started</span><br><span class="line">$ vagrant init</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;命令执行完后会在你的目录中创建 Vagrantfile 文件。可以查看这个文件，里面写满了注释和示例。虽然看起来很吓人，但不要害怕，我们会尽快修改它。<br>&emsp;&emsp;也可以在预先存在的目录中使用 vagrant init 命令配置已经存在的项目使用 Vagrant。<br>&emsp;&emsp;如果你使用版本控制，则 Vagrantfile 可以用于项目的版本控制。这样，每个与该项目合作的人都可以从 Vagrant 中受益，而无需任何前期工作.</p><h2 id="box的安装与使用"><a href="#box的安装与使用" class="headerlink" title="box的安装与使用"></a>box的安装与使用</h2><p>&emsp;&emsp;Vagrant 使用基础镜像来快速克隆虚拟机，而不是从头开始构建虚拟机。这些基础镜像在 Vagrant 中被称为“box”，并且指定用于 Vagrant 环境的 box 始终是创建新 Vagrantfile 后的第一步。</p><ul><li>安装 box<br>通过<code>vagrant box add</code>命令可以将 box 加入到 Vagrant。这会将 box 存储在一个特定的名称下，以便多个 Vagrant 环境可以重复利用。如果你还没有添加一个 box，可以这样做：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant box add hashicorp/precise64</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;这将从 HashiCorp 的 Vagrant Cloud box 目录 下载名为“hashicorp/precise64”的 box。虽然从 HashiCorp 的 Vagrant Cloud下载 box 是最便利的方式，你也可以从本地文件或指定的 URL 等添加 box。<br>&emsp;&emsp;对于当前用户，box 全局存储。每个项目都使用一个 box 作为初始镜像来克隆，并且从不修改基本镜像。这意味着如果你有两个项目都使用我们刚刚添加的 hashicorp/precise64 这个 box，则在一台 guest 机器中添加文件将不会对另一台机器产生影响。<br>&emsp;&emsp;在上面的命令中，你会注意到这些 box 是有命名空间的。box 分为两部分 - 用户名和 box 名 - 用斜线分隔。在上面的例子中，用户名是“hashicorp”，并且 box 是“precise64”。也可以通过 URL 或本地文件路径来指定 box，但入门指南中不会涉及这些内容。</p><blockquote><p>命名空间不保证规范 box！一个常见的误解是像“ubuntu”这样的命名空间代表了 Ubuntu 这个 box 的规范空间。这是不真实的。Vagrant Cloud上的命名空间的行为与 GitHub 上的命名空间非常相似。正如 GitHub 的支持团队无法协助解决某人存储库中的问题一样，HashiCorp 的支持团队无法管理第三方发布的 box。</p></blockquote><ul><li>使用 box<br>&emsp;&emsp;现在 box 已经添加到了 Vagrant，需要配置项目使用这个 box 作为基准镜像。打开空白的 Vagrantfile 文件添加下面的内容：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">  config.vm.box = &quot;hashicorp/precise64&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;这个例子中的“hashicorp/precise64”必须要跟你在上面添加的 box 名字匹配。通过这个配置，Vagrant 知道需要使用哪个 box。如果之前没有添加 box，Vagrant 会在运行时自动下载并添加 box。<br>&emsp;&emsp;可以通过 config.vm.box_version 来指定一个 box 的确切版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">  config.vm.box = &quot;hashicorp/precise64&quot;</span><br><span class="line">  config.vm.box_version = &quot;1.1.0&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;也可以直接使用 config.vm.box_url 指定一个 box 的 URL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">  config.vm.box = &quot;hashicorp/precise64&quot;</span><br><span class="line">  config.vm.box_url = &quot;http://files.vagrantup.com/precise64.box&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>在下一节中，我们将启动 Vagrant 环境并与其进行一点互动。</p><ul><li>查找更多的 box<br>&emsp;&emsp;对于本入门指南的其余部分，我们将仅使用之前添加的“hashicorp/precise64” box。但是在完成入门指南后，第一个问题可能就是“我在哪里可以找到更多的 box？”<br>&emsp;&emsp;HashiCorp 的 Vagrant Cloud box 目录 是寻找更多 box 的最佳地点。HashiCorp 的 Vagrant Cloud 有一个可以通过各种平台和技术免费使用的公共目录。HashiCorp 的 Vagrant Cloud 也有很好的搜索功能，可以让你找到你关心的 box。<br>&emsp;&emsp;除了寻找免费的 box，HashiCorp 的 Vagrant Cloud 允许你托管自己的 box，如果打算为自己的组织创建 box 的话还可以创建私有 box。</li></ul><h2 id="启动-vagrant-及-通过-ssh-登录虚拟机"><a href="#启动-vagrant-及-通过-ssh-登录虚拟机" class="headerlink" title="启动 vagrant 及 通过 ssh 登录虚拟机"></a>启动 vagrant 及 通过 ssh 登录虚拟机</h2><p>&emsp;&emsp;在终端运行 vagrant up 命令即可启动 Vagrant 环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant up</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;不到一分钟，命令就会执行完毕，运行 Ubuntu 的虚拟机会启动成功。Vagrant 运行虚拟机的时候没有 UI 界面。可以通过 SSH 连接到机器判断机器是否运行成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant ssh</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个命令会让你进入一个完整的 SSH 会话。会话建立后可以与机器进行交互，做任何你想做的事情。要小心 rm -rf /，因为 Vagrant 与包含 Vagrantfile 的主机上的目录共享一个 /vagrant 目录，这会删除所有这些文件。共享文件夹将在下一节介绍。<br>&emsp;&emsp;花点时间思考刚刚发生的事情：通过终端中的一行配置和一条命令，我们创建了一个功能齐全的，可通过 SSH 访问的虚拟机。SSH 会话可以用 CTRL + D 终止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vagrant@precise64:~$ logout</span><br><span class="line">Connection to 127.0.0.1 closed.</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;完成了需要使用虚拟机的工作后，在你的主机上运行 vagrant destroy，Vagrant 将终止虚拟机使用任何资源。<br>&emsp;&emsp;<code>vagrant destroy</code> 命令实际上并不删除下载的 box 文件。可以使用<code>vagrant box remove</code> 命令彻底删除 box 文件。</p><h2 id="同步目录（synced-folders）"><a href="#同步目录（synced-folders）" class="headerlink" title="同步目录（synced folders）"></a>同步目录（synced folders）</h2><p>&emsp;&emsp;尽管可以非常轻松的启动一台虚拟机，但很少有人希望通过 SSH 使用基于终端的编辑器来编辑文件。幸运的是，借助 Vagrant 你不需要这样做。通过使用同步目录，Vagrant 会自动同步 guest 机器上的文件。<br>&emsp;&emsp;默认情况下，Vagrant 将你的项目的目录（即 Vagrantfile 的目录）共享到 guest 中的 /vagrant 目录。<br>&emsp;&emsp;<strong>注意，当使用 vagrant ssh 目录进入机器时，默认进入 /home/vagrant 目录。  /home/vagrant 是与同步的 /vagrant 目录不同的目录。</strong><br>&emsp;&emsp;如果终端报错，提示不兼容 guest additions（或没有 guest additions），那么可能需要更新 box 或选择不同的 box，如 hashicorp/precise64。一些用户成功使用了 vagrant-vbguest 插件，但它并未得到 Vagrant 核心团队的正式支持。<br>&emsp;&emsp;再次运行 vagrant up 启动 vagrant，然后通过 vagrant ssh 进入机器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant up</span><br><span class="line">...</span><br><span class="line">$ vagrant ssh</span><br><span class="line">...</span><br><span class="line">vagrant@precise64:~$ ls /vagrant</span><br><span class="line">Vagrantfile</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;不管你信不信，你在虚拟机中看到的 Vagrantfile 文件实际上是你宿主机上的同一个文件。下面证明一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vagrant@precise64:~$ touch /vagrant/foo</span><br><span class="line">vagrant@precise64:~$ exit</span><br><span class="line">$ ls</span><br><span class="line">foo Vagrantfile</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;现在，“foo”文件会出现在你的宿主机上。你可以看到，Vagrant 保证了这个目录的同步。<br>&emsp;&emsp;通过同步目录，你可以继续使用宿主机上你自己的编辑器，对宿主机中文件的改动会自动同步到 guest 机器中。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>&emsp;&emsp;现在我们已经有了一个运行 Ubuntu 的虚拟机，并且可以在宿主机上编辑文件并自动同步到虚拟机。现在让我们安装一个 web 服务器，通过服务器访问这些文件。<br>&emsp;&emsp;可以通过 SSH 进入并安装一个 web 服务器并开始工作，但每个使用 Vagrant 的人都必须这样做。相反，Vagrant 内置了对自动配置的支持。使用此功能时，Vagrant 将在执行 vagrant up 时自动安装软件，以便 guest 机器可以重复创建并可立即使用。</p><ol><li>安装 Apache<br>&emsp;&emsp;可以通过 shell 脚本来为刚才的项目设置 Apache。创建下面的 shell 脚本并命名为 bootstrap.sh，保存在 Vagrantfile 文件相同的目录下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y apache2</span><br><span class="line">if ! [ -L /var/www ]; then</span><br><span class="line">  rm -rf /var/www</span><br><span class="line">  ln -fs /vagrant /var/www</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;然后，配置 Vagrant 在设置机器的时候运行这个脚本。编辑 Vagrantfile 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">  config.vm.box = &quot;hashicorp/precise64&quot;</span><br><span class="line">  config.vm.provision :shell, path: &quot;bootstrap.sh&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;“provision” 行是新添加的，告诉 Vagrant 使用 shell 命令执行 bootstrap.sh 文件来设置虚拟机。文件路径是相对于 Vagrantfile 文件所在的项目根目录的相对路径。</p><ol start="2"><li>配置<br>&emsp;&emsp;配置写完后，执行 vagrant up，Vagrant 会自动配置。可以在终端看到 shell 脚本的输出。如果虚拟机已经启动了，则需要执行 vagrant reload –provision，这会快速重启虚拟机并跳过初始化导入阶段。因为 Vagrant 只会在第一次 vagrant up 启动虚拟机的时候自动运行 provisioner，所以需要在 reload 命令中使用 provision 标志指示 Vagrant 必须运行 provisioner。<br>&emsp;&emsp;Vagrant 运行结束后，web 服务器会成功运行。现在还不能在宿主机的浏览器上查看网页，但可以在通过 SSH 进入虚拟机后，通过加载文件来判断配置是否生效：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant ssh</span><br><span class="line">...</span><br><span class="line">vagrant@precise64:~$ wget -qO- 127.0.0.1</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;上面例子会正常工作。我们安装 Apache 并设置其默认的 DocumentRoot 指向我们的 /vagrant 这个默认的同步目录。<br>&emsp;&emsp;可以创建更多文件并在终端查看，下一步需要配置网络选项以便用宿主机的浏览器访问虚拟机。</p><blockquote><p>对于复杂的配置脚本，将自定义的 Vagrant box 与预先安装的软件包打包在一起，而不是每次构建它们可能会更高效。入门指南未涵盖此主题，但可以在 自定义 box 文档中找到该主题。</p></blockquote><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>&emsp;&emsp;现在，我们启动了 web 服务器，并且通过同步目录使用宿主机上的文件提供服务。然而，还只能通过虚拟机中的终端访问服务器。这一章节中，我们会使用 Vagrant 的网络特性，配置 Vagrant 以便从宿主机访问服务器。</p><ul><li><p>端口转发（Port Forwarding）<br>&emsp;&emsp;配置文件中支持端口转发选项。通过端口转发，可以在访问宿主机的某个端口时，自动将流量转发到虚拟机的指定端口。<br>&emsp;&emsp;编辑 Vagrantfile 文件即可实现端口转发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">  config.vm.box = &quot;hashicorp/precise64&quot;</span><br><span class="line">  config.vm.provision :shell, path: &quot;bootstrap.sh&quot;</span><br><span class="line">  config.vm.network :forwarded_port, guest: 80, host: 4567</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>  &emsp;&emsp;运行 vagrant reload 或 vagrant up（取决于虚拟机是否已经启动）加载配置。<br>&emsp;&emsp;一旦虚拟机启动成功，在宿主机的浏览器中访问 <a href="http://127.0.0.1:4567。你应该看到虚拟机中的" target="_blank" rel="noopener">http://127.0.0.1:4567。你应该看到虚拟机中的</a> web 服务器提供的网页。</p></li><li>其他网络<br>Vagrant 还有其他网络配置选项，可以为虚拟机分配静态 IP 地址，或将虚拟机桥接到一个已经存在的网络上。更多资料参考<a href="https://www.vagrantup.com/docs/networking/" target="_blank" rel="noopener">这里</a>。</li></ul><h2 id="share"><a href="#share" class="headerlink" title="share"></a>share</h2><p>&emsp;&emsp;译者注：Vagrant Share 功能通过 ngrok 向所有人提供访问内网开发环境的能力。<br>&emsp;&emsp;现在我们已经启动并运行了一台 Web 服务器，并且可以从你的机器访问，我们拥有一个相当实用的开发环境。但除了提供开发环境外，Vagrant 还可以轻松地在这些环境中共享和协作。Vagrant 中实现这个功能的特性叫做 Vagrant Share。<br>&emsp;&emsp;Vagrant Share 使你可以通过网络向任何人共享 Vagrant 环境。这个功能会提供一个 URL 给你，任何人都可以通过这个 URL 路由到你的 Vagrant 环境。<br>&emsp;&emsp;运行 vagrant share：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant share</span><br><span class="line">...</span><br><span class="line">==&gt; default: Creating Vagrant Share session...</span><br><span class="line">==&gt; default: HTTP URL: http://b1fb1f3f.ngrok.io</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;每个人的 URL 都是不同的。复制你的 URL，通过浏览器访问即可。<br>&emsp;&emsp;如果你修改了共享目录中的文件，刷新 URL 后你会发现更新实时生效。这个 URL 直接路由到你的 Vagrant 环境，可以在世界上任意地点访问。<br>&emsp;&emsp;在终端中通过 Ctrl + C 结束共享会话。可以再次刷新 URL 来验证开发环境是否仍在共享中。<br>&emsp;&emsp;Vagrant Share 比简单的 HTTP 共享更加强大。详情参考 Vagrant Share 文档。</p><h2 id="清理（teardown）"><a href="#清理（teardown）" class="headerlink" title="清理（teardown）"></a>清理（teardown）</h2><p>&emsp;&emsp;我们现在有一个功能齐全的虚拟机，可以用于基本 Web 开发。但如果现在需要更换设备，或者在另一个项目上工作，如何清理我们的开发环境？<br>&emsp;&emsp;借助 Vagrant，可以暂停（suspend），停止（halt）或销毁（destroy）虚拟机。每个选项都有优点和缺点。选择最适合的即可。</p><ul><li>暂停（suspend）：通过调用 vagrant suspend 命令可以暂停虚拟机，此时会保存虚拟机当前运行状态并停止运行。当准备好再次工作时，运行 vagrant up 命令即可从上次暂停的状态恢复。这个方法的最大优点就是快，只要 5 到 10 秒就可以停止并开始工作。缺点是虚拟机仍占用磁盘空间，并且需要消耗更大的磁盘空间来保存虚拟机的 RAM 状态。</li><li>停止（halt）：通过调用 vagrant halt 命令可以优雅关闭虚拟机操作系统并断电。需要再次启动的时候，运行 vagrant up 命令即可。这个方法的好处是会干净地关闭你的机器，保存磁盘的内容，并让它再次干净地启动。缺点是冷启动需要较长时间，且虚拟机仍占用磁盘空间。</li><li>销毁（destroy）：通过调用 vagrant destroy 销毁虚拟机，这将从宿主机中删除虚拟机的所有痕迹。它会停止虚拟机，关闭它并删除其所有硬盘资源。当你准备好再次工作时，运行 vagrant up 命令即可。这样做的好处是，宿主机上不会留下残余物。虚拟机消耗的磁盘空间和 RAM 将被回收，并且主机保持清洁。缺点是，由于需要重新导入虚拟机并重新配置，因此需要更多时间。</li></ul><p><a href="https://app.vagrantup.com/boxes/search" target="_blank" rel="noopener">https://app.vagrantup.com/boxes/search</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;虚拟机&quot;&gt;&lt;a href=&quot;#虚拟机&quot; class=&quot;headerlink&quot; title=&quot;虚拟机&quot;&gt;&lt;/a&gt;虚拟机&lt;/h1&gt;&lt;p&gt;通过镜像文件创建虚拟环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;virtualbox&lt;/li&gt;
&lt;li&gt;VMware&lt;/li&gt;
&lt;/ul&gt;
&lt;
      
    
    </summary>
    
    
      <category term="项目部署" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>django-扩展Django自带User模型，实现用户注册与登录</title>
    <link href="http://yoursite.com/2018/09/03/django-%E6%89%A9%E5%B1%95Django%E8%87%AA%E5%B8%A6User%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%B8%8E%E7%99%BB%E5%BD%95/"/>
    <id>http://yoursite.com/2018/09/03/django-扩展Django自带User模型，实现用户注册与登录/</id>
    <published>2018-09-03T09:04:04.000Z</published>
    <updated>2018-10-26T01:25:58.540Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;用户的注册与登陆是一个网站应该具有的基本功能。前面的文章讲解了django自带的auth模块并使用第三方库完成登录注册等功能，今天来好好聊一聊如何扩展扩展Django自带User模型，并自己实现登录注册等功能。</p><h1 id="扩展自带User模型"><a href="#扩展自带User模型" class="headerlink" title="扩展自带User模型"></a>扩展自带User模型</h1><p>&emsp;&emsp;我们需要实现用户登录注册功能就要先设计user表，如果django原有的user表不满足项目需求可以重新设计user表。</p><ul><li>已有字段:<blockquote><p>id: 主键<br>username 用户名，该字段不要随便改动<br>password 密码<br>email 邮箱<br>first_name：名<br>last_name：姓<br>last_login Django自动记录用户最后登录时间<br>is_superuser 表明用户是否是超级用户,默认是False(后台管理会用到)<br>is_staff 表示是否是员工，默认是False(后台管理会用到)<br>is_active 用户是否是激活状态，默认是True<br>date_joined 注册时间，系统自动生成。</p></blockquote></li></ul><h2 id="继承AbstractUser的方式"><a href="#继承AbstractUser的方式" class="headerlink" title="继承AbstractUser的方式"></a>继承AbstractUser的方式</h2><ul><li>自定义user表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">from django.contrib.auth.models import AbstractUser</span><br><span class="line"></span><br><span class="line">class UserProfile(AbstractUser):</span><br><span class="line">    gender_choices = (</span><br><span class="line">        (&apos;male&apos;,&apos;男&apos;),</span><br><span class="line">        (&apos;female&apos;,&apos;女&apos;)</span><br><span class="line">    )</span><br><span class="line">    nick_name = models.CharField(&apos;昵称&apos;,max_length=50,default=&apos;&apos;)</span><br><span class="line">    birthday = models.DateField(&apos;生日&apos;,null=True,blank=True)</span><br><span class="line">    gender = models.CharField(&apos;性别&apos;,max_length=10,choices=gender_choices,default=&apos;female&apos;)</span><br><span class="line">    adress = models.CharField(&apos;地址&apos;,max_length=100,default=&apos;&apos;)</span><br><span class="line">    mobile = models.CharField(&apos;手机号&apos;,max_length=11,null=True,blank=True)</span><br><span class="line">    image = models.ImageField(upload_to=&apos;image/%Y%m&apos;,default=&apos;image/default.png&apos;,max_length=100)</span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name = &apos;用户信息&apos;</span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.username</span><br></pre></td></tr></table></figure></li><li><p>然后再setting.py中修改:</p><blockquote><p>AUTH_USER_MODEL = ‘users.UserProfile’</p></blockquote></li><li><p>执行makemigrations和migrate生成数据表:</p><blockquote><p>python manage.py makemigrations<br>python manage.py migrate</p></blockquote></li><li><p>特别要注意图片和文件model需要指出上传地址upload_to</p><blockquote><p>image = models.ImageField(‘轮播图’,upload_to=’banner/%Y%m’,max_length=100)<br>download = models.FileField(“资源文件”,upload_to=”course/resource/%Y/%m”,max_length=100)</p></blockquote></li><li><p>图片上传需要安装第三方库</p><blockquote><p>pip install pillow</p></blockquote></li></ul><h2 id="使用1对1方式"><a href="#使用1对1方式" class="headerlink" title="使用1对1方式"></a>使用1对1方式</h2><p>我们创建一个UserProfile模型，它只是对User模型的扩展, 与User是1对1的关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">from django.contrib.auth.models import User</span><br><span class="line">class UserProfile(models.Model):</span><br><span class="line">    # 与User是1对1关系</span><br><span class="line">    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name=&apos;profile&apos;)</span><br><span class="line">    org = models.CharField(&apos;Organization&apos;, max_length=128, blank=True)</span><br><span class="line">    telephone = models.CharField(&apos;Telephone&apos;, max_length=50, blank=True)</span><br><span class="line">    mod_date = models.DateTimeField(&apos;Last modified&apos;, auto_now=True)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name = &apos;User Profile&apos;</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.user</span><br></pre></td></tr></table></figure></p><p>然后你可以在终端输入以下命令，就可以创建UserProfile的数据表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations </span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure></p><h1 id="登录注册功能的实现"><a href="#登录注册功能的实现" class="headerlink" title="登录注册功能的实现"></a>登录注册功能的实现</h1><h2 id="配置url"><a href="#配置url" class="headerlink" title="- 配置url"></a>- 配置url</h2><blockquote><p>url(r’^accounts/‘, include(‘users.urls’)),</p></blockquote><figure class="highlight plain"><figcaption><span>users.urls</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">url(r&apos;^register/$&apos;, views.register, name=&apos;register&apos;),</span><br><span class="line">url(r&apos;^login/$&apos;, views.login, name=&apos;login&apos;),</span><br><span class="line">url(r&apos;^logout/$&apos;, views.logout, name=&apos;logout&apos;),</span><br><span class="line">url(r&apos;^user/(?P&lt;pk&gt;\d+)/profile/$&apos;, views.profile, name=&apos;profile&apos;),</span><br><span class="line">url(r&apos;^user/(?P&lt;pk&gt;\d+)/profile/update/$&apos;,views.profile_update,name=&apos;profile_update&apos;),</span><br><span class="line">url(r&apos;^user/(?P&lt;pk&gt;\d+)/pwdchange/$&apos;, views.pwd_change,name=&apos;pwd_change&apos;),</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;用户的注册与登陆是一个网站应该具有的基本功能。前面的文章讲解了django自带的auth模块并使用第三方库完成登录注册等功能，今天来好好聊一聊如何扩展扩展Django自带User模型，并自己实现登录注册等功能。&lt;/p&gt;
&lt;h1 id=&quot;扩展自带Use
      
    
    </summary>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门</title>
    <link href="http://yoursite.com/2018/09/03/Docker%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/09/03/Docker入门/</id>
    <published>2018-09-03T09:03:44.000Z</published>
    <updated>2018-10-26T01:50:49.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker概念"><a href="#Docker概念" class="headerlink" title="Docker概念"></a>Docker概念</h1><p>&emsp;&emsp;Docker是开发人员和系统管理员使用容器进行开发，部署和运行应用程序的平台。使用Linux容器部署应用程序称为容器化。<br><a id="more"></a><br>&emsp;&emsp;容器化越来越受欢迎，因为容器是：</p><ul><li>灵活：即使是最复杂的应用也可以集装箱化。</li><li>轻量级：容器利用并共享主机内核。</li><li>可互换：您可以即时部署更新和升级。</li><li>便携式：您可以在本地构建，部署到云，并在任何地方运行。</li><li>可扩展：您可以增加并自动分发容器副本。</li><li>可堆叠：您可以垂直和即时堆叠服务。</li></ul><h2 id="图像和容器"><a href="#图像和容器" class="headerlink" title="图像和容器"></a>图像和容器</h2><p>&emsp;&emsp;通过运行image启动容器。一个image是一个可执行的包，其中包括运行应用程序所需的所有代码，以及运行时的库，环境变量和配置文件。</p><h2 id="容器和虚拟机"><a href="#容器和虚拟机" class="headerlink" title="容器和虚拟机"></a>容器和虚拟机</h2><p>&emsp;&emsp;容器在Linux上本机运行，与其他容器共享主机的内核。它运行一个独立的进程，不占用任何其他可执行文件的内存，使其轻量级。相比之下，虚拟机（VM）运行一个完整的“客户”操作系统，通过虚拟机管理程序对主机资源进行虚拟访问。通常，VM提供的环境比大多数应用程序需要的资源更多。</p><h2 id="测试Docker版本"><a href="#测试Docker版本" class="headerlink" title="测试Docker版本"></a>测试Docker版本</h2><p>&emsp;&emsp;运行docker –version并确保您拥有受支持的Docker版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br><span class="line">Docker version 17.12.0-ce, build c97c6d6</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;运行docker info或（docker version不–）查看有关docker安装的更多详细信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br><span class="line"></span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 17.12.0-ce</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;要避免权限错误（以及使用sudo），请将您的用户添加到docker组中。阅读更多。</p><h2 id="测试Docker安装"><a href="#测试Docker安装" class="headerlink" title="测试Docker安装"></a>测试Docker安装</h2><p>&emsp;&emsp;通过运行简单的Docker镜像hello-world来测试您的安装是否有效 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image &apos;hello-world:latest&apos; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">ca4f61b1923c: Pull complete</span><br><span class="line">Digest: sha256:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;列出hello-world下载到您的计算机的图像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;列出hello-world在显示其消息后退出的容器（由图像生成）。如果它仍在运行，您将不需要–all选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker container ls --all</span><br><span class="line"></span><br><span class="line">CONTAINER ID     IMAGE           COMMAND      CREATED            STATUS</span><br><span class="line">54f4984ed6a8     hello-world     &quot;/hello&quot;     20 seconds ago     Exited (0) 19 seconds ago</span><br></pre></td></tr></table></figure></p><h2 id="Docker指令"><a href="#Docker指令" class="headerlink" title="Docker指令"></a>Docker指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">## List Docker CLI commands</span><br><span class="line">docker</span><br><span class="line">docker container --help</span><br><span class="line"></span><br><span class="line">## Display Docker version and info</span><br><span class="line">docker --version</span><br><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line">## Execute Docker image</span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line">## List Docker images</span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line">## List Docker containers (running, all, all in quiet mode)</span><br><span class="line">docker container ls</span><br><span class="line">docker container ls --all</span><br><span class="line">docker container ls -aq</span><br></pre></td></tr></table></figure><h2 id="新的开发环境"><a href="#新的开发环境" class="headerlink" title="新的开发环境"></a>新的开发环境</h2><p>&emsp;&emsp;在过去，如果您要开始编写Python应用程序，那么首先需要在你的计算机上安装Python运行环境。而且该环境需要非常适合你的应用程序按预期运行，并且还需要与你的生产环境相匹配。<br>&emsp;&emsp;如果使用Docker，你可以将可移植的Python运行环境时作为映像获取，无需安装。 然后，您的构建可以在应用程序代码旁边包含基本Python映像，确保您的应用程序，其依赖项和运行时都一起运行。<br>&emsp;&emsp;这些可移植图像由称为Dockerfile的东西定义。</p><h2 id="在win创建并运行一个容器"><a href="#在win创建并运行一个容器" class="headerlink" title="在win创建并运行一个容器"></a>在win创建并运行一个容器</h2><ol><li><p>Dockerfile<br>&emsp;&emsp;创建一个空目录。cd进入该目录，创建一个名为Dockerfile的文件，将以下内容复制并粘贴到该文件中，然后保存。<strong>Dockerfile命名必须为“Dockerfile”，Docker镜像构建时，会查找指定目录中的Dockerfile。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Use an official Python runtime as a parent image</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># Set the working directory to /app</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># Copy the current directory contents into the container at /app</span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"># Install any needed packages specified in requirements.txt</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># Make port 80 available to the world outside this container</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># Define environment variable</span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># Run app.py when the container launches</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure></li><li><p>应用程序本身<br>&emsp;&emsp;再创建两个文件，requirements.txt和app.py</p><figure class="highlight plain"><figcaption><span>requirements.txt</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>app.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis, RedisError</span><br><span class="line">import os</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">#Connect to Redis</span><br><span class="line">redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    try:</span><br><span class="line">        visits = redis.incr(&quot;counter&quot;)</span><br><span class="line">    except RedisError:</span><br><span class="line">        visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;</span><br><span class="line"></span><br><span class="line">    html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot;</span><br><span class="line">    return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;, port=80)</span><br></pre></td></tr></table></figure></li><li>构建应用程序<br>&emsp;&emsp;我们准备构建应用程序。确保您仍处于新目录的顶层。这是ls应该显示的内容：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">Dockerfileapp.pyrequirements.txt</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;现在运行build命令。这会创建一个Docker镜像，我们将使用-t它来标记，因此它具有友好的名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyhello .</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;你的构建的镜像将位于您机器的本地Docker镜像注册表中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY            TAG                 IMAGE ID</span><br><span class="line">friendlyhello         latest              326387cea398</span><br></pre></td></tr></table></figure></p><p>4.运行该应用程序<br>&emsp;&emsp;运行应用程序，使用以下方法将计算机的端口4000映射到容器的已发布端口80 -p：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;浏览器打开<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> . 就可以访问hello world.<br><strong> 1. 如果使用win,请使用Docker Machine IP而不是localhost。例如，http：//192.168.99.100：4000。要查找IP地址，请使用该命令docker-machine ip。</strong><br><img src="/django-模板的设计及常用过滤器与标签介绍/20180912015556050.png" alt=""><br><img src="/django-模板的设计及常用过滤器与标签介绍/20180912015607984.png" alt=""></p><p><strong> 2.如果在阿里云运行,需要访问IP:4000,注意要在安全组中添加规则</strong></p><h2 id="Dockerfile-Docker镜像-容器之间关系"><a href="#Dockerfile-Docker镜像-容器之间关系" class="headerlink" title="Dockerfile|Docker镜像|容器之间关系"></a>Dockerfile|Docker镜像|容器之间关系</h2><ul><li>Dockerfile：Dockerfile 是一个文本文件， 它是Docker镜像的描述文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。有了 Dockerfile，当我们需要定制自己额外的需求时，只需在 Dockerfile 上添加或者修改指令，重新生成 image 即可，省去了敲命令的麻烦。</li><li>Docker镜像： 通过Dockerfile做出来的，包含操作系统基础文件和软件运行环境，它使用分层的存储方式。</li><li>容器： 是运行起来的镜像，简单理解，Docker镜像相当于程序，容器相当于进程。<br><strong>使用 Dockerfile 定义镜像，依赖镜像来运行容器</strong><br><img src="/django-模板的设计及常用过滤器与标签介绍/20180912014224585.png" alt=""></li></ul><p>&emsp;&emsp;Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令、容器启动执行指令。一开始必须要指明所基于的镜像名称，接下来一般会说明维护者信息；后面则是镜像操作指令，例如 RUN 指令。每执行一条RUN 指令，镜像添加新的一层，并提交；最后是 CMD 指令，来指明运行容器时的操作命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker概念&quot;&gt;&lt;a href=&quot;#Docker概念&quot; class=&quot;headerlink&quot; title=&quot;Docker概念&quot;&gt;&lt;/a&gt;Docker概念&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Docker是开发人员和系统管理员使用容器进行开发，部署和运行应用程序的平台。使用Linux容器部署应用程序称为容器化。&lt;br&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>django-FBV&amp;CBV</title>
    <link href="http://yoursite.com/2018/09/02/django-FBV&amp;CBV/"/>
    <id>http://yoursite.com/2018/09/02/django-FBV&amp;CBV/</id>
    <published>2018-09-02T06:01:52.000Z</published>
    <updated>2018-10-26T01:50:19.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FBV"><a href="#FBV" class="headerlink" title="FBV"></a>FBV</h1><p>FBV（function base views） 就是在视图里使用函数处理请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url(r&apos;^index/&apos;, views.index),</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    if request.method == &quot;GET&quot;:</span><br><span class="line">        return HttpResponse(&quot;GET&quot;)</span><br><span class="line">    elif request.method == &quot;POST&quot;:</span><br><span class="line">        return HttpResponse(&quot;POST&quot;)</span><br></pre></td></tr></table></figure></p><blockquote><p>step1：根据访问请求，在urls寻找匹配的url映射，得到views.index<br>setp2：根据views.index ，调用views下index函数（传入参数request即用户请求信息）<br>step3：根据客户请求信息对数据进行处理，通过HttpResponse返回客户端</p></blockquote><h1 id="CBV"><a href="#CBV" class="headerlink" title="CBV"></a>CBV</h1><p>CBV（class base views） 就是在视图里使用类处理请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">url(r&apos;^index/&apos;, views.Index.as_view()),</span><br><span class="line"></span><br><span class="line">from django.views import View</span><br><span class="line">class Index(View):</span><br><span class="line">    def get(self, request):</span><br><span class="line">        return HttpResponse(&quot;GET&quot;)</span><br><span class="line">    def post(self, request):</span><br><span class="line">        return HttpResponse(&quot;POST&quot;)</span><br></pre></td></tr></table></figure></p><p>如果是get或者post都执行的代码可以放到dispatch:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def dispatch(self, request, *args, **kwargs):</span><br><span class="line">    # 调用父类中的dispatch</span><br><span class="line">    print(&apos;before&apos;)  # 类似装饰器的功能</span><br><span class="line">    result = super(Home,self).dispatch(request, *args, **kwargs)</span><br><span class="line">    print(&apos;after&apos;)  # 类似装饰器的功能</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure></p><p>其实CBV过程可以看成是FBV过程的抽象化、对象化。他需要最基本的三个类View，ContextMixin，TemplateResponseMixin<br>对应FBV的三个步骤：</p><blockquote><p>step1. View类提供类方法as_view(),用于调用dipatch()，根据request类型分发给get，post…等对应方法处理。<br>step2. ContextMixin类，get_context_data(self, **kwargs)获取上下文数据，如果对数据库进行操作均可以继承该类，然后将增删改查的结果放入上下文数据中（即重写get_context_data）<br>step3. TemplateResponseMixin类，将内容渲染到指定模板上，通过render_to_response()方法实现对应功能<br>而其他模板视图基本就是在这三个类上进行继承重写后得到。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FBV&quot;&gt;&lt;a href=&quot;#FBV&quot; class=&quot;headerlink&quot; title=&quot;FBV&quot;&gt;&lt;/a&gt;FBV&lt;/h1&gt;&lt;p&gt;FBV（function base views） 就是在视图里使用函数处理请求。&lt;br&gt;&lt;figure class=&quot;highlig
      
    
    </summary>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>django-编辑器Markdown的使用</title>
    <link href="http://yoursite.com/2018/09/01/django-%E7%BC%96%E8%BE%91%E5%99%A8Markdown%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/09/01/django-编辑器Markdown的使用/</id>
    <published>2018-09-01T14:46:43.000Z</published>
    <updated>2018-10-26T01:25:23.041Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;之前的一篇博客写到了如何在django中使用Ueditor,今天我们看看如何在django中使用Markdown进行文本的编辑.它是基于<a href="https://pandao.github.io/editor.md/" target="_blank" rel="noopener">editor.md</a>插件</p><h1 id="Markdown的安装"><a href="#Markdown的安装" class="headerlink" title="Markdown的安装"></a>Markdown的安装</h1><p>Markdown使用的是源码安装的方式:</p><ol><li>首先到<a href="https://github.com/feiyin0719/django-markdown-editor.git" target="_blank" rel="noopener">github</a>下载源码</li><li>把里面的markdown文件夹放到extra_apps中</li><li>然后在INSTALLED_APPS中添加markdown.并在url.py中添加:<blockquote><p>url(r’^markdown/‘, include(‘markdown.urls’)),</p></blockquote></li><li>在setting.py中设置图片上传的文件夹<blockquote><p>MARKDOWN_IMAGE_FLODER = ‘ markdown ‘  #图片会上传到media/markdown文件夹下</p></blockquote></li><li>配置上传图片格式<blockquote><p>MARKDOWN_IMAGE_FORMATS = [“jpg”，”jpeg”，”gif”，”png”，”bmp”，”webp”]</p></blockquote></li></ol><h1 id="在admin中使用"><a href="#在admin中使用" class="headerlink" title="在admin中使用"></a>在admin中使用</h1><p>&emsp;&emsp;所有的TextField都使用markdown编辑器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">from markdown.widgets import AdminMarkdownWidget</span><br><span class="line"></span><br><span class="line">class TestAdmin(admin.ModelAdmin):</span><br><span class="line">    formfield_overrides = &#123;</span><br><span class="line">        models.TextField: &#123;&apos;widget&apos;: AdminMarkdownWidget()&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">admin.site.register(Test,TestAdmin)</span><br></pre></td></tr></table></figure></p><h1 id="在xadmin中使用"><a href="#在xadmin中使用" class="headerlink" title="在xadmin中使用"></a>在xadmin中使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">from markdown.widgets import XAdminMarkdownWidget</span><br><span class="line"></span><br><span class="line">class TestAdmin(admin.ModelAdmin):</span><br><span class="line">    formfield_overrides = &#123;</span><br><span class="line">        models.TextField: &#123;&apos;widget&apos;: XAdminMarkdownWidget()&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">xadmin.site.register(Test,TestAdmin)</span><br></pre></td></tr></table></figure><h1 id="在form中使用"><a href="#在form中使用" class="headerlink" title="在form中使用"></a>在form中使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django import forms</span><br><span class="line">from markdown.forms import MarkdownField</span><br><span class="line"></span><br><span class="line">class BlogForm(forms.Form):</span><br><span class="line">    name = forms.CharField()</span><br><span class="line">    context = MarkdownField()</span><br></pre></td></tr></table></figure><p>这里注意在前端需要添加去添加css和js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Hello Django!&lt;/title&gt;</span><br><span class="line">    &#123;&#123;form.media&#125;&#125;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&#123;&#123;form&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><h1 id="支持参数"><a href="#支持参数" class="headerlink" title="支持参数"></a>支持参数</h1><blockquote><p>width<br>height<br>theme<br>previewTheme<br>editorTheme<br>syncScrolling<br>saveHTMLToTextarea<br>emoji<br>taskList<br>tocm<br>tex<br>flowChart<br>sequenceDiagram<br>codeFold</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">formfield_overrides = &#123;</span><br><span class="line">        models.TextField: &#123;&apos;widget&apos;: AdminMarkdownWidget(emoji=False)&#125;,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="最终后端效果"><a href="#最终后端效果" class="headerlink" title="最终后端效果"></a>最终后端效果</h1><p><img src="http://qiniu.rearib.top/django-编辑器Markdown的使用/20180902125815711.png" alt=""></p><h1 id="前端显示"><a href="#前端显示" class="headerlink" title="前端显示"></a>前端显示</h1><p><img src="http://qiniu.rearib.top/django-编辑器Markdown的使用/20180902013144792.png" alt=""><br>&emsp;&emsp;你会发现前端显示是有问题的,这个时候需要把markdown语法转换为html,我们需要安装django-markdown-deux.</p><ol><li>首先运行<blockquote><p>pip install django-markdown-deux</p></blockquote></li><li>在INSTALLED_APPS中添加markdown_deux</li><li>在需要显示markdown的页面:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load markdown_deux_tags %&#125;</span><br><span class="line">&#123;&#123; course.detail | markdown &#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><p>最后效果:<br><img src="http://qiniu.rearib.top/django-编辑器Markdown的使用/1.png" alt=""></p><p><strong>&emsp;&emsp;这里还有一个问题就是无法修改图片的大小,目前没有比较有效的解决办法,如果对图片大小要求比较高,可以使用七牛等支持参数的图床,如果有其他想法,欢迎交流~</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;之前的一篇博客写到了如何在django中使用Ueditor,今天我们看看如何在django中使用Markdown进行文本的编辑.它是基于&lt;a href=&quot;https://pandao.github.io/editor.md/&quot; target=&quot;_bl
      
    
    </summary>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="文本编辑" scheme="http://yoursite.com/tags/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>django-编辑器Ueditor的使用</title>
    <link href="http://yoursite.com/2018/09/01/django-%E7%BC%96%E8%BE%91%E5%99%A8Ueditor%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/09/01/django-编辑器Ueditor的使用/</id>
    <published>2018-09-01T14:46:26.000Z</published>
    <updated>2018-10-26T01:25:38.399Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Ueditor是比较流行的富文本编辑器,主要用于内容的编辑、排版和图片上传等。本文主要介绍Ueditor的安装并搭配xadmin的使用。</p><h1 id="富文本编辑器Ueditor"><a href="#富文本编辑器Ueditor" class="headerlink" title="富文本编辑器Ueditor"></a>富文本编辑器Ueditor</h1><p>&emsp;&emsp;UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码。</p><h1 id="Ueditor的源码安装"><a href="#Ueditor的源码安装" class="headerlink" title="Ueditor的源码安装"></a>Ueditor的源码安装</h1><p>&emsp;&emsp;前往<a href="https://github.com/twz915/DjangoUeditor3/" target="_blank" rel="noopener">github</a>下载源码然后解压，把DjangoUeditor文件夹拷贝到项目目录(extra_apps)下面。</p><h1 id="setting和url中的配置"><a href="#setting和url中的配置" class="headerlink" title="setting和url中的配置"></a>setting和url中的配置</h1><ul><li><p>settings中添加app</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &apos;DjangoUeditor&apos;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>MxOnline/urls.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path(&apos;ueditor/&apos;,include(&apos;DjangoUeditor.urls&apos; )),</span><br></pre></td></tr></table></figure></li></ul><h1 id="model和adminx中的配置"><a href="#model和adminx中的配置" class="headerlink" title="model和adminx中的配置"></a>model和adminx中的配置</h1><ul><li><p>course/models.py中Course修改detail字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Course(models.Model):</span><br><span class="line">    # detail = models.TextField(&quot;课程详情&quot;)</span><br><span class="line">    detail = UEditorField(verbose_name=u&apos;课程详情&apos;, width=600, height=300, imagePath=&quot;courses/ueditor/&quot;,</span><br><span class="line">                          filePath=&quot;courses/ueditor/&quot;, default=&apos;&apos;)</span><br></pre></td></tr></table></figure></li><li><p>xadmin/plugs目录下新建ueditor.py文件,代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import xadmin</span><br><span class="line">from xadmin.views import BaseAdminPlugin, CreateAdminView, ModelFormAdminView, UpdateAdminView</span><br><span class="line">from DjangoUeditor.models import UEditorField</span><br><span class="line">from DjangoUeditor.widgets import UEditorWidget</span><br><span class="line">from django.conf import settings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class XadminUEditorWidget(UEditorWidget):</span><br><span class="line">    def __init__(self, **kwargs):</span><br><span class="line">        self.ueditor_options = kwargs</span><br><span class="line">        self.Media.js = None</span><br><span class="line">        super(XadminUEditorWidget,self).__init__(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UeditorPlugin(BaseAdminPlugin):</span><br><span class="line">    def get_field_style(self, attrs, db_field, style, **kwargs):</span><br><span class="line">        if style == &apos;ueditor&apos;:</span><br><span class="line">            if isinstance(db_field, UEditorField):</span><br><span class="line">                widget = db_field.formfield().widget</span><br><span class="line">                param = &#123;&#125;</span><br><span class="line">                param.update(widget.ueditor_settings)</span><br><span class="line">                param.update(widget.attrs)</span><br><span class="line">                return &#123;&apos;widget&apos;:XadminUEditorWidget(**param)&#125;</span><br><span class="line">        return attrs</span><br><span class="line"></span><br><span class="line">    def block_extrahead(self, context, nodes):</span><br><span class="line">        js  = &apos;&lt;script type=&quot;text/javascript&quot; src=&quot;%s&quot;&gt;&lt;/script&gt;&apos; %(settings.STATIC_URL + &quot;ueditor/ueditor.config.js&quot;)</span><br><span class="line">        js += &apos;&lt;script type=&quot;text/javascript&quot; src=&quot;%s&quot;&gt;&lt;/script&gt;&apos; %(settings.STATIC_URL + &quot;ueditor/ueditor.all.min.js&quot;)</span><br><span class="line">        nodes.append(js)</span><br><span class="line"></span><br><span class="line">xadmin.site.register_plugin(UeditorPlugin, UpdateAdminView)</span><br><span class="line">xadmin.site.register_plugin(UeditorPlugin, CreateAdminView)</span><br></pre></td></tr></table></figure></li><li><p>xadmin/plugs/<strong>init</strong>.py里面添加ueditor插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PLUGINS = (</span><br><span class="line">   &apos;ueditor&apos;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>course/adminx.py中使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class CourseAdmin(object):</span><br><span class="line">    #detail就是要显示为富文本的字段名</span><br><span class="line">    style_fields = &#123;&quot;detail&quot;: &quot;ueditor&quot;&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="xadmin后台效果"><a href="#xadmin后台效果" class="headerlink" title="xadmin后台效果"></a>xadmin后台效果</h1><p><img src="http://qiniu.rearib.top/django-编辑器Ueditor的使用/20180901113023930.png" alt=""><br>&emsp;&emsp;但是前段显示还是会有问题:<br><img src="http://qiniu.rearib.top/django-编辑器Ueditor的使用/20180901112749059.png" alt=""><br>&emsp;&emsp;这是因为需要在模板中必须关闭Django的自动转义才能正常显示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% autoescape off %&#125;</span><br><span class="line">&#123;&#123; course.detail &#125;&#125;</span><br><span class="line">&#123;% endautoescape %&#125;</span><br></pre></td></tr></table></figure></p><h1 id="最终显示效果"><a href="#最终显示效果" class="headerlink" title="最终显示效果"></a>最终显示效果</h1><p><img src="http://qiniu.rearib.top/django-编辑器Ueditor的使用/20180901113054800.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;Ueditor是比较流行的富文本编辑器,主要用于内容的编辑、排版和图片上传等。本文主要介绍Ueditor的安装并搭配xadmin的使用。&lt;/p&gt;
&lt;h1 id=&quot;富文本编辑器Ueditor&quot;&gt;&lt;a href=&quot;#富文本编辑器Ueditor&quot; clas
      
    
    </summary>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="文本编辑" scheme="http://yoursite.com/tags/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>在线教育平台Mxonline-xadmin的使用</title>
    <link href="http://yoursite.com/2018/09/01/%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2%E5%B9%B3%E5%8F%B0Mxonline-xadmin%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/09/01/在线教育平台Mxonline-xadmin的使用/</id>
    <published>2018-09-01T05:10:09.000Z</published>
    <updated>2018-10-26T01:24:18.739Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;django自带了admin用于后台管理，但是在github上还有一个更好看、功能更强大的库来管理后台，叫xadmin，今天就来好好介绍一下xadmin的使用。</p><h1 id="xadmin的安装"><a href="#xadmin的安装" class="headerlink" title="xadmin的安装"></a>xadmin的安装</h1><p>&emsp;&emsp;通过<a href="https://xadmin.readthedocs.io/en/docs-chinese/quickstart.html" target="_blank" rel="noopener">文档</a>我们可以发现，我们有两种方法可以进行安装。</p><ol><li>使用pip install 安装<blockquote><p>pip install django-xadmin</p></blockquote></li><li>下载源码安装<blockquote><p>需要安装requirements.txt中的依赖包</p></blockquote></li></ol><p>&emsp;&emsp;关于源码安装，首先到github搜索 <a href="https://github.com/sshwsfc/xadmin" target="_blank" rel="noopener">xadmin</a>下载源码，然后在项目的工程目录下新建一个extra_apps，把源码放在该目录下，注意extra_apps需要与apps一样在settings中设置。这里不在重复叙述了，然后手动安装requirements.txt中的依赖包。最后在INSTALLED_APPS中添加xadmin和crispy_forms。<br>&emsp;&emsp;接下来配置url:</p><blockquote><p>from extra_apps import xadmin<br>url(r’^xadmin/‘, xadmin.site.urls),</p></blockquote><p>&emsp;&emsp;然后执行migrations和migrate生成数据库表并创建superuser.就可以访问登录啦</p><h1 id="注册app到xadmin后台"><a href="#注册app到xadmin后台" class="headerlink" title="注册app到xadmin后台"></a>注册app到xadmin后台</h1><ol><li>在app文件夹中新建adminx.py:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import xadmin</span><br><span class="line">from .models import EmailVerifyRecord</span><br><span class="line"></span><br><span class="line">#xadmin中这里是继承object，不再是继承admin</span><br><span class="line">class EmailVerifyRecordAdmin(object):</span><br><span class="line">    # 显示的列</span><br><span class="line">    list_display = [&apos;code&apos;, &apos;email&apos;, &apos;send_type&apos;, &apos;send_time&apos;]</span><br><span class="line">    # 搜索的字段，不要添加时间搜索</span><br><span class="line">    search_fields = [&apos;code&apos;, &apos;email&apos;, &apos;send_type&apos;]</span><br><span class="line">    # 过滤</span><br><span class="line">    list_filter = [&apos;code&apos;, &apos;email&apos;, &apos;send_type&apos;, &apos;send_time&apos;]</span><br><span class="line">xadmin.site.register(EmailVerifyRecord,EmailVerifyRecordAdmin)</span><br></pre></td></tr></table></figure></li></ol><h1 id="xadmin的全局配置"><a href="#xadmin的全局配置" class="headerlink" title="xadmin的全局配置"></a>xadmin的全局配置</h1><ul><li>全局配置,包括title和footer等</li><li>app名称汉化，菜单收叠。</li><li>使用Xadmin的主题功能。</li></ul><figure class="highlight plain"><figcaption><span>全局配置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from xadmin import views</span><br><span class="line">class GlobalSettings(object):</span><br><span class="line">    # 修改title</span><br><span class="line">    site_title = &apos;Mxonline后台管理界面&apos;</span><br><span class="line">    # 修改footer</span><br><span class="line">    site_footer = &apos;在线教育平台&apos;</span><br><span class="line">    # 收起菜单</span><br><span class="line">    menu_style = &apos;accordion&apos;</span><br><span class="line">    #将title和footer信息进行注册</span><br><span class="line">xadmin.site.register(views.CommAdminView,GlobalSettings)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>主题功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from xadmin import views</span><br><span class="line">#创建xadmin的最基本管理器配置，并与view绑定</span><br><span class="line">class BaseSetting(object):</span><br><span class="line">    # 开启主题功能</span><br><span class="line">    enable_themes = True</span><br><span class="line">    use_bootswatch = True</span><br><span class="line">#将基本配置管理与view绑定</span><br><span class="line">xadmin.site.register(views.BaseAdminView,BaseSetting)</span><br></pre></td></tr></table></figure><h1 id="修改app的名字"><a href="#修改app的名字" class="headerlink" title="修改app的名字"></a>修改app的名字</h1><p>&emsp;&emsp;在后台左侧的app显示还是英文,如果要设置为中文需要在apps.py中添加verbose_name,然后在<strong>init</strong>.py中添加default_app_config.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apps.py</span><br><span class="line">from django.apps import AppConfig</span><br><span class="line">class UsersConfig(AppConfig):</span><br><span class="line">    name = &apos;users&apos;</span><br><span class="line">    verbose_name = &apos;用户&apos;</span><br><span class="line">    </span><br><span class="line">__init__.py</span><br><span class="line">default_app_config = &apos;users.apps.UsersConfig&apos;</span><br></pre></td></tr></table></figure></p><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p><img src="http://qiniu.rearib.top/Django-xadmin打造在线教育平台-xadmin的使用/20180901044410119.png" alt=""></p><h1 id="后台用户"><a href="#后台用户" class="headerlink" title="后台用户"></a>后台用户</h1><h2 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h2><p>&emsp;&emsp;超级用户拥有所有权限，其它添加的用户默认没有任何权限。进后台添加一个用户“Editor1”,勾上“职员状态”后，这个用户才可以登录进后台。<br><img src="http://qiniu.rearib.top/在线教育平台Mxonline-xadmin的使用/20180901100248901.png" alt=""><br>&emsp;&emsp;默认没添加权限的用户登录到后台的情况如下：<br><img src="http://qiniu.rearib.top/在线教育平台Mxonline-xadmin的使用/20180901095242164.png" alt=""><br>&emsp;&emsp;使用超级管理员账号登录后为用户Editor1添加查看章节的权限后：<br><img src="http://qiniu.rearib.top/在线教育平台Mxonline-xadmin的使用/20180901100428008.png" alt=""><br>&emsp;&emsp;也可以添加一个组赋予相关权限，然后把用户添加到组中：<br><img src="http://qiniu.rearib.top/在线教育平台Mxonline-xadmin的使用/20180901100707800.png" alt=""><br>&emsp;&emsp;重新登录Editor1查看权限：<br><img src="http://qiniu.rearib.top/在线教育平台Mxonline-xadmin的使用/20180901101034415.png" alt=""><br>&emsp;&emsp;<strong>组里面的成员不但拥有自己本身的权限外，还会拥有组的权限</strong></p><h2 id="自定义icon"><a href="#自定义icon" class="headerlink" title="自定义icon"></a>自定义icon</h2><p>&emsp;&emsp;xadmin的图标采用的是第三方css样式“font awesome”,我们可以进官网下载最新的样式替代原本的，<a href="http://www.fontawesome.com.cn/" target="_blank" rel="noopener">下载地址</a><br>&emsp;&emsp;下载完后把里面的“css”和“fonts”两个文件夹拷贝到xadmin的源码（路径：xadmin/static/vendor/font-awesome）里面</p><ul><li><p>使用方法：<br>  以course为例，进官网找到图标的样式<br>  <img src="http://qiniu.rearib.top/在线教育平台Mxonline-xadmin的使用/20180901101427870.png" alt=""><br>  在course/adminx.py使用</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class CourseAdmin(object):</span><br><span class="line">    model_icon = &apos;fa fa-book&apos;</span><br></pre></td></tr></table></figure><p>  <img src="http://qiniu.rearib.top/在线教育平台Mxonline-xadmin的使用/20180901101611065.png" alt=""></p></li></ul><h1 id="后台内容设置"><a href="#后台内容设置" class="headerlink" title="后台内容设置"></a>后台内容设置</h1><h2 id="默认排序、只读字段和不显示的字段"><a href="#默认排序、只读字段和不显示的字段" class="headerlink" title="默认排序、只读字段和不显示的字段"></a>默认排序、只读字段和不显示的字段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class CourseAdmin(object):</span><br><span class="line">    &apos;&apos;&apos;课程&apos;&apos;&apos;</span><br><span class="line">    list_display = [ &apos;name&apos;,&apos;desc&apos;,&apos;detail&apos;,&apos;degree&apos;,&apos;learn_times&apos;,&apos;students&apos;]   #显示的字段</span><br><span class="line">    search_fields = [&apos;name&apos;, &apos;desc&apos;, &apos;detail&apos;, &apos;degree&apos;, &apos;students&apos;]             #搜索</span><br><span class="line">    list_filter = [ &apos;name&apos;,&apos;desc&apos;,&apos;detail&apos;,&apos;degree&apos;,&apos;learn_times&apos;,&apos;students&apos;]    #过滤 </span><br><span class="line">    model_icon = &apos;fa fa-book&apos;            #图标</span><br><span class="line">    ordering = [&apos;-click_nums&apos;]           #排序</span><br><span class="line">    readonly_fields = [&apos;click_nums&apos;]     #只读字段，不能编辑</span><br><span class="line">    exclude = [&apos;fav_nums&apos;]               #不显示的字段</span><br></pre></td></tr></table></figure><h2 id="inlines添加数据"><a href="#inlines添加数据" class="headerlink" title="inlines添加数据"></a>inlines添加数据</h2><p>&emsp;&emsp;model设计时章节信息和资源指向课程,但是按之前的配置方式章节信息和课程资源需要分开添加,我们可以用inlines去实现使用添加课程的时候添加章节和课程资源.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class LessonInline(object):</span><br><span class="line">    model = Lesson</span><br><span class="line">    extra = 0</span><br><span class="line">class CourseResourceInline(object):</span><br><span class="line">    model = CourseResource</span><br><span class="line">    extra = 0</span><br><span class="line">#在CourseAdmin中使用inlines添加上面两个的方法</span><br><span class="line">class CourseAdmin(object):</span><br><span class="line">    inlines = [LessonInline,CourseResourceInline]    #增加章节和课程资源</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以看到在添加课程页面就可以直接添加与之关联的章节信息和资源的内容.<br><img src="http://qiniu.rearib.top/在线教育平台Mxonline-xadmin的使用/20180901102158603.png" alt=""></p><h2 id="一张表分两个Model来管理"><a href="#一张表分两个Model来管理" class="headerlink" title="一张表分两个Model来管理"></a>一张表分两个Model来管理</h2><p>比如课程里面分为轮播课程和不是轮播课程两种类型，它们是存储在同一张表,但是我们可以分开来管理.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class BannerCourse(Course):</span><br><span class="line">    &apos;&apos;&apos;显示轮播课程&apos;&apos;&apos;</span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name = &apos;轮播课程&apos;</span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line">        #这里必须设置proxy=True，这样就不会再生成一张表，同时还具有Model的功能</span><br><span class="line">        proxy = True   #一种继承的方式</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">普通课程和轮播课程的后台管理通过添加该函数来进行筛选.</span><br><span class="line">def queryset(self):</span><br><span class="line">    # 重载queryset方法，来过滤出我们想要的数据的</span><br><span class="line">    qs = super(CourseAdmin, self).queryset()</span><br><span class="line">    # 只显示is_banner=True的课程</span><br><span class="line">    qs = qs.filter(is_banner=False)</span><br><span class="line">    return qs</span><br></pre></td></tr></table></figure><h2 id="其他常用功能"><a href="#其他常用功能" class="headerlink" title="其他常用功能"></a>其他常用功能</h2><ul><li><p>list_editable : 在列表页可以直接编辑的</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class CourseAdmin(object):</span><br><span class="line">    list_editable = [&apos;degree&apos;,&apos;desc&apos;]</span><br></pre></td></tr></table></figure><p>  <img src="http://qiniu.rearib.top/在线教育平台Mxonline-xadmin的使用/20180901103014984.png" alt=""></p></li><li><p>自定义函数作为列显示</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">model.py</span><br><span class="line">class Course(models.Model):</span><br><span class="line">def get_zj_nums(self):</span><br><span class="line">    #获取课程的章节数</span><br><span class="line">    return self.lesson_set.all().count()</span><br><span class="line">get_zj_nums.short_description = &apos;章节数&apos;   #在后台显示的名称</span><br><span class="line"></span><br><span class="line">adminx.py</span><br><span class="line">class CourseAdmin(object):</span><br><span class="line">    list_display = [&apos;get_zj_nums&apos;]  #直接使用函数名作为字段显示</span><br></pre></td></tr></table></figure><p>  <img src="http://qiniu.rearib.top/在线教育平台Mxonline-xadmin的使用/20180901102952563.png" alt=""></p></li><li><p>显示自定义的html代码</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">model.py</span><br><span class="line">class Course(models.Model):</span><br><span class="line">def go_to(self):</span><br><span class="line">    from django.utils.safestring import mark_safe</span><br><span class="line">    #mark_safe后就不会转义</span><br><span class="line">    return mark_safe(&quot;&lt;a href=&apos;https://home.cnblogs.com/u/derek1184405959/&apos;&gt;跳转&lt;/a&gt;&quot;)</span><br><span class="line">go_to.short_description = &quot;跳转&quot;</span><br><span class="line"></span><br><span class="line">adminx.py</span><br><span class="line">class CourseAdmin(object):</span><br><span class="line">    list_display = [&apos;go_to&apos;]</span><br></pre></td></tr></table></figure><p>  <img src="http://qiniu.rearib.top/在线教育平台Mxonline-xadmin的使用/20180901103213542.png" alt=""></p></li><li><p>refresh定时刷新工具</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class CourseAdmin(object):</span><br><span class="line">    refresh_times = [3,5]           #自动刷新（里面是秒数）</span><br></pre></td></tr></table></figure></li><li><p>字段联动</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class CourseAdmin(object):</span><br><span class="line">    def save_models(self):</span><br><span class="line">        # 在保存课程的时候统计课程机构的课程数</span><br><span class="line">        # obj实际是一个course对象</span><br><span class="line">        obj = self.new_obj</span><br><span class="line">        # 如果这里不保存，新增课程，统计的课程数会少一个</span><br><span class="line">        obj.save()</span><br><span class="line">        # 确定课程的课程机构存在。</span><br><span class="line">        if obj.course_org is not None:</span><br><span class="line">            #找到添加的课程的课程机构</span><br><span class="line">            course_org = obj.course_org</span><br><span class="line">            #课程机构的课程数量等于添加课程后的数量</span><br><span class="line">            course_org.course_nums = Course.objects.filter(course_org=course_org).count()</span><br><span class="line">            course_org.save()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;django自带了admin用于后台管理，但是在github上还有一个更好看、功能更强大的库来管理后台，叫xadmin，今天就来好好介绍一下xadmin的使用。&lt;/p&gt;
&lt;h1 id=&quot;xadmin的安装&quot;&gt;&lt;a href=&quot;#xadmin的安装&quot; 
      
    
    </summary>
    
    
      <category term="django项目" scheme="http://yoursite.com/tags/django%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="Mxonline" scheme="http://yoursite.com/tags/Mxonline/"/>
    
      <category term="xadmin" scheme="http://yoursite.com/tags/xadmin/"/>
    
  </entry>
  
  <entry>
    <title>在线教育平台Mxonline-django基本设置和model设计</title>
    <link href="http://yoursite.com/2018/09/01/%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2%E5%B9%B3%E5%8F%B0Mxonline-django%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE%E5%92%8Cmodel%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/09/01/在线教育平台Mxonline-django基本设置和model设计/</id>
    <published>2018-09-01T05:09:09.000Z</published>
    <updated>2018-10-26T01:24:03.276Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在学习了一段时间的django框架后，也做了几个较为完整的项目，现将整个的过程做个记录和整理，也算是进行一次章节和回顾吧。接下来几天将从项目工程创建到linux服务器部署中较为关键的点进行记录和总结。</p><h1 id="开发环境和开发平台"><a href="#开发环境和开发平台" class="headerlink" title="开发环境和开发平台"></a>开发环境和开发平台</h1><ul><li>win10</li><li>Pycharm</li><li>python3.6.2</li><li>django1.11.6</li></ul><h1 id="虚拟环境的安装与使用"><a href="#虚拟环境的安装与使用" class="headerlink" title="虚拟环境的安装与使用"></a>虚拟环境的安装与使用</h1><ul><li><strong>virtualenv</strong>的安装：在win下使用<code>pip install virtualenv</code>执行安装,安装成功后使用<code>pip list</code>可以查看到版本信息</li><li>在需要创建虚拟环境的目录下执行<code>virtualenv testvir</code>就可以创建一个虚拟环境.</li><li>cd 进入虚拟环境目录,通过dir查看该目录下文件,<code>cd Scripts</code>,执行<code>activate</code>可以激活虚拟环境,执行<code>deactivate.bat</code>可以退出虚拟环境</li><li><strong>virtualenvwrapper</strong>可以进行虚拟环境的管理</li><li>win下安装<code>pip install virtualenvwrapper-win</code>,安装成功后使用<code>mkvirtualenv testEve</code>创建虚拟环境,会提示创建的虚拟环境的位置</li><li>使用workon查看已经安装的虚拟环境,使用<code>workon testEve</code>,如果虚拟环境已经激活,在任何时候执行<code>deactivate.bat</code>就可以退出虚拟环境</li></ul><h1 id="新工程设置"><a href="#新工程设置" class="headerlink" title="新工程设置"></a>新工程设置</h1><p>&emsp;&emsp;工程目录下创建log(日志)、media(上传文件)、templates(模板文件)、static(静态文件)，并新建setting_dev.py用于存储密码等信息，如果将项目托管于github可以把该文件放到.gitignore.<br>&emsp;&emsp;在工程目录下新建apps用于存放所有app,此时导入需要<code>from apps.app1 import views</code>,可以apps右键Mark Directory As - Sources Root(全局搜索路径),然后就可以通过<code>from app1 import views</code>,但是Mark后Pycharm能识别,但是使用命令行无法识别,需要再在setting中添加:</p><blockquote><p>sys.path.inser(0,os.path.join(BASE_DIR,’apps’))                   </p></blockquote><h2 id="其他配置："><a href="#其他配置：" class="headerlink" title="其他配置："></a>其他配置：</h2><ul><li>数据库切换成mysql,安装mysqlclient连接myql,同时在setting_dev.py中配置数据库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    &apos;default&apos;: &#123;</span><br><span class="line">        &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;,</span><br><span class="line">        &apos;NAME&apos;: &apos;mxonline&apos;,        #数据库名字</span><br><span class="line">        &apos;USER&apos;: &apos;root&apos;,            #账号</span><br><span class="line">        &apos;PASSWORD&apos;: &apos;123456&apos;,      #密码</span><br><span class="line">        &apos;HOST&apos;: &apos;127.0.0.1&apos;,       #IP</span><br><span class="line">        &apos;PORT&apos;: &apos;3306&apos;,            #端口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在setting.py配置上传文件和静态文件的路径:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">STATIC_URL = &apos;/static/&apos;</span><br><span class="line">STATICFILES_DIRS = (</span><br><span class="line">    os.path.join(BASE_DIR,&apos;static&apos;),</span><br><span class="line">)</span><br><span class="line">MEDIA_URL = &apos;/media/&apos;</span><br><span class="line">MEDIA_ROOT = os.path.join(BASE_DIR,&apos;media&apos;)</span><br></pre></td></tr></table></figure></li><li>在url中配置处理图片的视图函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from django.conf.urls.static import static</span><br><span class="line">from django.conf import settings</span><br><span class="line">if settings.DEBUG:</span><br><span class="line">    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)</span><br></pre></td></tr></table></figure></li><li>修改语言和时区<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LANGUAGE_CODE = &apos;zh_hans&apos;</span><br><span class="line">TIME_ZONE = &apos;Asia/Shanghai&apos;</span><br><span class="line">USE_I18N = True</span><br><span class="line">USE_L10N = True</span><br><span class="line">USE_TZ = False</span><br></pre></td></tr></table></figure>&emsp;&emsp;根据项目要求,会有一个users、course、organization的app,同时针对用户的各种操作设计operation的app<blockquote><p>python manage.py startapp users<br>python manage.py startapp course<br>python manage.py startapp organization<br>python manage.py startapp operation</p></blockquote></li></ul><h1 id="model设计"><a href="#model设计" class="headerlink" title="model设计"></a>model设计</h1><p>&emsp;&emsp;在model设计之前一定要梳理每一个model需要哪些字段,这是一个项目的关键.<br><img src="http://qiniu.rearib.top/Django+xadmin%E6%89%93%E9%80%A0%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2%E5%B9%B3%E5%8F%B0-django%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE%E5%92%8Cmodel%E8%AE%BE%E8%AE%A1/20180901034210471.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;在学习了一段时间的django框架后，也做了几个较为完整的项目，现将整个的过程做个记录和整理，也算是进行一次章节和回顾吧。接下来几天将从项目工程创建到linux服务器部署中较为关键的点进行记录和总结。&lt;/p&gt;
&lt;h1 id=&quot;开发环境和开发平台&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="django项目" scheme="http://yoursite.com/tags/django%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="Mxonline" scheme="http://yoursite.com/tags/Mxonline/"/>
    
  </entry>
  
  <entry>
    <title>常用Markdown语法说明</title>
    <link href="http://yoursite.com/2018/08/30/%E5%B8%B8%E7%94%A8Markdown%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/2018/08/30/常用Markdown语法说明/</id>
    <published>2018-08-30T13:10:19.000Z</published>
    <updated>2018-10-26T01:26:49.750Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，它允许人们“使用易读易写的纯文本格式”编写文档，本文主要针对Hexo中Markdown常用的语法进行总结，更详细的内容请参考Hexo官方书写格式<a href="https://hexo.io/zh-cn/docs/tag-plugins#Image" target="_blank" rel="noopener">链接</a>和Markdown书写格式<a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">链接</a></p><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>Markdown支持两种标题的语法，Setext和atx形式：Setext形式是用底线的形式，利用 = (最高阶标题)和 - (第二阶标题)。Atx形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。<br><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180830101415216.png" alt=""></p><h1 id="最高阶标题"><a href="#最高阶标题" class="headerlink" title="最高阶标题"></a>最高阶标题</h1><h2 id="第二阶标题"><a href="#第二阶标题" class="headerlink" title="第二阶标题"></a>第二阶标题</h2><h1 id="H1标题"><a href="#H1标题" class="headerlink" title="H1标题"></a>H1标题</h1><h2 id="H2标题"><a href="#H2标题" class="headerlink" title="H2标题"></a>H2标题</h2><h3 id="H3标题"><a href="#H3标题" class="headerlink" title="H3标题"></a>H3标题</h3><h4 id="H4标题"><a href="#H4标题" class="headerlink" title="H4标题"></a>H4标题</h4><h5 id="H5标题"><a href="#H5标题" class="headerlink" title="H5标题"></a>H5标题</h5><h6 id="H6标题"><a href="#H6标题" class="headerlink" title="H6标题"></a>H6标题</h6><h1 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h1><p>区块引用则使用 email 形式的 ‘&gt;’ 角括号。<br><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180830101428434.png" alt=""></p><blockquote><p>区块引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote><h1 id="修辞和强调"><a href="#修辞和强调" class="headerlink" title="修辞和强调"></a>修辞和强调</h1><p>强调内容两侧分别加上星号或者底线。<br><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180831094029082.png" alt=""><br><em>斜体</em><br><strong>粗体</strong><br><del>删除</del></p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><ul><li>至少一个-</li><li>使用:来设置对其方式</li></ul><p><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180831094343570.png" alt=""></p><table><thead><tr><th style="text-align:left">第一列</th><th style="text-align:right">第二列</th><th style="text-align:center">第三列</th></tr></thead><tbody><tr><td style="text-align:left">内容</td><td style="text-align:right">内容</td><td style="text-align:center">内容</td></tr></tbody></table><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>无序列表使用星号、加号或减号来做为列表。<br><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180830101500576.png" alt=""></p><ul><li>一号</li><li>二号</li></ul><ul><li>三号</li><li>四号</li></ul><ul><li>五号</li><li>六号</li></ul><h1 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h1><p><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180830101514715.png" alt=""></p><ol><li>一号</li><li>二号</li></ol><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180831094437848.png" alt=""><br>这是我的<a href="http://blog.rearib.top" target="_blank" rel="noopener">博客</a>地址</p><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180831101823686.png" alt=""></p><hr><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>图片的语法和链接很像，只需在链接的基础上前方加一个！<br>注意图片大小的设置方式,关于其他设置可以参考<a href="https://developer.qiniu.com/dora/manual/3683/img-directions-for-use" target="_blank" rel="noopener">七牛云</a><br><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180831101811191.png" alt=""><br><img src="http://qiniu.rearib.top/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180706201017_eviCsbl.jpg?imageView2/1/w/200/h/200/" alt="我的头像"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180831101753642.png" alt=""><br><figure class="highlight objc"><figcaption><span>main.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; i = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">      printf(<span class="string">"hello markdown!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h1><p><img src="http://qiniu.rearib.top/常用Markdown语法说明/20180831103438948.png" alt=""></p><ul><li style="list-style: none"><input type="checkbox" checked> 选项一</li><li style="list-style: none"><input type="checkbox"> 选项二  </li><li style="list-style: none"><input type="checkbox"> 选项三</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Markdown 是一种轻量级标记语言，它允许人们“使用易读易写的纯文本格式”编写文档，本文主要针对Hexo中Markdown常用的语法进行总结，更详细的内容请参考Hexo官方书写格式&lt;a href=&quot;https://hexo.io/zh-cn/docs/tag-plugi
      
    
    </summary>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
</feed>
